<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XPS13-intel-CPU超频导致发热严重</title>
    <url>/2020/06/07/XPS13-intel-CPU%E8%B6%85%E9%A2%91%E5%AF%BC%E8%87%B4%E5%8F%91%E7%83%AD%E4%B8%A5%E9%87%8D/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>前段时间入手了一台xps13,安装了fedora28后,经常在启动和关机时出项cpu过热的报警信息:</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[26670.911219] CPU1: Core temperature above threshold, cpu clock throttled (total events &#x3D; 1)</span><br><span class="line">[26670.911221] CPU0: Core temperature above threshold, cpu clock throttled (total events &#x3D; 1)</span><br><span class="line">[26670.911222] CPU2: Package temperature above threshold, cpu clock throttled (total events &#x3D; 1)</span><br><span class="line">[26670.911223] CPU3: Package temperature above threshold, cpu clock throttled (total events &#x3D; 1)</span><br><span class="line">[26670.911224] CPU0: Package temperature above threshold, cpu clock throttled (total events &#x3D; 1)</span><br><span class="line">[26670.911232] CPU1: Package temperature above threshold, cpu clock throttled (total events &#x3D; 1)</span><br></pre></td></tr></table></figure>

<p>主要是由于主板打开了超频选项,内核也支持超频,使得cpu由1.2GHZ超频到4GHZ以上,明显感觉主机发热严重.使用<code>s-tui</code>记录CPU温度都达到100度.真的是<em>烤鸡</em>了…</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>查阅相关资料显示,intel的cpu可以通过修改<code>/sys/devices/system/cpu/intel_pstate</code>下的设置修改cpu超频.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╰─$ ls /sys/devices/system/cpu/intel_pstate </span><br><span class="line">max_perf_pct  min_perf_pct  no_turbo  num_pstates  status  turbo_pct</span><br></pre></td></tr></table></figure>

<p>可以通过修改<code>no_turbo</code>为<code>1</code>来关闭超频.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 |sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo</span><br></pre></td></tr></table></figure>

<p>cpu温度明显的降到了40度左右,发热现象消失了.<br>开了n个虚拟机和chrome视频站点以及vscode,检测cpu的使用率并未负载严重,说明这样已经基本满足日常使用需求了,起码可以省电,减少发热.</p>
<p>这样做在重启后会失效,除非自己修改内核配置再编译内核.关闭内核超频开关,或者开机F12进入主板设置,把turbo关闭.<br>但是这样做不够灵活,万一我突然有大量的计算要跑呢?</p>
<p>工具和方法有很多:</p>
<p>可以参考这里的回答:<a href="https://askubuntu.com/questions/391474/stop-cpu-from-overheating/875872#875872" target="_blank" rel="noopener">stop cpu from overheating</a></p>
<ul>
<li><p>TLP工具是个选择,不仅能够减少发热,还能极端的降低电池消耗,延长电池使用时间.</p>
</li>
<li><p>简单点的即使关闭<code>turbo</code>,可以通过systemd自动加载服务的方式来保证开机自动关闭参考<a href="https://blog.christophersmart.com/2017/02/08/manage-intel-turbo-boost-with-systemd/" target="_blank" rel="noopener"><br>  Manage Intel Turbo Boost with systemd</a>:<br>  新建一个文件<code>/usr/lib/systemd/system/disable-turbo-boost.service</code> 打开并编辑该文件写入:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Disable Turbo Boost on Intel CPU</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;bin&#x2F;echo 1 &gt; \</span><br><span class="line">&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;intel_pstate&#x2F;no_turbo&quot;</span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;bin&#x2F;echo 0 &gt; \</span><br><span class="line">&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;intel_pstate&#x2F;no_turbo&quot;</span><br><span class="line">RemainAfterExit&#x3D;yes</span><br><span class="line">User&#x3D;root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;sysinit.target</span><br></pre></td></tr></table></figure>

<p>使用<code>sudo systemctl daemon-reload</code>加载服务配置<br>使用:<code>sudo systemctl enable disable-turbo-boost.service</code>来开启该服务,<br>使用<code>sudo systemctl start disable-turbo-boost.service</code>来启动该服务.<br>这样就可以开机自动启动关闭turbo的功能.如果像临时关闭turbo,那么就使用<code>sudo systemctl stop disable-turbo-boost.service</code></p>
<ul>
<li>可是我不想每次需要关闭的时候都去执行systemd命令,我想在gnome dash中执行程序,那么在gnome下我也可以自己新建一个app:    <code>~/.local/share/applications/open-turbo.desktop</code><br>编辑其内容为:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version&#x3D;1.0</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">Name&#x3D;openturbo</span><br><span class="line">Comment&#x3D;open cpu turbo boost</span><br><span class="line">Exec&#x3D;gksudo -k -u root &#x2F;bin&#x2F;sh -c &quot;&#x2F;usr&#x2F;bin&#x2F;echo 0 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;intel_pstate&#x2F;no_turbo&quot;</span><br><span class="line">Terminal&#x3D;false</span><br><span class="line">Categories&#x3D;Utilities;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你习惯使用gnome的插件,希望在桌面就可以控制cpu频率上限和超频选项,那么可以使用<a href="https://extensions.gnome.org/extension/945/cpu-power-manager/" target="_blank" rel="noopener">extension</a>,其代码地址<a href="https://github.com/martin31821/cpupower" target="_blank" rel="noopener">github</a></li>
</ul>
<p>有关于tubo加速的内核参数设置可以参考这里<a href="http://lynnapan.github.io/2016/12/15/Turbo%E5%92%8CIntel_Pstate/" target="_blank" rel="noopener">服务器server的频率知识整理</a>:</p>
]]></content>
      <categories>
        <category>折腾笔记</category>
      </categories>
      <tags>
        <tag>fedora</tag>
        <tag>linux</tag>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 学习笔记</title>
    <url>/2020/06/07/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>docker 学习笔记</h1>

<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>docker的功能比较像一个chroot应用,拥有一个守护进程daemon.</p>
<p>docker容器并不是一个完整的系统,不包含linux内核,并且只是一个最小系统.docker容器的内核依旧是宿主系统的内核.docker利用了linux内核的<strong>命名空间namespace</strong>,<strong>容器组cgroup</strong>,<strong>设备映射</strong>的技术.</p>
<a id="more"></a>
<p>docker的命令使用起来比较像git.</p>
<p>docker拥有官方hub和可以私有搭建的镜像库registry(默认docker官方的docker hub),提供镜像下载服务.</p>
<p>docker文件系统利用了<strong>联合加载(union mount)</strong>和<strong>写时复制(copy on write)</strong>的技术(aufs也是该技术),可以在文件系统上叠加文件结构,形成层级关系,但是从纵向看过去就像一个文件系统.通过镜像库下载的镜像作为最底层rootfs,并不能被修改,而是每次修改都记录在一个层中,在最顶层加载一个读写文件系统,使得看上去好像我们修改了底层系统一样.</p>
<p>docker目前使用时必须具有<strong>root权限</strong>.因为需要用到宿主底层的接口.</p>
<p>docker启动后会修改镜像中的<code>/etc/hosts</code>和<code>/etc/resolv.conf</code>文件,使得docker容器可以使用主机的网络环境,以及记录docker network子网路由解析信息等.docker会感知所使用网络下的所有容器并将相应的DNS信息写入每个容器的<code>/etc/hosts</code>中,如果指定了容器的名称,主机可以使用hostname.netname的形式解析DNS.</p>
<p>docker容器默认不对外公开任何接口,是无法访问的,需要给容器指定对外的接口</p>
<p>docker默认使用<strong>172.17.x.x</strong>作为子网地址,除非该子网被占用.如果占用,则从<strong>172.16~172.30</strong>中尝试.</p>
<p>docker安装时会创建一个新的网络接口<strong>docker0</strong>,作为默认网络桥.它是一个虚拟的以太网桥,用于连接宿主和容器.docker每创建一个容器就会创建一组互联的网络接口,一端作为容器的eth0接口,一端作为veth开头的接口存在与宿主作为一个宿主端口,可以认为它是一根网线连接在docker0和容器内网卡上.</p>
<p>(1.9版本以上)可以创建自己的专用容器间网络,称为<strong>Docker Networking</strong>.使得容器可以跨越不同的主机进行通信,并且是支持可插拔的.</p>
<p>docker容器间通讯的两种方式: 通过docker网络 和 使用link链接连接容器.</p>
<h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><p><strong>守护进程/usr/bin/docker启动选项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--log-driver 下同docker run的 --log-driver,版本1.6以后可用</span><br><span class="line">-insecure-registry localhost:5000 &#x2F;&#x2F;启动守护进程时指定本地registry</span><br><span class="line">--ice&#x3D;false 关闭所有没有链接的容器间的通讯</span><br><span class="line">-H tcp:&#x2F;&#x2F;0.0.0.0:2375 将docker守护进程绑定到宿主机的所有网络的2375端口上DOCKER_HOST环境变量代指该参数</span><br><span class="line">-d 作为daemon守护进程启动在后台</span><br></pre></td></tr></table></figure>

<p><strong>启动基于容器的本地registry</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 5000:5000 registry:2</span><br></pre></td></tr></table></figure>

<p><strong>docker run</strong> 创建并运行一个容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -i -t ubuntu:16.04 &#x2F;bin&#x2F;bash &#x2F;&#x2F;镜像名ubuntu后加:16.04指定ubuntu仓库类目下的某一镜像16.04,&#x2F;bin&#x2F;bash是启动容器后需要执行的命令</span><br><span class="line"></span><br><span class="line">-i 保证stdin开启,以便支持交互式访问容器</span><br><span class="line">-t 为容器分配一个伪tty终端,以便交互式访问容器</span><br><span class="line">-d 将容器放在后台运行,使用deamon模式</span><br><span class="line">-p 8080:80 指定docker容器运行时对外公开的端口,将容器的80端口映射到宿主机的8080端口,</span><br><span class="line">-p 80 则docker在宿主机中从32768-61000中选择一个端口号映射到容器的80端口</span><br><span class="line">-p 127.0.0.1:8080:80&#x2F;udp 则指定了绑定的本地宿主机的IP,并且指定UDP端口.</span><br><span class="line">-P 对外公开在Dockerfile中使用EXPOSE指令公开的所有端口</span><br><span class="line">--name 为启动的容器指定一个名称,即容器名,而不是使用自动生成的名称,支持a-z,A-Z,0-9,下划线,圆点,横线,即正则:[a-zA-Z0-9_.-]</span><br><span class="line">--log-driver 控制容器使用日志驱动,可选:syslog(禁用docker logs并将所有容器日志重定向到syslog中),默认json-file,none(禁用日志)等</span><br><span class="line">--restart&#x3D;always&#x2F;on-failure:5 让容器自动重启,always是一直重启,on-failure指定容器退出代码非0后重启,后面数字指定当容器退出代码非0以后重启的次数.(1.2版本以后)</span><br><span class="line">--entrypoint 标志可以覆盖ENTRYPOINT指令</span><br><span class="line">-w 指令会在运行时覆盖WORKDIR工作目录设置 -w &#x2F;var&#x2F;log</span><br><span class="line">-e 传递环境变量 -e &quot;WEB&#x3D;&#x2F;var&#x2F;www&#x2F;html&quot;</span><br><span class="line">-u 覆盖USER指令</span><br><span class="line">--build-arg 开启ARG参数,其后可以给参数指定值,如 --build-arg build&#x3D;1234</span><br><span class="line">-v 指定一个目录映射对应于容器内的一个目录,将宿主机中的目录作为卷挂载到容器,使用:分割,后面加ro(只读)或rw(可读写)指定读写权限,如果容器内目录不存在则自动创建一个. 如: -v &#x2F;home&#x2F;web:&#x2F;var&#x2F;www&#x2F;html:ro</span><br><span class="line">--net&#x3D;mynet 指定运行时使用的docker网络</span><br><span class="line">--link A:B 创建两个容器间的C-S链接,A是要链接的容器名,B是链接的别名.--link链接的容器不需要对外公开接口.可以多处使用指定多个容器.docker会在父容器修改&#x2F;etc&#x2F;hosts和写入包含链接信息的环境变量(以别名B的大写开头).</span><br><span class="line">--hostname 或-h 指定容器的主机名,容器内主机的名称</span><br><span class="line">--add-host 在&#x2F;etc&#x2F;hosts中添加主机记录</span><br><span class="line">--dns或--dns-search为某个容器单独配置DNS(写入&#x2F;etc&#x2F;resolv.conf).</span><br><span class="line">--privileged 启动docker特权模式,允许以宿主机具有的(几乎)所有能力来运行容器,包括内核特性和设备访问,用来在docker中运行docker.容器在这个模式下对宿主具有root访问权限.</span><br><span class="line">--cidfile&#x3D;&#x2F;tmp&#x2F;container.id.txt,让docker截获容器ID并存到指定的文件里.</span><br><span class="line">--volume-from ubuntu-test 把指定容器ubuntu-test里的所有卷都加入到新创建的容器里,即便ubuntu-test没有运行,也能访问到它的卷.即使删除了使用卷的最后一个容器,卷中的数据也会持久保存.</span><br><span class="line">--rm 标志创建只用一次的容器,使用完就删除.可以用于测试或者备份容器内的卷:</span><br><span class="line"></span><br><span class="line">sudo docker run --rm --volumes-from ubuntu-test -v &#x2F;home:&#x2F;backup ubuntu tar cvf &#x2F;backup&#x2F;bk.tar &#x2F;data  </span><br><span class="line">&#x2F;&#x2F;使用ubuntu基础镜像创建一个只用一次的镜像,将宿主本地&#x2F;home目录挂载到ubuntu-test容器的&#x2F;backup下,并且执行压缩命令将&#x2F;data目录下的文件压缩到&#x2F;backup&#x2F;bk.tar文件中.这样在宿主的目录下就会有一个bk.tar作为ubuntu-test下的&#x2F;data的备份.</span><br></pre></td></tr></table></figure>

<p><strong>docker ps</strong> 列出正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a 列出所有容器</span><br><span class="line">-q 只返回容器的ID列不返回其他信息</span><br></pre></td></tr></table></figure>

<p><strong>docker start</strong> 启动已经创建并停止的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker start ubuntu_test</span><br></pre></td></tr></table></figure>

<p><strong>docker attach</strong> 重新附着到重启以后的容器会话上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker attach ubuntu_test</span><br></pre></td></tr></table></figure>

<p><strong>docker logs</strong> 获取容器的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker logs ubuntu_test</span><br><span class="line"></span><br><span class="line">-f 持续监控容器日志,类似tail -f,crtl+c退出监控</span><br><span class="line">-t 为每条日志加上时间戳,便于调试</span><br></pre></td></tr></table></figure>

<p><strong>docker top</strong> 查看以守护式方式运行在后台的容器内的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker top ubuntu_test</span><br></pre></td></tr></table></figure>

<p><strong>docker exec</strong> 在正在运行容器内部执行新的命令或额外启动新的进程(1.3版本以后)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker exec -d ubuntu_test touch 1.file</span><br><span class="line"></span><br><span class="line">-d 指定要在内部执行命令的容器的名字和执行的命令</span><br><span class="line">-u 为新启动的进程指定一个用户属性(1.7版本以后)</span><br></pre></td></tr></table></figure>

<p><strong>docker stop</strong> 停止守护式的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker stop c2c4e57c12</span><br></pre></td></tr></table></figure>

<p><strong>docker kill</strong> 发送信号给容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker kill -s &lt;sibnal&gt; &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p><strong>docker inspect</strong> 获取容器的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker inspect ubuntu_test</span><br><span class="line">-f&#x2F;--format&#x3D;&#123;&#123; &#125;&#125; 筛选结果,支持使用go的模板</span><br><span class="line">sudo docker inspect --format&#x3D;&#39;&#123;&#123; .Config.Hostname &#125;&#125;&#39; ubuntu_test 只显示出Config下Hostname子项的内容</span><br></pre></td></tr></table></figure>

<p><strong>docker rm</strong> 删除不再使用的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker rm 80430f8d</span><br><span class="line">-f 强制删除正在运行的容器</span><br><span class="line">sudo docker rm $(sudo docker ps -a -q) 组合命令可以删除所有容器</span><br></pre></td></tr></table></figure>

<p><strong>docker rmi</strong> 删除一个或多个镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker rmi ubuntu_test test &#x2F;&#x2F;删除多个镜像</span><br><span class="line">sudo docker rmi $(sudo docker images -a -q) &#x2F;&#x2F;删除所有镜像</span><br></pre></td></tr></table></figure>

<p><strong>docker images</strong> 列出docker镜像</p>
<p>本地的镜像都保存在<code>/var/lib/docker</code>下,所有容器在<code>/var/lib/docker/container</code>下</p>
<p><strong>docker pull</strong> 将某个镜像从registry中拉取下来到本地</p>
<p><code>sudo docker pull fedora:20</code></p>
<p><strong>docker search</strong> 在registry中查询某个镜像</p>
<p><code>sudo docker search ubuntu</code></p>
<p><strong>docker commit</strong> 提交某个镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker commit -m &quot;new image&quot; -a &quot;my&quot; 433b23ce mydockeraccount&#x2F;test:webser &#x2F;&#x2F;将433b23ce这个镜像提交到docker hub中我的账号下名为test的仓库类目下并且使用:指定了镜像标签为webser</span><br><span class="line"></span><br><span class="line">-m 指定新创建的镜像的提交信息</span><br><span class="line">-a 指定该镜像的作者信息</span><br></pre></td></tr></table></figure>

<p><strong>docker build</strong> 使用Dockerfile文件构建镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以使用 镜像名:标签 的格式可以设置镜像标签,如果没有指定标签自动设置latest标签</span><br><span class="line">-t 为新构建镜像设置仓库和名称</span><br><span class="line">-f 指定区别于默认的位置的Dockerfile,如 -f path&#x2F;to&#x2F;file,这个位置相对于构建环境上下文目录.</span><br><span class="line">--no-cache 关闭缓存功能,每次构建都重头开始,不使用缓存.</span><br></pre></td></tr></table></figure>

<p><strong>docker login</strong> 登录doker hub</p>
<p><code>sudo docker login</code>登录信息记录在<code>$HOME/.dockercfg</code>或<code>$HOME/.docker/config.json(1.7版本以上)</code>中</p>
<p><strong>docker logout</strong> 退出registry</p>
<p><strong>docker history</strong> 查看镜像构建的每一步都做了什么,是如何构建出来的</p>
<p><code>sudo docker history 22d48fg //列出该镜像构建时的每一层和Dockerfile指令</code></p>
<p><strong>docker port</strong> 查看容器的端口映射情况</p>
<p><code>sudo docker port ubuntu-test 80 //查看ubuntu-test的80端口映射到宿主哪个端口</code></p>
<p><strong>docker network</strong> docker networking 相关操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker network create mynet &#x2F;&#x2F;创建名为mynet的docker桥接网络,命令返回该网络的ID.创建overlay网络会允许我们在多宿主间通信.</span><br><span class="line"></span><br><span class="line">sudo docker network inspect mynet &#x2F;&#x2F;查看创建的docker网络</span><br><span class="line"></span><br><span class="line">sudo docker network ls &#x2F;&#x2F;列出当前系统中的所有docker网络</span><br><span class="line"></span><br><span class="line">sudo docker network connect mynet ubuntu-test&#x2F;&#x2F;添加正在运行的容器ubuntu-test到已有的网络mynet中</span><br><span class="line"></span><br><span class="line">sudo docker network disconnect mynet ubuntu-test&#x2F;&#x2F;从网络mynet中断开容器ubuntu-test</span><br><span class="line"></span><br><span class="line">docker run 时可以指定容器允许所使用的网络</span><br></pre></td></tr></table></figure>




<h2 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h2><p>Dockerfile使用DSL语法,所有指令都必须为大写.</p>
<p>Dockerfile是顺序执行的.</p>
<p>在构建环境(上下文)目录(即使用当前所处在的目录位置为构建环境)下,新建名为Dockerfile的文件.Dockerfile大致执行流程为:从基础镜像运行一个容器,每次执行一个指令修改并提交操作生成新的镜像层,在该镜像层基础上运行新的容器,再重复执行下一条指令.某一指令执行失败可以使用上一指令执行后的容器名称进行调试.</p>
<p>docker构建每一步都会提交为镜像,就使得之前构建过程中的镜像可以被当作缓存,再次执行构建操作时如果构建操作没有变化会略过构建而直接使用缓存.</p>
<p>构建环境下.dockeignore文件可以指定目录下那些文件不被当作构建环境中的上下文的一部分,类似git的gitignore.该文件使用go的filepath中的匹配规则.</p>
<p>每个Dockerfile的第一条指令必须是FROM.</p>
<p><strong>RUN</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定镜像被构建时运行的命令</span><br><span class="line"></span><br><span class="line">RUN pip install -r requirement.txt &#x2F;&#x2F;执行pip命令从requirement.txt文件中读取需要安装的依赖名并安装.</span><br><span class="line">RUN会在shell中默认使用&#96;&#x2F;bin&#x2F;sh -c &#96;作为执行命令的前缀</span><br><span class="line"></span><br><span class="line">推荐使用数组格式的RUN指令: RUN [ &quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot; ],数组语法</span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定容器启动时要运行的命令</span><br><span class="line"></span><br><span class="line">CMD [ &quot;&#x2F;bin&#x2F;bash&quot;, &quot;-l&quot; ],使用数组语法,不指定时docker会在命令前加&#96;&#x2F;bin&#x2F;sh -c&#96;(-c 表示使用后续字符串作为命令而不是从标准输入读取命令),推荐使用数组语法. </span><br><span class="line">docker run可以覆盖CMD指令.</span><br></pre></td></tr></table></figure>

<p><strong>ENTRYPOINT</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定在运行时要运行的命令,且不会轻易被run指令覆盖.</span><br><span class="line"></span><br><span class="line">docker run指令中的参数被作为该命令的参数传递给ENTRYPOINT中的指令.</span><br><span class="line">可以同时使用CMD和ENTRYPOINT,指定启动时的默认行为:</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;nginx&quot;]</span><br><span class="line">CMD [&quot;-g&quot;,&quot;daemon off&quot;]</span><br><span class="line">指定默认启动nginx并让nginx守护进程以前台方式运行(避免容器自动退出),docker run 命令以其他参数 如 -h 覆盖该指令行为.</span><br><span class="line">docker run 的--entrypoint 标志可以覆盖ENTRYPOINT</span><br></pre></td></tr></table></figure>

<p><strong>WORKDIR</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定一个工作目录,后续的ENTRYPOINT和CMD指令会在这个目录下执行.</span><br><span class="line"></span><br><span class="line">WORKDIR &#x2F;home</span><br><span class="line">docker run 的-w指令会在运行时覆盖工作目录</span><br></pre></td></tr></table></figure>

<p><strong>ENV</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定镜像构建过程中的环境变量.</span><br><span class="line"></span><br><span class="line">这些变量会永久保留到从这个镜像创建的任何容器.</span><br><span class="line">docker run 使用-e 传递环境变量</span><br><span class="line">ENV WWW &#x2F;var&#x2F;www&#x2F;html &#x2F;&#x2F;指定WWW变量代表&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">WORKDIR $WWW &#x2F;&#x2F;切换工作目录到&#x2F;var&#x2F;www&#x2F;html</span><br></pre></td></tr></table></figure>

<p><strong>USER</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定镜像以什么用户运行</span><br><span class="line"></span><br><span class="line">USER uid:gid</span><br><span class="line">USER user </span><br><span class="line">USER group </span><br><span class="line">&#x2F;&#x2F;指定用户和组或用户或组,不指定则默认使用root用户.</span><br><span class="line">docker run 使用-u 覆盖该指令</span><br></pre></td></tr></table></figure>

<p><strong>VOLUME</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指定一个目录位置,用来向基于镜像创建的容器添加卷</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;&#x2F;var&#x2F;www&#x2F;html&quot;]</span><br><span class="line">一个卷可以存在与多个容器内的特定目录,即可以共享,这个特定的目录会绕过联合文件系统.</span><br><span class="line">一个容器可以不和其他容器共享卷</span><br><span class="line">对卷的修改是立即生效的</span><br><span class="line">对卷的修改不会对镜像产生影响</span><br><span class="line">卷会一直存在直到没有任何容器再使用它.</span><br><span class="line">卷可以方便向镜像中添加数据代码等而不用提交新的镜像.</span><br><span class="line">可以使用数组方式指定多个卷VOLUME [&quot;&#x2F;var&#x2F;www&#x2F;html&quot;,&quot;&#x2F;tmp&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>ADD</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用来将构建环境下的文件和目录或URL位置对应的资源复制到镜像中.</span><br><span class="line"></span><br><span class="line">ADD subdir&#x2F;test.txt &#x2F;home&#x2F;test&#x2F;</span><br><span class="line">不能对构建环境以外的文件进行操作.</span><br><span class="line">docker通过地址的结尾字符来判断目标位置是文件还是目录,以&#x2F;结尾的均看做目录.</span><br><span class="line">ADD对于gzip,bzip,xz源文件会自动解压,与tar -x功能类似.如果目的地址已经存在同名文件或目录不会覆盖.如果目的位置不存在会创建全路径(包含路径中任何目录),新创建的文件和目录mod为0755,gid和uid为0.</span><br><span class="line">ADD指令会使得构建缓存机制变得无效.</span><br></pre></td></tr></table></figure>

<p><strong>COPY</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似ADD,COPY只在构建上下文中复制本地文件,不做提取和解压工作.</span><br><span class="line">目的地址必须是容器内的绝对路径.</span><br></pre></td></tr></table></figure>

<p><strong>LABEL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1.6版本以上)为docker镜像添加元数据,元数据以键值对形式出现,推荐所有元数据放在一列,以免创建多层镜像.</span><br><span class="line"></span><br><span class="line">LABEL ver&#x3D;&quot;1.1&quot; type&#x3D;&quot;date&quot;</span><br></pre></td></tr></table></figure>

<p><strong>STOPSIGNAL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1.9版本以上)设置停止容器时发送的系统调用信号,必须是内核系统调用表中的合法的数,如 SIGKILL,9</span><br></pre></td></tr></table></figure>

<p><strong>ARG</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1.9版本以上)定义可以在docker build 命令运行时传递给构建的变量.构建时只需使用--build-arg标志即可.</span><br><span class="line"></span><br><span class="line">ARG build &#x2F;&#x2F;未指定build参数的默认值</span><br><span class="line">ARG target&#x3D;&#x2F;var&#x2F;www&#x2F;html &#x2F;&#x2F;指定了target参数的默认值</span><br><span class="line">docker预定义的ARG变量,无需在Dockerfile中定义:</span><br><span class="line">HTTP_PROXY</span><br><span class="line">http_proxy</span><br><span class="line">HTTPS_PROXY</span><br><span class="line">https_proxy</span><br><span class="line">FTP_PROXY</span><br><span class="line">ftp_proxy</span><br><span class="line">NO_PROXY</span><br><span class="line">no_proxy</span><br></pre></td></tr></table></figure>

<p><strong>ONBUILD</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为镜像添加触发器,当一个镜像被用作其他镜像构建的基础镜像时会触发执行,在构建过程中插入新的指令.相当于这些指令紧跟在构建其他镜像的Dockerfile的FROM后面.</span><br><span class="line"></span><br><span class="line">ONBUILD ADD . &#x2F;app&#x2F;</span><br><span class="line">ONBUILD会顺序执行,并且只能被继承一次,不会出现在孙子镜像中.</span><br><span class="line">FROM,MAINTAINER,ONBUILD不能被用在ONBUILD中,以防递归.</span><br></pre></td></tr></table></figure>


<h2 id="Remote-API"><a href="#Remote-API" class="headerlink" title="Remote API"></a>Remote API</h2><p>docker守护进程提供remote api, 默认情况下会在宿主创建套接字<code>unix:///var/run/docker.sock</code></p>
<p><code>echo -e &quot;GET /info HTTP/1.0\r\n&quot; |sudo nc -U /var/run/dcoker.sock // 查询本地docker API</code></p>
<p>要启动docker API 需要使用-H给守护进程传递参数,可以修改守护进程的启动配置文件,将守护进程永久绑定到指定的网络接口上.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu&#x2F;Debain:	&#x2F;etc&#x2F;default&#x2F;dcoker</span><br><span class="line">RedHat&#x2F;Fedora:	&#x2F;etc&#x2F;sysconfig&#x2F;docker</span><br><span class="line">使用systemd的版本:	&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br></pre></td></tr></table></figure>
<p>可以使用POST请求来调用/container/create接入点来创建容器,等同于<code>docker run</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type: application&#x2F;json&quot; http:&#x2F;&#x2F;localhost:2375&#x2F;container&#x2F;create -d &#39;&#123;&quot;Image&quot;:&quot;ubuntu-test&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>docker官网有<a href="http://docs.docker.com/reference/api/remote_api_client_libraries/" target="_blank" rel="noopener">docker Remote API客户端库</a>的完整列表.</p>
<p>Docker Remote API 可以使用TLS/SSL进行认证,确保安全.需要自己创建CA证书.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>pythonic技巧</title>
    <url>/2020/06/07/pythonic-%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="pythonic-技巧"><a href="#pythonic-技巧" class="headerlink" title="pythonic 技巧"></a>pythonic 技巧</h1><ol>
<li><p>赋值可以采用元组赋值方法: <code>a,b = 1, 2</code> , 函数的返回值也可是多值返回, <code>a, b = test(c)</code>这一点与golang很像, 支持多个, 对于数组赋值也可以通过序列解包来进行赋值<code>a,b = [1,2]</code></p>
</li>
<li><p>对于方法处理,可以进行多次嵌套, 如 <code>a.split(&#39;\n&#39;).strip()</code></p>
</li>
<li><p>if…else….可以进行三目运算,类似c语言, <code>a = b if a &gt; 10 else c</code></p>
<a id="more"></a></li>
<li><p>多值判断用 <code>if 70 &lt; a &lt; 90 :</code> 不用 <code>if a &gt; 70 and a &lt; 90</code> 或者使用<code>if a in (1,2,3):</code>判断多个条件, 判断空值或None 用<code>if a</code>而不是 <code>if len(a)&gt;0 or a != None</code>,判断多个and 或 or条件 可以使用 <code>if all(a&gt;60,b&gt;70):</code></p>
</li>
<li><p>for 循环 尽量使用推导式 <code>a= [x for x in b_list]</code>,同时list的下标和数值用 <code>for k,v in enumerate(a)</code>,推导式比较省内存,因为其默认就是使用的生成器的方式进行.</p>
</li>
<li><p>print 可以通过打印’\r’来不进行回车,从而实现刷新当前显示数据</p>
</li>
<li><p>lambda指定匿名函数,<code>filter(lambda x: x+=1, list_a)</code> 将list_a依次通过lambda函数处理 </p>
</li>
<li><p>yield 生成器迭代数据 </p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibs</span><span class="params">(n)</span>:</span></span><br><span class="line">	a,b,i =<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i&lt;n:</span><br><span class="line">		i=i+<span class="number">1</span></span><br><span class="line">		<span class="keyword">yield</span> a</span><br><span class="line">		a,b=b,a+b</span><br><span class="line">lres = ist(fibs(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>装饰器定义切面函数,适用于日志,审计等场景</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def wraped_func(f):</span><br><span class="line">	def wrap(*args,**kwargs):</span><br><span class="line">		do_something</span><br><span class="line">		return f(*args,**kwargs)</span><br><span class="line">	return wrap</span><br><span class="line"></span><br><span class="line">@wraped_func</span><br><span class="line">def func():</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
</li>
<li><p>调试python代码可以通过导入断点 <code>breakpoint()</code> (3.7+) <code>import pdb; pdb.set_trace()</code>(3.6-)</p>
</li>
<li><p>格式化字符串, 使用f,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n ,x &#x3D; 1,31  </span><br><span class="line">a &#x3D; f&quot;xxx &#123;n&#125; &#123;x&#x2F;10:.5f&#125; ddd&quot; </span><br><span class="line">输出:a &#x3D; &quot;xxx 1 3.10000 ddd&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序list使用sorted(), 默认升序,指定reverse=True参数降序</p>
</li>
<li><p>使用set进行数据去重, 可以直接使用 set.add() 方法加入数据到set中,这样产生的数据没有重复, 这样比判断是否再list中再添加的方法时间消耗更低</p>
</li>
<li><p>使用get获取dict中的值并指定默认值,使用setdefault()设置字典项的默认值.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习笔记</title>
    <url>/2020/06/07/shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="shell学习笔记"><a href="#shell学习笔记" class="headerlink" title=" shell学习笔记"></a> shell学习笔记</h1><ol>
<li><p>检测变量是否存在：<code>${varname? ERR:something}</code>若varname变量未定义则报错后面错误信息”ERR:…”</p>
</li>
<li><p>bash4.0 新特性: <code>{1..10..2}</code>从1自增到10每次加2</p>
<a id="more"></a>  </li>
<li><p><code>d{a,b,c}</code>代表da,db,dc</p>
</li>
<li><p><code>~+</code>代表PWD值/<code>~-</code>代表LODPWD值</p>
</li>
<li><p>bash 没有设置-f会支持文件名扩展类似正则:<code>* ? [ ]</code></p>
</li>
<li><p>bash 提示符带有颜色: <code>&quot;\e[0;34m ...  \e[m&quot;</code><br><code>\e[ 指示开始 0;34m代表颜色代码 \e[m 指示结束</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0;30 黑色 </span><br><span class="line">0;34蓝色 </span><br><span class="line">0;32绿色 </span><br><span class="line">0;36 青色 </span><br><span class="line">0;31 红色 </span><br><span class="line">0;35 紫色 </span><br><span class="line">0;33 褐色</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tput</code> 命令设置提示符 <code>bold</code>粗体 <code>rev</code>反转 <code>sgr0</code>关闭所有属性 <code>setaf</code>设置前色<code>setab</code> 设置背景色 0黑 1红 2绿 3黄 4蓝 5洋红 6青 7白</p>
</li>
<li><p><code>set -o</code>开启bash特性 +o关闭</p>
</li>
<li><p>linux不允许给目录创建硬链接<code>ln</code>不能对目录使用,只能加<code>-s</code>创建软连接</p>
</li>
<li><p><code>/dev/null</code>是linux的特殊dev文件,是一个黑洞,不想要的东西都可以写进这里.它读不出任何数据.</p>
</li>
<li><p><code>tar</code>可以加<code>--wildcards</code>与<code>-xvf</code>提取制定模式的一组文件或目录如 <code>--wildcards &#39;*.jpg&#39;</code></p>
</li>
<li><p><code>lsof</code>或<code>fuser</code>可以查看mount的文件系统被哪个进程占用</p>
</li>
<li><p><code>atq</code>与<code>at -l</code>功能相同</p>
</li>
<li><p><code>nohup command [arg]  &amp;</code> 运行一个对挂起免疫的后台任务</p>
</li>
<li><p>bash间接扩展参数:<code>${!B}</code>如果B的值是某个变量参数A的名字,那么该式值是参数A的值而不是B的值</p>
</li>
<li><p>bash内部变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. $BASH bash全路径; </span><br><span class="line">b. $IFS 内部字段分隔符,默认值:&quot;&lt;space&gt;&lt;tab&gt;&lt;newline&gt;&quot;;空格 tab 新行 ; </span><br><span class="line">c. $OSTYPE 操作系统类型 ;</span><br><span class="line">d. $SECONDS 脚本已运行秒数;</span><br><span class="line">e. $TMOUT 如非0则作为命令read的默认超时秒数; </span><br><span class="line">f. $UID 当前用户账号ID</span><br><span class="line">g. $LINENO shell脚本当前行号</span><br><span class="line">h. $FUNCNAME 当前执行调用堆栈的所有shell函数名数组,$&#123;FUNCNAME[0]&#125;代表当前正在执行shell函数名称,$&#123;FUNCNAME[1]&#125;代表调用			$&#123;FUNCNAME[0]&#125;的函数的名字</span><br><span class="line">i. $PS4 bash -x 时显示的默认+号值</span><br></pre></td></tr></table></figure>
</li>
<li><p>bash参数 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. $1 $2 ... 10以上是用&#123;&#125; 即$&#123;10&#125; </span><br><span class="line">b. $* 代表$1c$2c.... c是IFS的第一个字符,默认空白 常用用法: for arg in $*</span><br><span class="line">c. &quot;$@&quot; 等价与 &quot;$1&quot; &quot;$2&quot;...每个都是分割的单词 常用用法: for arg in &quot;$@&quot;</span><br><span class="line">d. $&amp;#35; 参数个数</span><br><span class="line">e. $! 最后一次执行的后台命令进程号</span><br><span class="line">f. $0 shell脚本名称</span><br><span class="line">g. $? 最近一次前台执行命令的退出状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>declare 申明变量 -i 代表整型 -r 只读 -p 显示属性和值 -a 申明数组 </p>
</li>
<li><p>数组也可又<code>$arr=(a1 b2 c3)</code>定义,引用数组必须加{}, @ <em>表示数组所有成员,如 `${arr[2]} /${arr[</em>]} `.不指定索引默认第一个元素 $arr值是a1</p>
</li>
<li><p>数字常量:0x开头表示16进制, 0开头表示8进制 , <code>BASE&amp;#35;NUMBER</code>表示BASE进制的数NUMBER 如<code>12&amp;#35;234</code> 表示12进制的234</p>
</li>
<li><p>let 进行算数运算<code>let &quot;i=i + 5&quot;</code></p>
</li>
<li><p>expr进行表达式求值并输出</p>
</li>
<li><p>shell返回的状态码0~255间整数,shell每行代码不多于80字符</p>
</li>
<li><p>[[]]仅在bash /zsh/ korn shell 中可用,[]在所有符合POSIX标准的shell下可用 </p>
</li>
<li><p>test命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）判断表达式</span><br><span class="line">　　if test  (表达式为真)</span><br><span class="line">　　if test !表达式为假</span><br><span class="line">　　test 表达式1 –a 表达式2                  两个表达式都为真</span><br><span class="line">　　test 表达式1 –o 表达式2                 两个表达式有一个为真</span><br><span class="line">　　2）判断字符串</span><br><span class="line">　　test –n 字符串                                   字符串的长度非零</span><br><span class="line">　　test –z 字符串                                    字符串的长度为零</span><br><span class="line">　　test 字符串1＝字符串2                    字符串相等</span><br><span class="line">　　test 字符串1！＝字符串2               字符串不等</span><br><span class="line">　　3）判断整数</span><br><span class="line">　　test 整数1 –eq 整数2                        整数相等</span><br><span class="line">　　test 整数1 –ge 整数2                        整数1大于等于整数2</span><br><span class="line">　　test 整数1 –gt 整数2                         整数1大于整数2</span><br><span class="line">　　test 整数1 –le 整数2                         整数1小于等于整数2</span><br><span class="line">　　test 整数1 –lt 整数2                          整数1小于整数2</span><br><span class="line">　　test 整数1 –ne 整数2                        整数1不等于整数2</span><br><span class="line">　　4）判断文件</span><br><span class="line">　　test  File1 –ef  File2                            两个文件具有同样的设备号和i结点号</span><br><span class="line">　　test  File1 –nt  File2                            文件1比文件2 新</span><br><span class="line">　　test  File1 –ot  File2                            文件1比文件2 旧</span><br><span class="line">　　test –b File                                           文件存在并且是块设备文件</span><br><span class="line">　　test –c File                                           文件存在并且是字符设备文件</span><br><span class="line">　　test –d File                                           文件存在并且是目录</span><br><span class="line">　　test –e File                                           文件存在</span><br><span class="line">　　test –f File                                            文件存在并且是正规文件</span><br><span class="line">　　test –g File                                           文件存在并且是设置了组ID</span><br><span class="line">　　test –G File                                           文件存在并且属于有效组ID</span><br><span class="line">　　test –h File                                           文件存在并且是一个符号链接（同-L）</span><br><span class="line">　　test –k File                                           文件存在并且设置了sticky位</span><br><span class="line">　　test –b File                                           文件存在并且是块设备文件</span><br><span class="line">　　test –L File                                           文件存在并且是一个符号链接（同-h）</span><br><span class="line">　　test –o File                                           文件存在并且属于有效用户ID</span><br><span class="line">　　test –p File                                           文件存在并且是一个命名管道</span><br><span class="line">　　test –r File                                            文件存在并且可读</span><br><span class="line">　　test –s File                                           文件存在并且是一个套接字</span><br><span class="line">　　test –t FD                                             文件描述符是在一个终端打开的</span><br><span class="line">　　test –u File                                           文件存在并且设置了它的set-user-id位</span><br><span class="line">　　test –w File                                          文件存在并且可写</span><br><span class="line">　　test –x File                                           文件存在并且可执行</span><br></pre></td></tr></table></figure></li>
<li><p><code>break [n]</code>n表示跳出n层嵌套循环.没有n或n小于1,退出码0,否则退出码为n</p>
</li>
<li><p>linux下正在运行的进程,会在/proc下存在以进程号命名的子目录,<code>/proc/[PID]/fd</code>的每一个条目对应一个该进程打开的文件,用文件描述符命名,并软连接到实际文件</p>
</li>
<li><p>函数  </p>
<ol>
<li>创建函数一定要在调用函数之前</li>
<li>function_name() 或者 function name        //function是关键字 name 后面可以省略()<br>{<br>commands…<br>[return int;] 返回值0~255 没有则默认返回最后一条指令运行返回值<br>}</li>
<li>函数自己使用$1 $2 … 作为传递的参数 $* $@ 代表所有的传递的参数 $&#35;传递给函数参数个数</li>
<li>shell默认情况下所有变量都是全局变量,函数内可使用local定义内部变量,local只能在函数体内使用</li>
<li>在脚本中加载函数文件中的函数 使用 点好. 或者source如: . /path/function.sh 或source /path/function.sh</li>
<li>调用函数直接输入名称,不加() </li>
<li>&amp;可以将函数放在后台运行</li>
</ol>
</li>
<li><p>bash正则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*： 代表 0 个或者多个任意字符</span><br><span class="line">?： 代表一定有一个的任意字符</span><br><span class="line">[]： 代表一定有一个在括号内的字符（非任意字符）。例如[abcd]代表一定有一个字符，可能是 abcd 这四个选项的任意一个。</span><br><span class="line">[-]：若邮件韩在括号内时，代表在编码顺序内的所有自负。例如：[0-9]代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的。</span><br><span class="line">[^]： 若括号内的第一个字符为指数字符(^)，那表示反向选择，例如：[^abc]代表一定有一个字符，只要是非 abc 的其他字符就可以。</span><br><span class="line">^：匹配行首位置</span><br><span class="line">$：匹配行尾位置</span><br><span class="line">.：匹配任意祖父</span><br><span class="line">*：对*之前的匹配整体或字符匹配任意次（包括 0 次）</span><br><span class="line">\?：对\?之前的匹配整体或字符匹配 0 次或 1 次</span><br><span class="line">\&#123;n\&#125;: 对 \ &#123; 之前的匹配整体或字符匹配 n 次</span><br><span class="line">\&#123;m,\&#125;: 对 \ &#123; 之前的匹配整体或字符匹配至少 m 次</span><br><span class="line">\&#123;m,n&#125;: 对 \ &#123; 之前的匹配整体或字符匹配 m 到 n 次</span><br><span class="line">\&lt;\&gt;匹配单词边界,如:\&lt;the\&gt;只匹配 the 不匹配then</span><br><span class="line">[abcdef]: 对单字符而言匹配[]中的字符</span><br><span class="line">[a-z]： 对单字符而言，匹配任意一个小写字母</span><br><span class="line">[^a-z]：不匹配括号中的内容</span><br><span class="line">+ :重复『一个或一个以上』的前一个 RE 字符,与*类似 但不包括0个字符的情况</span><br><span class="line">?：『零个或一个』的前一个 RE 字符</span><br><span class="line">|：用或( or )的方式找出数个字串</span><br><span class="line">()：找出『群组』字串与| 一起使用</span><br><span class="line">()+：多个重复群组的判别</span><br></pre></td></tr></table></figure>

<p>POSIX字符类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[:alnum:]	字母数字字符</span><br><span class="line">[:alpha:]	字母字符</span><br><span class="line">[:cntrl:]	控制字符</span><br><span class="line">[:digit:]	数字字符</span><br><span class="line">[:graph:]	非空白字符(非空格、控制字符等)</span><br><span class="line">[:lower:]	小写字母</span><br><span class="line">[:print:]	与[:graph:]相似，但是包含空格字符</span><br><span class="line">[:punct:]	标点字符</span><br><span class="line">[:space:]	所有的空白字符(换行符、空格、制表符)</span><br><span class="line">[:upper:]	大写字母</span><br><span class="line">[:xdigit:]	允许十六进制的数字(0-9a-fA-F)</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭脚本case语句对参数大小写敏感:在case前加入语句shopt -s nocasematch 重新打开用 shopt -u nocasematch</p>
</li>
<li><p>shift [n] 命令向左移动参数变量,n代表每次移动位数, shift后一般加对$?的值做判断语句来检查shift是否被执行</p>
</li>
<li><p>getopts (bash内置)的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. 使用形式是：getopts option_string variable.getopts一共有两个参数，第一个是-a这样的选项，第二个参数是 hello这样的参数。</span><br><span class="line">b. 选项之间可以通过冒号:进行分隔，也可以直接相连接，：表示选项后面必须带有参数，如果没有可以不加实际值进行传递.</span><br><span class="line">c. 当optstring以”:”开头时，getopts会区分invalid option错误和miss option argument错误。</span><br><span class="line">d. 如果optstring不以”:“开头，invalid option错误和miss option argument错误都会使varname被设成?，$OPTARG是出问题的option。</span><br></pre></td></tr></table></figure></li>
<li><p>getopt(命令行命令) 命令的选项说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a 使getopt长参数支持&quot;-&quot;符号打头，必须与-l同时使用</span><br><span class="line">-l 后面接getopt支持长参数列表.选项用逗号分割,&quot;:&quot;表示选项需要一个参数,&quot;::&quot;表示选项有个可选参数</span><br><span class="line">-n program如果getopt处理参数返回错误，会指出是谁处理的这个错误，这个在调用多个脚本时，很有用</span><br><span class="line">-o 后面接短参数列表，这种用法与getopts类似.每个字符代表一个选项,&quot;:&quot;表示选项需要一个参数,&quot;::&quot;表示选项有个可选参数</span><br><span class="line">-u 不给参数列表加引号，默认是加引号的（不使用-u选项），例如在加不引号的时候 --longopt &quot;select * from db1.table1&quot; $2只会取到select ，而不是完整的SQL语句。</span><br></pre></td></tr></table></figure>
<p>使用eval 的目的是为了防止参数中有shell命令，被错误的扩展。<br>样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARGV&#x3D;($(getopt -o 短选项1[:]短选项2[:]...[:]短选项n -l 长选项1,长选项2,...,长选项n -- &quot;$@&quot;))</span><br><span class="line">eval set -- &quot;$ARGV&quot;</span><br><span class="line">while true</span><br><span class="line"> do</span><br><span class="line">    case &quot;$1&quot; in</span><br><span class="line">     -短选项1|--长选项1)</span><br><span class="line">         process</span><br><span class="line">        shift</span><br><span class="line">        ;;</span><br><span class="line">    -短选项2|--长选项2)</span><br><span class="line">         &amp;#35; 获取选项</span><br><span class="line">         opt &#x3D; $2</span><br><span class="line">         process</span><br><span class="line">        shift 2</span><br><span class="line">        ;;</span><br><span class="line">     ......</span><br><span class="line">    -短选项3|--长选项3)</span><br><span class="line">         process</span><br><span class="line">         ;;</span><br><span class="line">     --)</span><br><span class="line"> break</span><br><span class="line">;;</span><br><span class="line"> esac</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>read 读入用户输入 -p 在输入前显示信息 -t 输入超时设置 -s隐藏用户输入 </p>
</li>
<li><p>重定向:<br>a. cat将输出接管道|进行输入数据的方法会不好,最好让你的程序从标准输入读取数据用&lt;,这样用户就可以使用重定向来获取数据.<br>b. 从文本输入用&lt;&lt;EOF格式,结束标识是EOF,必须写在行首.<br>c. &lt;&lt;&lt;用于输入重定向的普通字符串,后面接的就是要输入的字符<br>d. 0 输入 1 输出 2错误<br>e. 同时重定向 “&amp;&gt;” “&gt;&amp;” “2&gt;&amp;1” 追加用 &gt;&gt;<br>f. 在shell中最多可以有9个打开的文件描述符0-8.exec 用于操作文件描述符,如exec 2&gt;err.log.符号&lt;&amp;可以复制一个输入文件描述符，符号&gt;&amp;可以复制一个输出描述符。exec n&lt;&amp;- 关闭文件描述符.exec [n] &lt;&gt;file 打开读写文件</p>
</li>
<li><p>管道|与重定向的区别是,管道是将第一个命令的输出作为第二个的输入,而重定向是将命令与文件链接.</p>
</li>
<li><p>常用的管道过滤命令: awk,cut, grep, tar , head 取文件开头,paste 合并文件行, sed ,sort 行排序, split 文件分割, strings 打印文件中可打印的字符串, tac 与cat相反 倒序显示文件,tail 显示文件结尾 , tee 从标准输入读取内容并写入标准文件或输出, tr 转换或删除字符, uniq 报告或忽略重复的行, wc 统计行数字数等,column进行输出的表格格式化.</p>
</li>
<li><p>posix信号:<br>在linux下的:       </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX	</span><br><span class="line">信号	     	取值		默认动作	含义（发出信号的原因）</span><br><span class="line">SIGHUP		1	Term	终端的挂断或进程死亡</span><br><span class="line">SIGINT		2	Term	来自键盘的中断信号</span><br><span class="line">SIGQUIT		3	Core	来自键盘的离开信号</span><br><span class="line">SIGILL		4	Core	非法指令</span><br><span class="line">SIGABRT	6	Core	来自abort的异常信号</span><br><span class="line">SIGFPE		8	Core	浮点例外</span><br><span class="line">SIGKILL		9	Term	杀死</span><br><span class="line">SIGSEGV	11	Core	段非法错误(内存引用无效)</span><br><span class="line">SIGPIPE		13	Term	管道损坏：向一个没有读进程的管道写数据</span><br><span class="line">SIGALRM	14	Term	来自alarm的计时器到时信号</span><br><span class="line">SIGTERM	15	Term	终止</span><br><span class="line">SIGUSR1	30,10,16	Term	用户自定义信号1</span><br><span class="line">SIGUSR2	31,12,17	Term	用户自定义信号2</span><br><span class="line">SIGCHLD	20,17,18	Ign	子进程停止或终止</span><br><span class="line">SIGCONT	19,18,25	Cont	如果停止，继续执行</span><br><span class="line">SIGSTOP	17,19,23	Stop	非来自终端的停止信号</span><br><span class="line">SIGTSTP		18,20,24	Stop	来自终端的停止信号</span><br><span class="line">SIGTTIN		21,21,26	Stop	后台进程读终端</span><br><span class="line">SIGTTOU	22,22,27	Stop	后台进程写终端</span><br><span class="line">　			　</span><br><span class="line">SIGBUS		10,7,10	Core	总线错误（内存访问错误）</span><br><span class="line">SIGPOLL		Term	Pollable	事件发生(Sys V)，与SIGIO同义</span><br><span class="line">SIGPROF	27,27,29	Term	统计分布图用计时器到时</span><br><span class="line">SIGSYS		12,-,12	Core	非法系统调用(SVr4)</span><br><span class="line">SIGTRAP	5		Core	跟踪&#x2F;断点自陷</span><br><span class="line">SIGURG		16,23,21	Ign	socket紧急信号(4.2BSD)</span><br><span class="line">SIGVTALRM	26,26,28	Term	虚拟计时器到时(4.2BSD)</span><br><span class="line">SIGXCPU	24,24,30	Core	超过CPU时限(4.2BSD)</span><br><span class="line">SIGXFSZ		25,25,31	Core	超过文件长度限制(4.2BSD)</span><br><span class="line">　			　</span><br><span class="line">SIGIOT		6		Core	IOT自陷，与SIGABRT同义</span><br><span class="line">SIGEMT		7,-,7		Term</span><br><span class="line">SIGSTKFLT	-,16,-	Term	协处理器堆栈错误(不使用)</span><br><span class="line">SIGIO		23,29,22	Term	描述符上可以进行I&#x2F;O操作</span><br><span class="line">SIGCLD		-,-,18	Ign	与SIGCHLD同义</span><br><span class="line">SIGPWR		29,30,19	Term	电力故障(System V)</span><br><span class="line">SIGINFO		29,-,-			与SIGPWR同义</span><br><span class="line">SIGLOST	-,-,-		Term	文件锁丢失</span><br><span class="line">SIGWINCH	28,28,20	Ign	窗口大小改变(4.3BSD, Sun)</span><br><span class="line">SIGUNUSED	-,31,-	Term	未使用信号(will be SIGSYS)</span><br></pre></td></tr></table></figure>
<p>一些信号的取值是硬件结构相关的（一般alpha和sparc架构用第一个值，i386、ppc和sh架构用中间值，mips架构用第三个值， - 表示相应架构的取值未知）。<br>SIGKILL和SIGSTOP信号不能被挂钩、阻塞或忽略。</p>
</li>
<li><p>disown -h %1 会阻止shell 向后台作业1发送SIGHUP信号,这时退出shell作业依旧会执行,如果用shopt打开了shell内部的huponexit,会在退出shell时默认向所有作业发送SIGHUP</p>
</li>
<li><p>进程的状态:<code>D 不可中断休眠 R运行 S 休眠 T 停止 Z 僵死</code></p>
</li>
<li><p>bash下:<br><code>Ctrl + C</code> 中断信号,发送SIGINT.<br><code>Ctrl+Y</code> 延时挂起,使运行的进程在尝试从终端读取数据时停止,控制权返回shell.<br><code>Ctrl+Z</code> 挂起信号,发送SIGTSTP,返回shell</p>
</li>
<li><p><code>(command1;command2;...)</code>内嵌在圆括号内部的命令列表,作为一个shell进程的子shell进程运行,其变量对外不可见,运行环境变量可设置不同.</p>
</li>
<li><p>捕获:<br>a. <code>trap command signal [signal ...]</code>捕获特定的信号进行处理 如<code>trap &quot;kill -9 $self &quot; SIGHUP</code> (在收到sinhup信号后立即杀死自己)<br>b. trap语句中若””内为空则不做响应,可用于屏蔽Ctrl+C 等<br>c. <code>trap - signal...</code> 用于重置默认模式,移除信号的捕获.</p>
</li>
</ol>
<h2 id="sed手册"><a href="#sed手册" class="headerlink" title="sed手册"></a>sed手册</h2><p><a href="https://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener">参考站点</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]&amp;#35; sed [-nefr] [动作]</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑；</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line">动作说明： [n1[,n2]]function</span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』</span><br><span class="line">function：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s&#x2F;old&#x2F;new&#x2F;g 就是啦！</span><br></pre></td></tr></table></figure>

<h2 id="awk"><a href="#awk" class="headerlink" title="awk "></a>awk </h2><p><a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">参考站点</a><br><code>awk &#39;{pattern + action}&#39; {filenames}</code><br>尽管操作可能会很复杂，但语法总是这样，其中<code>pattern</code>表示 AWK 在数据中查找的内容，而 <code>action</code>是在找到匹配内容时所执行的一系列命令。花括号<code>（{}）</code>不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。<br>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。<br>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。<br>模式可以是以下任意一个：<code>/正则表达式/</code>：使用通配符的扩展集。 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。 模式匹配表达式：用运算符<del>（匹配）和</del>!（不匹配）。 BEGIN语句块、pattern语句块、END语句块.</p>
<h2 id="set"><a href="#set" class="headerlink" title="set --"></a><code>set --</code></h2><p>  表示:”If  no  arguments follow this option, then the positional parameters are unset.  Otherwise, the positional parameters are set  to the args, even if some of them begin with a -.”</p>
<h2 id="shell-调用其他脚本"><a href="#shell-调用其他脚本" class="headerlink" title="shell 调用其他脚本"></a>shell 调用其他脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 使用.&#x2F;1.sh 或者 sh 1.sh 执行后使用exit退出并返回 ,</span><br><span class="line"> . 1.sh 或 export 1.sh 执行后用return返回.</span><br><span class="line"> </span><br><span class="line">shell脚本中的函数类似使用.&#x2F;1.sh方式执行的,有输入变量和返回但返回用return</span><br><span class="line"></span><br><span class="line">所有shell return只能返回数字,如果需要返回字符串,在func中使用echo.</span><br><span class="line"></span><br><span class="line">用&quot;.&quot;或者export执行的相当于本脚本执行,变量通用.无须返回.</span><br></pre></td></tr></table></figure>

<h2 id="echo和printf命令"><a href="#echo和printf命令" class="headerlink" title="echo和printf命令"></a>echo和printf命令</h2><p><code>echo -e &quot;1\t2\t3&quot;</code><br>显示结果为<code>123</code><br>echo 会自动在输出结尾加上一个\n回车,但是printf不会。<br>echo的-e命令表示需要转义，把\t转换成tab空格，-n命令会忽略输出结尾的回车。</p>
<p><strong><em>echo打印彩色输出：</em></strong> <code>echo -e &quot;\e[1;31m this is red \e[0m&quot;</code><br>其中\e[1;31m表示颜色开始，\e[0m表示重置即结束。31代表红色，修改数字对应不同颜色：黑色30，红色31，绿色32，黄色33，蓝色34，洋红35，青色36，白色37。</p>
<p>print命令和c语言的类似，<br><code>printf &quot;%-5s %-6.2f&quot; hello 43.2222</code>表示输出<code>hello 43.22</code>，<br>-表示左对齐，否组默认右对齐，数字是格式化位数。</p>
<p><code>var=value</code>和<code>var = value</code> 不同，前者是赋值，后者是等于比较操作,注意中间的空格区分。</p>
<p><strong><em>获取字符串长度</em></strong><br>采用<code>${&amp;#35;var}</code> var表示所要获取的字符串<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=1234567890</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;&amp;#35;var&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出：<code>&gt;10</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串拼接性能对比</title>
    <url>/2020/06/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><p>last update: 5/21/19 10:10 PM</p>
<p>前两天需要大量做字符串的拼接,生成html文件.对于如何快速生成字符串进行了研究和测试. </p>
<a id="more"></a>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>在python中最先想到的拼接方式就是<code>c=c+a</code>很直观.另外发现python还提供了很多种字符串的操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c&#x3D;c+a</span><br><span class="line"></span><br><span class="line">c+&#x3D;a</span><br><span class="line"></span><br><span class="line">&quot;&#123;&#125;&#123;&#125;&quot;.format(c,a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c&#x3D;[] c+&#x3D;[a] &quot;&quot;.join(c)</span><br></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	# coding: utf-8</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">count &#x3D; 20000</span><br><span class="line"></span><br><span class="line">beg &#x3D; time.time()</span><br><span class="line">a &#x3D; &quot;this is a test sting a&quot;</span><br><span class="line">b &#x3D; &quot;this is another test string 测试测试测试ing&quot;</span><br><span class="line">res &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">for i in range(count):</span><br><span class="line">    if i%2 &#x3D;&#x3D; 0:</span><br><span class="line">        res &#x3D; res + a + &quot;:&quot;+str(i)</span><br><span class="line">    else:</span><br><span class="line">        res &#x3D; res + b+ &quot;:&quot;+str(i)</span><br><span class="line">print(&quot;time cost +: %s&quot;,time.time()-beg)</span><br><span class="line"></span><br><span class="line">beg &#x3D; time.time()</span><br><span class="line">for i in range(count):</span><br><span class="line">    if i%2 &#x3D;&#x3D; 0:</span><br><span class="line">        res +&#x3D; a + &quot;:&quot;+str(i)</span><br><span class="line">    else:</span><br><span class="line">        res +&#x3D; b+ &quot;:&quot;+str(i)</span><br><span class="line">print(&quot;time cost +&#x3D;: %s&quot;,time.time()-beg)</span><br><span class="line"></span><br><span class="line">beg &#x3D; time.time()</span><br><span class="line">for i in range(count):</span><br><span class="line">    if i%2 &#x3D;&#x3D; 0:</span><br><span class="line">        res &#x3D; &quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(res,a,&quot;:&quot;,str(i)) </span><br><span class="line">    else:</span><br><span class="line">        res &#x3D; &quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(res,b,&quot;:&quot;,str(i)) </span><br><span class="line">print(&quot;time cost format: %s&quot;,time.time()-beg)</span><br><span class="line"></span><br><span class="line">res &#x3D; []</span><br><span class="line">beg &#x3D; time.time()</span><br><span class="line">for i in range(count):</span><br><span class="line">    if i%2 &#x3D;&#x3D; 0:</span><br><span class="line">        res+&#x3D;[a,&quot;:&quot;,str(i)]</span><br><span class="line">    else:</span><br><span class="line">        res+&#x3D;[b,&quot;:&quot;,str(i)]</span><br><span class="line">result &#x3D; &quot; &quot;.join(res)</span><br><span class="line">print(&quot;time cost join list: %s&quot;,time.time()-beg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res &#x3D; 1</span><br><span class="line">beg &#x3D; time.time()</span><br><span class="line">for i in range(count):</span><br><span class="line">    if i%2 &#x3D;&#x3D; 0:</span><br><span class="line">        res &#x3D; res + i</span><br><span class="line">    else:</span><br><span class="line">        res &#x3D; res + i&#x2F;2 </span><br><span class="line">print(&quot;time cost + num : %s&quot;,time.time()-beg)</span><br><span class="line"></span><br><span class="line">res &#x3D; 1</span><br><span class="line">beg &#x3D; time.time()</span><br><span class="line">for i in range(count):</span><br><span class="line">    if i%2 &#x3D;&#x3D; 0:</span><br><span class="line">        res +&#x3D; i</span><br><span class="line">    else:</span><br><span class="line">        res +&#x3D; i&#x2F;2 </span><br><span class="line">print(&quot;time cost +&#x3D; num: %s&quot;,time.time()-beg)</span><br></pre></td></tr></table></figure>

<p>执行时间对比:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">─$ python test.py </span><br><span class="line">(&#39;time cost +: %s&#39;, 3.4623711109161377)</span><br><span class="line">(&#39;time cost +&#x3D;: %s&#39;, 0.015604972839355469)</span><br><span class="line">(&#39;time cost format: %s&#39;, 3.1990790367126465)</span><br><span class="line">(&#39;time cost join list: %s&#39;, 0.013344049453735352)</span><br><span class="line">(&#39;time cost + num : %s&#39;, 0.005431175231933594)</span><br><span class="line">(&#39;time cost +&#x3D; num: %s&#39;, 0.005048036575317383)</span><br><span class="line"></span><br><span class="line">╰─$ python3 test.py</span><br><span class="line">time cost +: %s 6.251662492752075</span><br><span class="line">time cost +&#x3D;: %s 0.02083301544189453</span><br><span class="line">time cost format: %s 52.249574184417725</span><br><span class="line">time cost join list: %s 0.020740747451782227</span><br><span class="line">time cost + num : %s 0.005892515182495117</span><br><span class="line">time cost +&#x3D; num: %s 0.005952358245849609</span><br></pre></td></tr></table></figure>


<p>同样对于golang</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strings&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var count &#x3D; 50000</span><br><span class="line"></span><br><span class="line">var a &#x3D; &quot;this is a test&quot;</span><br><span class="line">var b &#x3D; &quot;this is another test&quot;</span><br><span class="line">var c string</span><br><span class="line"></span><br><span class="line">func testAdd() &#123;</span><br><span class="line">	t :&#x3D; time.Now()</span><br><span class="line">	for i :&#x3D; 0; i &lt; count; i++ &#123;</span><br><span class="line">		c &#x3D; c + a + b</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;test add:&quot;, time.Now().Sub(t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testPlus() &#123;</span><br><span class="line">	t :&#x3D; time.Now()</span><br><span class="line">	for i :&#x3D; 0; i &lt; count; i++ &#123;</span><br><span class="line">		c +&#x3D; a + b</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;test plus:&quot;, time.Now().Sub(t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func testArray() &#123;</span><br><span class="line">	d :&#x3D; []string&#123;&#125;</span><br><span class="line">	t :&#x3D; time.Now()</span><br><span class="line">	for i :&#x3D; 0; i &lt; count; i++ &#123;</span><br><span class="line">		d &#x3D; append(d, a, b)</span><br><span class="line">	&#125;</span><br><span class="line">	strings.Join(d, &quot;&quot;)</span><br><span class="line">	fmt.Println(&quot;test array:&quot;, time.Now().Sub(t))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	testAdd()</span><br><span class="line">	testPlus()</span><br><span class="line">	testArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ go run testgo&#x2F;string_plus.go </span><br><span class="line">test add: 6.464752503s</span><br><span class="line">test plus: 19.349181857s</span><br><span class="line">test array: 10.107554ms</span><br><span class="line"></span><br><span class="line">─$ go run testgo&#x2F;string_plus.go &#x2F;&#x2F;count&#x3D;20000</span><br><span class="line">test add: 1.046215762s</span><br><span class="line">test plus: 3.233030314s</span><br><span class="line">test array: 4.82766ms</span><br></pre></td></tr></table></figure>

<p>综合上述测试可见, 对于大量字符串拼接的需求, 使用数组(array/list)存放需要进行拼接的字符串,之后再使用join()拼接,效率高很多.<br>究其原因,因为数组是指针连接的,产生时使用新的指针指向需要连接的数据,go在append时会自动增加cap为两倍,分配新的内存空间,而数组存放的是指向实际底层数据的指针,字符串数据并未重新生成, 但是对于+拼接方法,重新产生一个新的字符串,需要分配新的内存空间,因此会占用很多时间.<br>同时也发现python3对于字符串的拼接并不比python2做的好..</p>
<p>另外 go字符串不要使用+= 而python 可以适当使用+=,其性能仅差于list 同时go语言的性能的确远高于python</p>
<hr>
<p>别人的测试代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from cStringIO import StringIO</span><br><span class="line">import timing, commands, os</span><br><span class="line">from sys import argv</span><br><span class="line"></span><br><span class="line">def method1():</span><br><span class="line">	out_str &#x3D; &#39;&#39;</span><br><span class="line">	for num in xrange(loop_count):</span><br><span class="line">		out_str +&#x3D; &#96;num&#96;</span><br><span class="line">	ps_stats()</span><br><span class="line">	return out_str</span><br><span class="line"></span><br><span class="line">def method2():</span><br><span class="line">	from UserString import MutableString</span><br><span class="line">	out_str &#x3D; MutableString()</span><br><span class="line">	for num in xrange(loop_count):</span><br><span class="line">		out_str +&#x3D; &#96;num&#96;</span><br><span class="line">	ps_stats()</span><br><span class="line">	return out_str</span><br><span class="line"></span><br><span class="line">def method3():</span><br><span class="line">	from array import array</span><br><span class="line">	char_array &#x3D; array(&#39;c&#39;)</span><br><span class="line">	for num in xrange(loop_count):</span><br><span class="line">		char_array.fromstring(&#96;num&#96;)</span><br><span class="line">	ps_stats()</span><br><span class="line">	return char_array.tostring()</span><br><span class="line"></span><br><span class="line">def method4():</span><br><span class="line">	str_list &#x3D; []</span><br><span class="line">	for num in xrange(loop_count):</span><br><span class="line">		str_list.append(&#96;num&#96;)</span><br><span class="line">	out_str &#x3D; &#39;&#39;.join(str_list)</span><br><span class="line">	ps_stats()</span><br><span class="line">	return out_str</span><br><span class="line"></span><br><span class="line">def method5():</span><br><span class="line">	file_str &#x3D; StringIO()</span><br><span class="line">	for num in xrange(loop_count):</span><br><span class="line">		file_str.write(&#96;num&#96;)</span><br><span class="line">	out_str &#x3D; file_str.getvalue()</span><br><span class="line">	ps_stats()</span><br><span class="line">	return out_str</span><br><span class="line"></span><br><span class="line">def method6():</span><br><span class="line">	out_str &#x3D; &#39;&#39;.join([&#96;num&#96; for num in xrange(loop_count)])</span><br><span class="line">	ps_stats()</span><br><span class="line">	return out_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ps_stats():</span><br><span class="line">	global process_size</span><br><span class="line">	ps &#x3D; commands.getoutput(&#39;ps -up &#39; + &#96;pid&#96;)</span><br><span class="line">	process_size &#x3D; ps.split()[15]</span><br><span class="line"></span><br><span class="line">def call_method(num):</span><br><span class="line">	global process_size</span><br><span class="line">	timing.start()</span><br><span class="line">	z &#x3D; eval(&#39;method&#39; + str(num))()</span><br><span class="line">	timing.finish()</span><br><span class="line">	print &quot;method&quot;, num</span><br><span class="line">	print &quot;time&quot;, float(timing.micro()) &#x2F; 1000000</span><br><span class="line">	print &quot;output size &quot;, len(z) &#x2F; 1024, &quot;kb&quot;</span><br><span class="line">	print &quot;process size&quot;, process_size, &quot;kb&quot;</span><br><span class="line">	print</span><br><span class="line">	</span><br><span class="line">loop_count &#x3D; 100000</span><br><span class="line">pid &#x3D; os.getpid()</span><br><span class="line"></span><br><span class="line">if len(argv) &#x3D;&#x3D; 2:</span><br><span class="line">	call_method(argv[1])</span><br><span class="line">else:</span><br><span class="line">	print &quot;Usage: python stest.py &lt;n&gt;\n&quot; \</span><br><span class="line">		&quot;  where n is the method number to test&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Results: Twenty thousand integers</strong></p>
<p>In the first test 20,000 integers were concatenated into a string 86kb long.</p>
<p>Concatenations  per second         Process size (kB)<br>     Method 1    3770         2424<br>     Method 2    2230         2424<br>     Method 3    29,600         2452<br>     Method 4    83,700         3028<br>     Method 5    90,900         2536<br>     Method 6    119,800         3000</p>
<p><strong>Results: Five hundred thousand integers</strong></p>
<p>Next I tried a run of each method using 500,000 integers concatenated into a string 2,821 kB long. This is a much more serious test and we start to see the size of the python interpreter process grow to accomodate the data structures used in the computation.</p>
<p>Concatenations per second         Process size (kB)<br>     Method 3    17,100         8,016<br>     Method 4    74,800         22,872<br>     Method 5    94,900         10,480<br>     Method 6    102,100         22,844</p>
<p><strong>Conclusions</strong></p>
<p>I would use Method 6 in most real programs. It’s fast and it’s easy to understand. It does require that you be able to write a single expression that returns each of the values to append. Sometimes that’s just not convenient to do - for example when there are several different chunks of code that are generating output. In those cases you can pick between Method 4 and Method 5.</p>
<p>Method 4 wins for flexibility. You can use all of the normal slice operations on your list of strings, for insertions, deletions and modifications. The performance for appending is pretty decent.</p>
<p>Method 5 wins out on efficiency. It’s uses less memory than either of the list methods (4 &amp; 6) and it’s faster than even the list comprehension for very large numbers of operations (more than about 700,000). If you’re doing a lot of string appending cStringIO is the way to go.</p>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>language</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop集群以及Hive服务部署中的坑</title>
    <url>/2020/06/07/Hadoop%E9%9B%86%E7%BE%A4%E4%BB%A5%E5%8F%8AHive%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="Hadoop集群以及Hive服务部署中的坑"><a href="#Hadoop集群以及Hive服务部署中的坑" class="headerlink" title="Hadoop集群以及Hive服务部署中的坑"></a>Hadoop集群以及Hive服务部署中的坑</h1><p>部署hive的版本必须和hadoop的版本匹配, 具体对应关系可以从官方文档中找到说明, 主要就是因为lib库的差异导致的. 两者必须运行在相同的java环境下. hive2.x.x不能适用与hadoop3.x.x</p>
<a id="more"></a>
<p>由于hadoop是同一份配置多机拷贝部署的, 那么就需要保持数据节点和master的namenode节点的配置一致性. </p>
<p>hadoop部署的节点机器一定要具有相互ssh访问的权限, 必须事先定义好publickey互访. 同时在每个节点上都得有整个集群的hosts信息(或者直接在路由上指定), 必须保证每个节点都可以通过其他节点的hostname访问到其他节点. 需要注意的是<code>/etc/hosts</code>文件中最好是没有指向本地localhost的配置,即不要出现<code>127.0.0.1 localhost</code>之类的配置. 在配置好ssh和hosts后,确保在每台机器上都能成功通过hostname进行ssh publickey访问. 如果ssh不是默认22端口 可以通过在hadoop的配置文件<code>hadoop-env.sh</code>中设置<code>export HADOOP_SSH_OPTS=&quot;-p 26387 -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=10s&quot;</code> 同时在该文件中也需要执行hadoop运行的用户:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HDFS_NAMENODE_USER&#x3D;&quot;root&quot;</span><br><span class="line">export HDFS_DATANODE_USER&#x3D;&quot;root&quot;</span><br><span class="line">export HDFS_SECONDARYNAMENODE_USER&#x3D;&quot;root&quot;</span><br><span class="line">export YARN_RESOURCEMANAGER_USER&#x3D;&quot;root&quot;</span><br><span class="line">export YARN_NODEMANAGER_USER&#x3D;&quot;root&quot;</span><br></pre></td></tr></table></figure>

<p>hadoop的默认配置在代码目录下的<code>etc/hadoop</code>下,需要修改定义xml 文件, 根据官方手册填写对应的配置,注意涉及到节点信息的地方都不用ip地址而是必须使用hostname.(除了外部访问地址)</p>
<p>hadoop集群启动使用<code>sbin/start-all.sh</code>, 而且只需要在namenode上执行, 不需要在每个节点上都执行,.但是启动后需要通过<code>jps</code>查看java进程确保每个数据节点上都有数据服务和调度程序, 同时确保namenode 上的调度yarn调度器正确启动. 有时会出现一个进程不能正确启动, 需要到对应的节点上通过查看hadoop日志文件排查原因, 并通过<code>stop-all.sh</code> &amp;<code>start-all.sh</code>两个脚本重新执行一次启动集群.或者单独执行<code>start-yarn.sh</code>等</p>
<p>hive只需要部署在hadoop的一个数据节点上就行, 但是 由于hive server服务使用root访问是需要有hadoop访问权限的,因此在hadoop的配置中必须加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;hadoop.proxyuser.root.groups&lt;&#x2F;name&gt;</span><br><span class="line">     &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">   &lt;&#x2F;property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hadoop.proxyuser.root.hosts&lt;&#x2F;name&gt;</span><br><span class="line">     &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">   &lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>hadoop的map-reduce执行方式的执行个数通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.job.reduces&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;4&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;description&gt;reduce个数&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.job.maps&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;4&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;description&gt;map个数&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>
<p>设置, 但是其值最好设定为集群数据节点数量的0.95倍. 同时为了加速执行, 可以把预测执行<code>mapreduce.map.speculative</code>和<code>mapreduce.reduce.speculative</code>关闭, 并且使用<code>mapreduce.output.fileoutputformat.compress</code>开启中间数据压缩.</p>
<p>hive的配置文件最好和其版本保持一致, 不同版本的配置文件小有出入. 在<code>hive-env.sh</code>中使用<code>HADOOP_OPTS</code>来配置hive的java运行环境参数, 其中<code>Xmx和Xms</code>根据实际机器的内存配置设定.  而<code>hive-site.xml</code> 配置文件可以通过模板<code>hive-default.xml</code>来修改生成.  </p>
<p>需要注意的是每次修改配置后都需要重启hive server2服务或者退出hive cli来生效配置, 同时注意已经启动的hive server2数量, 如果启动了多个服务, 可能会出现混乱的结果, 请确保节点上只有一个hive server2</p>
]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>flink定制jvm监控metrics</title>
    <url>/2020/06/07/flink%E5%AE%9A%E5%88%B6jvm%E7%9A%84metaspace%E7%AD%89%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="flink定制jvm的metaspace等监控指标"><a href="#flink定制jvm的metaspace等监控指标" class="headerlink" title="flink定制jvm的metaspace等监控指标"></a>flink定制jvm的metaspace等监控指标</h1><p><strong>起因</strong></p>
<p>项目中使用了Flink计算框架去针对实时数据做分析. 我们基于目前最新的Flink1.10.1版本进行开发, 定制自己的业务处理算子逻辑. 开发中我们多次遇到一个问题:<code>java.lang.OutOfMemoryError:Metaspace</code>. 其发生的场景很不规律, 经过多次观察日志发现, 似乎集中发生在频繁重新提交新的flink执行任务到task manager并且停止旧的任务的场景下. </p>
<p>具体原因很有可能就是flink框架对同一个task manager执行了任务重新分配时, jvm并不是重新启动的. 由于一个task manager的jvm每次都会通过<a href="http://janino-compiler.github.io/janino/" target="_blank" rel="noopener">Janino</a> 动态重新加载job manager发过来的任务代码解析执行, 此时如果代码编写不当或者框架本身出现内存泄漏,那么将迟早遇见这个metaspace的oom错误. </p>
<p>关于框架可能出现的问题, 在<a href="https://issues.apache.org/jira/browse/FLINK-16225" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/FLINK-16225</a> 和 <a href="https://issues.apache.org/jira/browse/FLINK-11205" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/FLINK-11205</a> 中有详细的讨论. </p>
<p><em>ps: 最新的进展是这个问题声称被修复了: <a href="https://issues.apache.org/jira/browse/FLINK-16408" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/FLINK-16408</a>, 修复的发布版本是1.11.0, 期待ing…</em></p>
<p>虽然框架层面声称解决了问题, 但是代码层面是我们自己写的啊, 你无法保证一个错误的写法不会导致 mataspace的 oom. 为此我们的需求就很简单, 持续监控各个task manager的jvm内存信息, 通过prometheus监控系统把指标放到grafana中观察, 结合日志等信息去定位oom前后都发生了什么.</p>
<p>flink提供了很全面的metrics指标系统, 但是却偏偏没有jvm的metaspace信息指标, 只有nonheap和heap的指标. 虽然这个指标也包含了metaspace信息,但是有点笼统了, 我就想知道确切的metaspace内存用量.</p>
<p><strong>思路</strong></p>
<p>同事说, 既然没有办法获取, 那我们就利用jmx自己去收集, 再搞的jmx exporter 发送给prometheus不就行了吗? 诚然, 这样做没毛病. 但是我们要搞出好几个依赖来,维护成本有点大, 另外, 既然flink提供了heap等jvm信息, 那么暴露metaspace信息不也应该是顺手的事情吗? 想到这里, 那我们看看官方源码先:</p>
<p>flink的源码中对于监控指标暴露设计的很好, <code>flink-metrics</code>目录下定义了多种metrics收集信息的转换逻辑, 而产生metrics的定义不在这里. 在<code>flink-runtime</code>下<code>src/main/java/org.apache.flink.runtime</code>的<code>metircs</code>目录中定义了监控指标如何生成的.</p>
<p>我们这里关心的jvm信息收集定义在<code>util/MetricUtils.java</code>中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateStatusMetrics</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			MetricGroup metricGroup)</span> </span>&#123;</span><br><span class="line">		MetricGroup jvm = metricGroup.addGroup(<span class="string">"JVM"</span>);</span><br><span class="line"></span><br><span class="line">		instantiateClassLoaderMetrics(jvm.addGroup(<span class="string">"ClassLoader"</span>));</span><br><span class="line">		instantiateGarbageCollectorMetrics(jvm.addGroup(<span class="string">"GarbageCollector"</span>));</span><br><span class="line">		instantiateMemoryMetrics(jvm.addGroup(<span class="string">"Memory"</span>));</span><br><span class="line">		instantiateThreadMetrics(jvm.addGroup(<span class="string">"Threads"</span>));</span><br><span class="line">		instantiateCPUMetrics(jvm.addGroup(<span class="string">"CPU"</span>));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>instantiateStatusMetrics</code>中调用了内存信息收集方法<code>instantiateMemoryMetrics(jvm.addGroup(&quot;Memory&quot;));</code>, 跳到其中可见第1,2行调用了获取nonheap和heap信息的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateMemoryMetrics</span><span class="params">(MetricGroup metrics)</span> </span>&#123;</span><br><span class="line">    instantiateHeapMemoryMetrics(metrics.addGroup(METRIC_GROUP_HEAP_NAME));</span><br><span class="line">    instantiateNonHeapMemoryMetrics(metrics.addGroup(METRIC_GROUP_NONHEAP_NAME));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MBeanServer con = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String directBufferPoolName = <span class="string">"java.nio:type=BufferPool,name=direct"</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这两个函数定义是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateHeapMemoryMetrics</span><span class="params">(<span class="keyword">final</span> MetricGroup metricGroup)</span> </span>&#123;</span><br><span class="line">		instantiateMemoryUsageMetrics(metricGroup, () -&gt; ManagementFactory.getMemoryMXBean().getHeapMemoryUsage());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@VisibleForTesting</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateNonHeapMemoryMetrics</span><span class="params">(<span class="keyword">final</span> MetricGroup metricGroup)</span> </span>&#123;</span><br><span class="line">		instantiateMemoryUsageMetrics(metricGroup, () -&gt; ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>@VisibleForTesting</code>?当前的内存信息暴露只是测试版?好吧…</p>
<p>两者都去调用了<code>instantiateMemoryUsageMetrics</code>以暴露<code>used,committed,max</code>信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateMemoryUsageMetrics</span><span class="params">(<span class="keyword">final</span> MetricGroup metricGroup, <span class="keyword">final</span> Supplier&lt;MemoryUsage&gt; memoryUsageSupplier)</span> </span>&#123;</span><br><span class="line">		metricGroup.&lt;Long, Gauge&lt;Long&gt;&gt;gauge(MetricNames.MEMORY_USED, () -&gt; memoryUsageSupplier.get().getUsed());</span><br><span class="line">		metricGroup.&lt;Long, Gauge&lt;Long&gt;&gt;gauge(MetricNames.MEMORY_COMMITTED, () -&gt; memoryUsageSupplier.get().getCommitted());</span><br><span class="line">		metricGroup.&lt;Long, Gauge&lt;Long&gt;&gt;gauge(MetricNames.MEMORY_MAX, () -&gt; memoryUsageSupplier.get().getMax());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里我就发现, 问题好办了, 用了<code>ManagementFactory</code>是吧? matasapce也可以轻松拿到啊.开撸吧.</p>
<p><strong>改造</strong></p>
<p>首先构造一个获取各种jvm内存信息的方法, 有关<code>used,committed,max</code>的信息生成也通过<code>instantiateMemoryUsageMetrics</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateMemoryDetailMetrics</span><span class="params">(MetricGroup metrics)</span> </span>&#123;</span><br><span class="line">		List&lt;MemoryPoolMXBean&gt; pools = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">final</span> MemoryPoolMXBean pool: pools) &#123;</span><br><span class="line">			instantiateMemoryUsageMetrics(metrics.addGroup(pool.getName()), pool::getUsage);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>再在<code>instantiateMemoryMetrics</code>中添加我们定义的方法调用即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiateMemoryMetrics</span><span class="params">(MetricGroup metrics)</span> </span>&#123;</span><br><span class="line">		instantiateHeapMemoryMetrics(metrics.addGroup(METRIC_GROUP_HEAP_NAME));</span><br><span class="line">		instantiateNonHeapMemoryMetrics(metrics.addGroup(METRIC_GROUP_NONHEAP_NAME));</span><br><span class="line">		</span><br><span class="line">		instantiateMemoryDetailMetrics(metrics);</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<p>完成了我们就编译一下,上线部署即可了. 但是编译的时候却碰到了一些坑.</p>
<ol>
<li><p>IDEA中导入flink依赖出现<br><code>Cannot resolve io.confluent:kafka-schema-registry-client:3.3.1</code>错误.</p>
<p> 解决办法:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget http://packages.confluent.io/maven/io/confluent/kafka-schema-registry-client/3.3.1/kafka-schema-registry-client-3.3.1.jar`</span><br><span class="line">$ mvn install:install-file -DgroupId=io.confluent -DartifactId=kafka-schema-registry-client -Dversion=3.3.1 -Dpackaging=jar  -Dfile=./kafka-schema-registry-client-3.3.1.jar</span><br></pre></td></tr></table></figure>

<p> flink编译中会执行语法检查, 对于<code>import xxx.*</code>这种语法会报错拒绝编译.</p>
</li>
<li><p>执行<code>mvn clean package -DskipTests</code>出现语法不规范的错误提示<br> 这个问题其实不是坑,而是我们代码不规范! 可见代码规范很重要, 越大的项目越是在乎, 专门通过mvn做了检查. 比如: <code>for (final GarbageCollectorMXBean garbageCollector: garbageCollectors){</code> 这个<code>for</code>和<code>(</code>之间必须有个空格; import依赖必须按照字典顺序排序等.<br> <em>ps: 此处吐槽一下, 每次编译十多分钟, 苦等半天你告诉我就因为代码不规范…我吐血哦…</em></p>
</li>
</ol>
<p><strong>FQA</strong><br>Q: 有人问, 我只做了生成metrics, 那么怎么暴露的, 怎么转为prometheus的?<br>A: 这个就要看<code>flink-metrics</code>中代码了, 其实我们什么也不用做, 其会根据配置使用对应的监控数据格式将所有metrics转换后暴露出去. 接口设计的很nice.</p>
<p>Q: 有做好的grafana看板吗?我想做个伸手党.<br>A: 有, 我也是站在巨人的肩膀上, 改进了下. 我想你也可以, 等我有空了整理一套prometheus的各种看板一起贴出.</p>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>wine 微信安装问题解决</title>
    <url>/2020/06/07/wine%20%E5%BE%AE%E4%BF%A1%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="wine-微信安装问题解决"><a href="#wine-微信安装问题解决" class="headerlink" title="wine 微信安装问题解决"></a>wine 微信安装问题解决</h1><p>wine安装wechat后出现输入框无法输入文字的问题, 解决方法如下:</p>
<ol>
<li>使用winetricks安装gdiplus riched20 riched30:<br><code>winetricks gdiplus riched20 riched30</code></li>
<li>输入法使用的是fctix-rime, 需要修改env环境变量: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">QT4_IM_MODULE&#x3D;fcitx</span><br><span class="line">QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">XIM&#x3D;fcitx</span><br><span class="line">XIM_PROGRAM&#x3D;fcitx</span><br><span class="line">XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br></pre></td></tr></table></figure></li>
<li>字体出现框框, 需要安装中文字体, 系统那个安装微软雅黑、宋体、黑体, 在<code>~/.wine/drive_c/windows/Fonts</code> 下面安装中文字体</li>
<li>字体发虚, 解决: <code>winetricks settings fontsmooth=rgb</code></li>
</ol>
]]></content>
      <categories>
        <category>折腾笔记</category>
      </categories>
      <tags>
        <tag>wine</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>比较[]int的方法实现</title>
    <url>/2020/06/07/%E5%88%A4%E6%96%ADint%E6%95%B0%E7%BB%84string%E6%95%B0%E6%8D%AE%E7%9B%B8%E7%AD%89%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BD%8D%E6%93%8D%E4%BD%9C%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="判断int数组-string数据相等的方法及位操作讨论"><a href="#判断int数组-string数据相等的方法及位操作讨论" class="headerlink" title="判断int数组/string数据相等的方法及位操作讨论"></a>判断int数组/string数据相等的方法及位操作讨论</h1><h3 id="判断int数组相等-数组元素可能重复"><a href="#判断int数组相等-数组元素可能重复" class="headerlink" title="判断int数组相等(数组元素可能重复)"></a>判断int数组相等(数组元素可能重复)</h3><p>go中我们时常会遇到判断两个int数组是否相同的需求, 自己撸一个方法也很简单, 搞起来:</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>思路1: 把两个数组排序以后,对比每个位置上的数据是否相同.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSliceEqualSlow</span><span class="params">(a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(a)</span><br><span class="line">	sort.Ints(b)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> b[k] != v &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样每个数组都需要排序, 如果是快排, 也是o(2nlgn+n) ~ o(nlgn)时间复杂度, 有点慢啊</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>思路2: 观察发现, 如果两个数组相同 , 那么其中任一个int数据其出现的次数一定是偶数个的, 那么用hash记录一下出现次数, 空间换时间?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSliceEqualHash</span><span class="params">(a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">	<span class="keyword">var</span> v, tmp <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> _, v = <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp, ok = hashMap[v]; ok &#123;</span><br><span class="line">			hashMap[v] = tmp + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			hashMap[v] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v = <span class="keyword">range</span> b &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp, ok = hashMap[v]; ok &#123;</span><br><span class="line">			hashMap[v] = tmp - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v = <span class="keyword">range</span> hashMap &#123;</span><br><span class="line">		<span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法3-只针对数组内存在重复的情况"><a href="#方法3-只针对数组内存在重复的情况" class="headerlink" title="方法3 (只针对数组内存在重复的情况)"></a>方法3 (只针对数组内存在重复的情况)</h4><p>思路3: 如果两个数组相同 , 那么其中任一个int数据其出现的次数一定是偶数个的, 用hash空间消耗也不少. 我们知道一个数与或其自己一定是0,偶数个相同的数与或也一定是0,那么用位操作岂不是很快? </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSliceEqual</span><span class="params">(a, b []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		r = r ^ v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">		r = r ^ v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上实现 针对 <code>[2 2 2] [2 3 3]</code>和<code>[-1 -1 2 2] [0 0 1 1]</code>这样的数组就失效了.</strong></p>
<h4 id="对比测试"><a href="#对比测试" class="headerlink" title="对比测试"></a>对比测试</h4><ol>
<li>测试正确性:</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	input = [][][]<span class="keyword">int</span>&#123;</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;<span class="literal">nil</span>, []<span class="keyword">int</span>&#123;&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;&#125;,<span class="literal">nil</span>&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;<span class="literal">nil</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;<span class="literal">nil</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;, <span class="literal">nil</span>&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;&#125;,</span><br><span class="line">		[][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	expect = []<span class="keyword">bool</span>&#123;</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsSliceEqual</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Run(<span class="string">"1:"</span>, TestIsSliceEqual1)</span><br><span class="line">	t.Run(<span class="string">"2:"</span>, TestIsSliceEqual2)</span><br><span class="line">	t.Run(<span class="string">"3:"</span>, TestIsSliceEqual3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsSliceEqual1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">if</span> r := isSliceEqualSlow(v[<span class="number">0</span>], v[<span class="number">1</span>]); r != expect[k] &#123;</span><br><span class="line">			t.Errorf(<span class="string">"at %d, input: %v, expect: %v, result: %v, not equal"</span>, k, v, expect[k], r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsSliceEqual2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">if</span> r := isSliceEqualHash(v[<span class="number">0</span>], v[<span class="number">1</span>]); r != expect[k] &#123;</span><br><span class="line">			t.Errorf(<span class="string">"at %d, input: %v, expect: %v, result: %v, not equal"</span>, k, v, expect[k], r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsSliceEqual3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">if</span> r := isSliceEqual(v[<span class="number">0</span>], v[<span class="number">1</span>]); r != expect[k] &#123;</span><br><span class="line">			t.Errorf(<span class="string">"at %d, input: %v, expect: %v, result: %v, not equal"</span>, k, v, expect[k], r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注:</strong><br><code>TestIsSliceEqual3</code>无法通过测试,但是如果是数组元素不重复的测试集则可以通过测试. </p>
<ol start="2">
<li>benchmarks测试</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsSliceEqual</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">"1:"</span>, BenchmarkIsSliceEqual1)</span><br><span class="line">	b.Run(<span class="string">"2:"</span>, BenchmarkIsSliceEqual2)</span><br><span class="line">	b.Run(<span class="string">"3:"</span>, BenchmarkIsSliceEqual3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsSliceEqual1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">			isSliceEqualSlow(v[<span class="number">0</span>], v[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsSliceEqual2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">			isSliceEqualHash(v[<span class="number">0</span>], v[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsSliceEqual3</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">			isSliceEqual(v[<span class="number">0</span>], v[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: testcase</span><br><span class="line">BenchmarkIsSliceEqual&#x2F;1:-8         	  579404	      1818 ns&#x2F;op	     512 B&#x2F;op	      16 allocs&#x2F;op</span><br><span class="line">BenchmarkIsSliceEqual&#x2F;2:-8         	  502230	      2515 ns&#x2F;op	     256 B&#x2F;op	       8 allocs&#x2F;op</span><br><span class="line">BenchmarkIsSliceEqual&#x2F;3:-8         	 6719389	       180 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>

<p>由测试结果可见:  位操作的威力之大! 写代码时常还是需要考虑性能的, <strong>代码=数据结构+算法</strong>的确是哲理.同时附上个人理解 <strong>业务&gt;代码</strong>,哈哈:-).</p>
<p>针对不同的数据场景可以选择不同的比较方式, 如果输入的数组中元素不重复, 那么就使用位操作的方法, 如果重复, 则使用第一种方式, 排序后依次对比.</p>
<h3 id="发散思考1"><a href="#发散思考1" class="headerlink" title="发散思考1"></a>发散思考1</h3><p>既然位操作很niubility, 那么不由得想到leetcode上各种位操作解题. 其中有个问题正好来研究研究:<br><code>位移操作 比 &amp; 操作 慢吗?</code></p>
<p>问题由来: <a href="https://leetcode.com/problems/counting-bits/" target="_blank" rel="noopener">counting-bits</a> 以及<a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">Number of 1 Bits</a></p>
<p>对于计算1的个数的实现:</p>
<h4 id="方法1-使用位移操作"><a href="#方法1-使用位移操作" class="headerlink" title="方法1 使用位移操作"></a>方法1 使用位移操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeightBitMove</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">		res += <span class="keyword">int</span>(num &amp; <span class="number">1</span>)</span><br><span class="line">		num = num &gt;&gt; <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法2-使用-amp-和减1操作"><a href="#方法2-使用-amp-和减1操作" class="headerlink" title="方法2 使用&amp;和减1操作"></a>方法2 使用&amp;和减1操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeightMinusOne</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">		res++</span><br><span class="line">		num = (num - <span class="number">1</span>) &amp; num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	input = []<span class="keyword">uint32</span>&#123;</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">2</span>,</span><br><span class="line">		<span class="number">4</span>,</span><br><span class="line">		<span class="number">7</span>,</span><br><span class="line">		<span class="number">8</span>,</span><br><span class="line">		<span class="number">12345</span>,</span><br><span class="line">		<span class="number">54321</span>,</span><br><span class="line">		<span class="number">123456789</span>,</span><br><span class="line">		<span class="number">987654321</span>,</span><br><span class="line">		<span class="number">1357924680</span>,</span><br><span class="line">		<span class="number">2468013579</span>,</span><br><span class="line">		<span class="number">2</span>&lt;&lt;<span class="number">31</span> <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	expect = []<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">3</span>,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">6</span>,</span><br><span class="line">		<span class="number">7</span>,</span><br><span class="line">		<span class="number">16</span>,</span><br><span class="line">		<span class="number">17</span>,</span><br><span class="line">		<span class="number">11</span>,</span><br><span class="line">		<span class="number">15</span>,</span><br><span class="line">		<span class="number">32</span>,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHammingWeightBitMove</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> tmp <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> input&#123;</span><br><span class="line">		<span class="keyword">if</span> tmp = hammingWeightBitMove(v); expect[k] != tmp&#123;</span><br><span class="line">			t.Errorf(<span class="string">"at index %v, input: %v, expect: %v, get %v"</span>,k,v,expect[k],tmp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHammingWeightMinusOne</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> tmp <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> k,v:=<span class="keyword">range</span> input&#123;</span><br><span class="line">		<span class="keyword">if</span> tmp = hammingWeightMinusOne(v); expect[k] != tmp&#123;</span><br><span class="line">			t.Errorf(<span class="string">"at index %v, input: %v, expect: %v, get %v"</span>,k,v,expect[k],tmp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHammingWeight</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">	t.Run(<span class="string">"bit move:"</span>,TestHammingWeightBitMove)</span><br><span class="line">	t.Run(<span class="string">"minus one:"</span>,TestHammingWeightMinusOne)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHammingWeightBitMove</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> _, v:=<span class="keyword">range</span> input&#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">			hammingWeightBitMove(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHammingWeightMinusOne</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> _, v:=<span class="keyword">range</span> input&#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">			hammingWeightMinusOne(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHammingWeight</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">	b.Run(<span class="string">"bit move:"</span>, BenchmarkHammingWeightBitMove)</span><br><span class="line">	b.Run(<span class="string">"minus one:"</span>,BenchmarkHammingWeightMinusOne)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下, 可见使用减1取与 <code>n = n &amp; (n-1)</code> 确实比位移操作 <code>n = n &gt;&gt; 1</code> 快, 原因是计算机中数据都是使用补码存储的, 操作补码执行位移操作就比执行&amp;操作耗时一些了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: testonebits</span><br><span class="line">BenchmarkHammingWeight&#x2F;bit_move:-8         	 4188075	       293 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkHammingWeight&#x2F;minus_one:-8        	 6249888	       196 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok  	testonebits	2.942s</span><br></pre></td></tr></table></figure>

<h3 id="发散思考2"><a href="#发散思考2" class="headerlink" title="发散思考2"></a>发散思考2</h3><p>那么比较两个字符串数组是否相等, 又该如何比较呢?</p>
<p>暂时只想到用hash/sort. 如果你有好的方法, 请不吝赐教.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isStrSliceEqualHash</span><span class="params">(a []<span class="keyword">string</span>, b []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp, ok := hashMap[v]; ok &#123;</span><br><span class="line">			hashMap[v] = tmp + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			hashMap[v] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp, ok := hashMap[v]; ok &#123;</span><br><span class="line">			hashMap[v] = tmp - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> hashMap &#123;</span><br><span class="line">		<span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isStrSliceEqualSort</span><span class="params">(a []<span class="keyword">string</span>, b []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(a)</span><br><span class="line">	sort.Strings(b)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> v != b[k] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试数据:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> D <span class="keyword">struct</span> &#123;</span><br><span class="line">	input  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expect <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataStr = []D&#123;</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"abcef"</span>, <span class="string">"ef"</span>, <span class="string">"abcdefg"</span>, <span class="string">"abcdf"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"abcef"</span>, <span class="string">"ef"</span>, <span class="string">"abcdefg"</span>, <span class="string">"abcdf"</span>&#125;&#125;, <span class="literal">true</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"abcdefg"</span>, <span class="string">"abcdf"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"abcdeg"</span>, <span class="string">"abcdfg"</span>, <span class="string">"abc"</span>, <span class="string">""</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"abcdeg"</span>, <span class="string">"abcdfg"</span>, <span class="string">"abc"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;&#125;, []<span class="keyword">string</span>&#123;<span class="string">"abcdeg"</span>, <span class="string">"abcdfg"</span>, <span class="string">"abc"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;&#125;, []<span class="keyword">string</span>&#123;&#125;&#125;, <span class="literal">true</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;&#125;, <span class="literal">nil</span>&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;<span class="literal">nil</span>, <span class="literal">nil</span>&#125;, <span class="literal">true</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;<span class="literal">nil</span>, []<span class="keyword">string</span>&#123;&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;<span class="literal">nil</span>, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"123"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"123"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"123"</span>&#125;&#125;, <span class="literal">true</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"1234"</span>, <span class="string">"1234"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"123"</span>, <span class="string">"1234"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"1234"</span>, <span class="string">""</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"1234"</span>, <span class="string">""</span>, <span class="string">""</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"1234"</span>, <span class="string">"1234"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>, <span class="string">"1234"</span>, <span class="string">"1234"</span>, <span class="string">"1234"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">"123"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>&#125;&#125;, <span class="literal">true</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"123"</span>&#125;&#125;, <span class="literal">false</span>&#125;,</span><br><span class="line">		D&#123;[][]<span class="keyword">string</span>&#123;[]<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;&#125;, <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: testonebits</span><br><span class="line">BenchmarkIsStrSliceEqual&#x2F;hash:-8         	  593346	      2113 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkIsStrSliceEqual&#x2F;sort:-8         	  576940	      2014 ns&#x2F;op	     512 B&#x2F;op	      16 allocs&#x2F;op</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>两者相差无几.</p>
<h3 id="速记-位操作的各种技巧"><a href="#速记-位操作的各种技巧" class="headerlink" title="速记: 位操作的各种技巧"></a>速记: 位操作的各种技巧</h3><ol>
<li>实现乘除法:  <code>&gt;&gt; 1</code>右移1位 等于 除以2, <code>&lt;&lt;1</code>左移1位等于 乘以2,  左右移相比乘除法快一点</li>
<li><strong>位操作进行两数值交换:  <code>a^=b; b^=a; a^=b;</code>, 适合各种比较后交换的排序场景</strong></li>
<li><strong>判断奇偶: <code>n &amp; (n -1) == 0</code> 或者 <code>n &amp; 1 == 0</code>是偶数 否则 奇数, 比使用 <code>n % 2</code> 效率高, 适合交替执行的条件判断场景</strong></li>
<li>交换符号将正数变成负数，负数变成正数: <code>~a + 1</code> , 整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</li>
<li><strong>求绝对值: 对于32位数而言,  符号位: <code>flag = a &gt;&gt; 31</code>; 绝对值则是 <code>((a ^ flag) - flag)</code>, 求绝对值公式: <code>(a^(a&gt;&gt;31))-(a&gt;&gt;31)</code>, 适合高频求绝对值进行数据判断的场景</strong></li>
<li><a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">二进制逆序</a>:  对于32位数, 依次以 2 , 4, 6, 8 位作为一组，再进行组内高低位交换<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = (( a &amp; <span class="number">0xAAAA</span>) &gt;&gt; <span class="number">1</span> | (( a &amp; <span class="number">0x5555</span>)  &lt;&lt; <span class="number">1</span>)</span><br><span class="line">a = (( a &amp; <span class="number">0xCCCC</span>) &gt;&gt; <span class="number">2</span>  | (( a &amp; <span class="number">0x3333</span>)  &lt;&lt; <span class="number">2</span>)</span><br><span class="line">a = (( a &amp; <span class="number">0xF0F0</span>) &gt;&gt; <span class="number">4</span>   | (( a &amp; <span class="number">0x0F0F</span>)  &lt;&lt; <span class="number">4</span>)</span><br><span class="line">a = (( a &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>   | (( a &amp; <span class="number">0x00FF</span>)  &lt;&lt; <span class="number">8</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>取两个数的平均数: 使用 <code>( x&amp;y ) + ((x ^ y) &gt;&gt; 1)</code> 比使用 <code>(x+y)/2</code>效率高. 适合热点代码并且无需考虑 <code>x+y</code> 溢出的问题. 前半部分求得相同的bit,其除2后保持不变,后半部分求不同的bit,右移1位即除以2.加和后即是平均数. 适合高频求平均数场景.</strong></li>
</ol>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>language</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>RoaringBitMap小试牛刀</title>
    <url>/2020/08/27/RoaringBitmap%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</url>
    <content><![CDATA[<h1 id="RoaringBitmap小试牛刀"><a href="#RoaringBitmap小试牛刀" class="headerlink" title="RoaringBitmap小试牛刀"></a>RoaringBitmap小试牛刀</h1><h2 id="什么是RoaringBitmap"><a href="#什么是RoaringBitmap" class="headerlink" title="什么是RoaringBitmap"></a>什么是RoaringBitmap</h2><p>RoaringBitmap的<a href="https://github.com/RoaringBitmap/" target="_blank" rel="noopener">官方github代码库:</a> 中提供了各种语言的实现.<br>论文地址: <a href="http://db.ucsd.edu/wp-content/uploads/2017/03/sidm338-wangA.pdf" target="_blank" rel="noopener">http://db.ucsd.edu/wp-content/uploads/2017/03/sidm338-wangA.pdf</a></p>
<p>roaringbitmap属于bitset中的一种, 他是bitmap的升级优化版. 对于大量数据的去重, 大量数据中是否存在的查询, 合并多个数据集合取交并集等场景比较适用.  类似的还有EWAHCompressedBitmap.</p>
<p>RoaringBitmap的存储数据结构主要有以下三种:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">keys []<span class="keyword">int16</span></span><br><span class="line">values []Container</span><br><span class="line">size <span class="keyword">int</span>(<span class="keyword">int32</span>)</span><br></pre></td></tr></table></figure>
<p>它的原理是: 对于32位的整数, 分开成两个部分, 即高16位和低16位(int16类型), 高16位存储到 <code>keys []uint16</code>中, 低16位被存储到<code>values</code>中, <code>size</code>表示当前包含的key-value对的个数.  keys的数组永远保持有序的, 通过二分查找进行数据的搜索. </p>
<p>低16的Container根据数据量情况有三种存储形式. </p>
<ul>
<li><code>ArrayContainer</code>:  对于数据个数小于<code>DEFAULT_MAX_SIZE</code>(4096)的, 存储在<code>ArrayContainer</code>中, 其实际就是一个<code>[]int16</code>的数组, 数据直接按照顺序存在其中, 通过二分查找进行搜索. 适合这个高16的id区间下只有少量数据的场景. 每个数据2B, 容器大小最大为8kb, 这个大小刚好适合存入cache, 以通过cache命中来加速读取效率. </li>
<li><code>BitmapContainer</code>: 对于数据个数大于<code>DEFAULT_MAX_SIZE</code>的, 则将存储容器转换为<code>BitmapContainer</code>, 其是一个由<code>int64</code>组成的位图数组<code>bitmap []int64</code>. 因为是低16位,要表示这些数据就需要2^16(65536)个比特位, 每个int64存储64个, 总共就需要1024个int64来存储这些比特位. 不管其中真的存储了一个还是全部65536个数据的标记, 都会初始化占用这1024个int64, 即固定的8kb内存空间. </li>
<li><code>RunContainer</code>: 对于只存一个1的bitmapcontainer来说实在是太浪费空间了, 那就就可以通过行程长度压缩算法对连续的数据进行压缩. 对于连续出现的数字，只记录初始数字和后续数量:<ol>
<li>对于数列11，它会压缩为11,0；</li>
<li>对于数列11,12,13,14,15，它会压缩为11,4；</li>
<li>对于数列11,12,13,14,15,21,22，它会压缩为11,4,21,1；<br>数据存储在<code>[]int16</code>中, 他的性能最好情况，即只存在一个数据或只存在一串连续数字，那么只会存储2个int16，占用4字节. 最坏情况，0~65535的范围内填充所有的奇数位（或所有偶数位），需要存储65536个int16，128kb. 这里是只对于比特位为1的数据进行记录或者只对于0的数据进行记录.</li>
</ol>
</li>
</ul>
<p>只有<code>BitmapContainer</code>可以通过下标在O(1)时间查询, array容器是通过二分查找来查询O(logn), run容器通过顺序查找进行搜索. </p>
<p>在使用时, 对于如何生成存储的容器, 使用哪种容器, 以及怎么做容器转换都进行了优化:</p>
<ul>
<li>创建单个值时使用arraycontainer</li>
<li>创建连续的值时比较array和run的空间代价选择较少的</li>
<li>对于array容器, 数据量超过4096后自动转为bitmap容器, 通过调用优化方法比较转为run容器和bitmap的容器空间大小来决定是否转换为runcontainer</li>
<li>对于bitmap容器,当数据量低于4096后转为array容器, 调用优化方法根据空间来决定是否转为run容器.</li>
<li>对于run容器,在调用优化方法后会对比三种容器的空间来决定是否转化为对应的容器存储. </li>
</ul>
<h2 id="go版本实际使用体验"><a href="#go版本实际使用体验" class="headerlink" title="go版本实际使用体验"></a>go版本实际使用体验</h2><p>go版本的roaringbitmap地址为:<a href="https://github.com/RoaringBitmap/roaring" target="_blank" rel="noopener">https://github.com/RoaringBitmap/roaring</a><br>其中提供了对于64位数据进行支持的API(存储keys的切片数组从[]uint16换成了[]uint32).</p>
<p>roaringbitmap中在进行二分查找的时候,如果找不到会返回当前index的负数, 这样可以方便知道位置信息, 这种优化细节可以很好的加速下次临近数据的查找.</p>
<p>使用示例可以直接参考官方的代码示例.  刚好我这里有个应用场景, 我这边业务有多张mysql数据表, 其中的数据总量在2000万左右, 而且数据还在不断的写入. 其中每个表的都有uid字段(64位整数), 并且这个字段不是唯一的,同时由一个自增的id键值. 现在需要实时的统计这多张数据表中所有的uid去重后的总数. 如果每次统计都通过sql去多张表进行distinct的计算, 每计算一次都需要花个几分钟. 实际上我只需要在第一次将全部去重数据计算好并存下来, 下一次计算就只把新增的数据和这个旧的数据集进行一个并集的操作, 那个新产生的数据集大小不就是我要的总数吗? 使用一个hashmap可以存储这个数据, hash的key值存储uid, value为一个最小数据类型. 这样这个hashmap的key会很庞大,并且数据散列度较大, 有没有更好的存储方式呢?  想到这里, 我就想到了使用roaringmap. </p>
<p>具体办法是:  第一次运行, 通过多个goroutine对每个表都通过id按照固定的步长分批查询uid数据, 把结果交给一个goroutine去写入roaringbitmap, 将这个bitmap存在文件中, 并保存下每个表当前查询到的最大id. 以后再次执行时就在上次查询的最大id基础上依旧多goroutine并发查询uid数据并写入一个新的bitmap, 最后对两个bitmap进行or操作, 就得到了当前的全量去重uid. </p>
<p>~这里goroutine的并发数量设置为cpu数量的2倍. id步长递增量拍脑袋设的10000. ~</p>
<p>这里跑个题, 由于go数据库连接使用的连接池, 不需要考虑每次请求都重新建立tcp连接.  而每个IP包能实际携带的tcp数量量在1460B以下, 实际可能就只有1400B, 每个uid都是8B, 这样一算一个IP包就最多能携带175个数据, 这还要不考虑其他协议的数据, 所以如果想让每个tcp都不分片, 都刚好被一个IP包承载, 就需要每次取数据量在175以下.真的这样可以最大优化吗? 实际上不是, 每批数据量很小, 每次都要经过操作系统的层层传递, 还不如一次性把大量的数据拿过来, 这样不用每个goroutine的请求都要经过两端操作系统的各种数据传递, 数据的解析执行, 数据库中各种数据读取操作. 反而性能会更好. </p>
<p>实际测试, 100多万的数据, 直接一次请求获取需要1.92s左右, 比我人工批量取100万个要好很多.  </p>
<p>另外由于goroutine本身除了垃圾处理和内存占用外, 只要没被调度, 就没什么消耗, 可以尽量创建, 不需要人工设置一个太小的上限, 当然, 如果为了控制内存和性能, 还是要有个上限, 这个上限可以大很多. 就如<a href="https://golang.org/doc/faq#goroutines" target="_blank" rel="noopener">Why goroutines instead of threads?:</a> 中所说, 在同一个地址空间中创建数十万个goroutine是很实际的。在4 GB内存的计算机上，goroutine的最大数量限制大约为略少于100万的数字。每个goroutine大约占用4KB多的栈空间, goroutine的初始栈空间, 在1.2的时候扩到8K(2个操作系统page), 在1.4的时候又减到2K, 这些变化是由于分段堆栈在段之间快速来回切换时造成了性能问题(“热堆栈分割”), 当分段的堆栈被替换为连续的堆栈后就在1.4中减少到2k了.</p>
<p>所以可以尽可能的创建goroutine, 但是实际使用的时候就会遇到操作系统的limit瓶颈, 如果操作系统限制了open file的数量, 那么将在达到限制后无法创建更多的网络请求, 也就导致goroutine的执行数量被限制. 可参考<a href="https://groups.google.com/g/golang-nuts/c/l-euVrgfaxo" target="_blank" rel="noopener">这里</a> </p>
<p>因此, 最后确定了设置并发上限为10000, 并且一次尽可能多的请求数据(1干万数据大约77MB,一次请求1千万).</p>
<p>最终在千兆带宽的内网服务器上执行效果是11.317s跑完首次数据写入, 其后如果间隔10分钟执行则只需0.682s.</p>
<p>去重后uid数据量为100多万 </p>
<p>存储的bitmap文件大小: 2.6M. 如果使用map的数据结构存储, 每个key都是8B, 那么这100多万数据就要7.63M的空间了, 再加上value的空间就更大了. 可见roaringbitmap的威力. </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>go blog 学习笔记</title>
    <url>/2020/08/24/go%20blog%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="go-blog-学习笔记"><a href="#go-blog-学习笔记" class="headerlink" title="go blog 学习笔记"></a>go blog 学习笔记</h2><h2 id="The-Go-Memory-Model"><a href="#The-Go-Memory-Model" class="headerlink" title="The Go Memory Model"></a>The Go Memory Model</h2><p><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">The Go Memory Model</a></p>
<p><code>Reads and writes of values larger than a single machine word behave as multiple machine-word-sized operations in an unspecified order.</code><br>读写大于一个机器字的数据会表现为对多个机器字大小的数据进行不确定执行顺序的操作.</p>
<p>编译器存在重排的可能,多核执行也存在乱序的执行,  所以, 针对如下的语句可能出现b先被赋值的情况, 如果并发读取a,b的值可能会出现不同的效果. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>文章最后给出了一个解决办法: 任何时候都使用显示的同步, 去控制数据的变化. </p>
<h2 id="Errors-are-values"><a href="#Errors-are-values" class="headerlink" title="Errors are values"></a>Errors are values</h2><p><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a></p>
<p>Error也是一种数据, 对于复杂的错误返回或者多次执行的错误返回, 可通过定义一个包含Err 属性的返回对象, 其定义了error字段, 以便在执行逻辑的最后读取该字段来获取是否发生了error. </p>
<p>在1.13以后go中通过添加了error的IS AS, Unwrap来扩展error的对于嵌套场景的使用.<br><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">Working with Errors in Go 1.13</a> </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go 调度器是部分抢占式的以及如何调度</title>
    <url>/2020/09/12/go%20%E8%B0%83%E5%BA%A6%E5%99%A8%E6%98%AF%E9%83%A8%E5%88%86%E6%8A%A2%E5%8D%A0%E5%BC%8F%E7%9A%84%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="go-调度器是部分抢占式的以及如何调度"><a href="#go-调度器是部分抢占式的以及如何调度" class="headerlink" title="go 调度器是部分抢占式的以及如何调度"></a>go 调度器是部分抢占式的以及如何调度</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cpuIntensive</span><span class="params">(p *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">100000000000</span>; i++ &#123;</span><br><span class="line">    *p = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  x := <span class="number">0</span></span><br><span class="line">  <span class="keyword">go</span> cpuIntensive(&amp;x)</span><br><span class="line"></span><br><span class="line">  time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// printed only after cpuIntensive is completely finished</span></span><br><span class="line">  fmt.Printf(<span class="string">"x = %d.\n"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码, print只在cpuIntensive执行完毕后才打印. 除非你在cpuIntensive中手动加入了runtime.Gosched(). 原因是密集的cpu计算过程并不包含可以抢占的抢占点(IO阻塞/垃圾回收等), 实际使用场景中很少会有这种, 但是如果你遇到这样的事情, 就需要手动的添加一些可以抢占的点, 手动除非调度器执行调度.</p>
<p>如果一个goroutine执行过程中到达了go中定义的可以抢占的点(IO/垃圾回收/等待输入等), 那么就会让出执行权给在同一个thread或全局goroutine队列中goroutine, 这个过程对于操作系统层面看是无感知的.切换的代价很小, 只需要变更3个寄存器的值,因此很轻量. go 多路复用thread线程, 这种实现不要求开发者自己去显示地通过事件循环和回调来处理futures/promises. 这种显示的处理需要是在同一个thread中手动创建事件循环,并利用操作系统提供的事件描述符与回调机制做处理.</p>
<p>go中block的goroutine会调用对应的操作系统内核提供的多路并发机制(epoll等)来等待执行结果的返回并同时让出当前线程的执行权限给其他goroutine.但是如果系统不支持IO多路复用,go会创建一个新的线程会去执行其他goroutine, 并等待到block结束后,重新返回这个goroutine,这时可能会存在多于cpu数量GOMAXPROCS的内核线程,这时就不受GOMAXPROCS控制了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evport -&gt; soloris   O(1)</span><br><span class="line">epoll -&gt; linux O(1)</span><br><span class="line">kequeue -&gt; OS X和freeBSD O(1)</span><br><span class="line">select -&gt; 所有系统平台 O(n) 最大支持1024个事件描述符</span><br></pre></td></tr></table></figure>

<p>goroutine建立在事件驱动的架构之上. 同时并发的事件数量受到进程可以同时打开的文件描述符数量限制. 因此ulimit -n 必须设置一个合理值以供在进行大量同时的IO处理使用. 由于IO事件返回通常有一个超时设定, 返回后的文件描述符就会可被其他并发的事件使用, 因此一个较大的nofile值就足够cover大量的并发事件.</p>
<p>对于并发请求服务时,还需要考虑服务端是否有并发限制, 所以同时执行的goroutine数量还需要有一定的考虑</p>
<p>参考 <a href="https://hadar.gr/2017/lightweight-goroutines" target="_blank" rel="noopener">https://hadar.gr/2017/lightweight-goroutines</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go高级编程--分布式系统学习笔记</title>
    <url>/2020/09/12/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="go高级编程–分布式系统学习笔记"><a href="#go高级编程–分布式系统学习笔记" class="headerlink" title="go高级编程–分布式系统学习笔记"></a>go高级编程–分布式系统学习笔记</h1><p>谷歌的chubby论文中提到: 基于强一致协议的锁适用于 粗粒度 的加锁操作, 粗粒度即占用锁时间较长的场景, 基于分布式的阻塞锁比较适合分布式任务调度场景, 但是不适合高频次的短时间抢锁操作. 比如对于秒杀系统来说, 使用redis或try-lock来做 胜者为王的操作. 而使用zookeeper/etcd就不适合这种场景, zookeeper的加锁会使得竞争者处于阻塞状态, 只有一个人成功返回. 而redis可用setnx操作使得失败者立刻返回, 胜者进入后续逻辑.  如果业务对锁的一致性要求很高,即保证锁数据的可靠性, 那么就需要使用zookeeper和etcd而不能用redis, 代价是较低的吞吐量和较高的延迟.<br>zk和etcd是无法通过横向扩展提高性能的, 只能增加多个集群.</p>
<p>定时器的实现: 时间堆(小顶堆/四叉树–go内置定时器实现) 和 时间轮(类似hash或时钟)</p>
<p>时间堆: 对于一个时间, 如果小于对顶则堆内定时任务都未到触发时间, 检查时间复杂度为o(1), 如果时间小于堆顶,则弹出对顶和做堆调整, 复杂度为o(lgN), 直到时间小于堆顶. 同时触发弹出任务.</p>
<p>时间轮: 时间每次转动到一个刻度时检查其挂载的任务是否已经到期, 每个任务分配时通过hash 触发时间%时间轮元素大小来确定挂载位置, 如果冲突就通过链表挂载进行扩展. </p>
<p>DSL可以表示程序的boolean表达式, json可以表示DSL, 所以json可以表示树状结构就能表示DSL就能描述程序的抽象语法树.</p>
<p>canal通过伪装成mysql的从库获取mysql的binlog,解析成json格式通过kafka交给下游的数据库进行分析消费或者做OLAP(数据分析)事务,下游通过写入es进行纯查询业务, 要求表中必须有唯一的主键id保证写入数据不重复, 同时通过直接覆盖id对应数据来避免了区分新增还是更新.</p>
<p>go 的rand.Perm是经过修正的随机洗牌算法, 使用经典的fisher-yates算法, 这个随机是伪随机. 如果需要使用真随机, 使用随机种子, <code>rand.Seed(time.Now().UnixNano())</code></p>
<p>配置的本地缓存可以解决配置中心不可用的问题, 但是却又引入了配置文件不一致的问题,需要监控该问题. 配置中心对于大量的配置场景又需要考虑网络和存储负载. 同时配置文件的获取需要结合业务逻辑, 在业务逻辑执行时获取配置并更新配置会导致当前业务执行逻辑上的配置前后不一致.  配置的变更需要记录, 以便快速回滚.</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>尾调用/函数式编程 初识以及go的相关</title>
    <url>/2020/09/12/%E5%B0%BE%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%20%E5%88%9D%E8%AF%86%E4%BB%A5%E5%8F%8Ago%E7%9A%84%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="尾调用-函数式编程-初识以及go的相关"><a href="#尾调用-函数式编程-初识以及go的相关" class="headerlink" title="尾调用/函数式编程 初识以及go的相关"></a>尾调用/函数式编程 初识以及go的相关</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程: 函数式编程最常见的技术就是对一个集合做Map、Reduce和Filter操作，map对集合成员做了映射操作，生成新的集合；reduce就是降维操作，化整为零；filter顾名思义通过过滤器生成新的集合。</p>
<p>其特点是把函数当成变量来用</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归算法在使用栈（stack，先进后出）来执行数据操作的时候是非常方便的，它比循环操作更快，并且代码的简洁性好。</p>
<p>递归带来的效率问题主要是函数调用带来的额外开销（函数的入栈出栈），以及栈容量的限制（次数太多可能会stack overflow）</p>
<h4 id="递归算法："><a href="#递归算法：" class="headerlink" title="递归算法："></a>递归算法：</h4><p>优点：代码简洁、清晰，并且容易验证正确性。（如果你真的理解了算法的话，否则你更晕）<br>缺点：它的运行需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理（还有可能出现堆栈溢出的情况），比如参数传递需要压栈等操作，会对执行效率有一定影响。但是，对于某些问题，如果不使用递归，那将是极端难看的代码。</p>
<h4 id="循环算法："><a href="#循环算法：" class="headerlink" title="循环算法："></a>循环算法：</h4><p>优点：速度快，结构简单。<br>缺点：并不能解决所有的问题。有的问题适合使用递归而不是循环。如果使用循环并不困难的话，最好使用循环。</p>
<p>系统栈（也叫核心栈、内核栈）是内存中属于操作系统空间的一块区域，其主要用途为： (1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出； (2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。<br>用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。<br>我们编写的递归程序属于用户程序，因此使用的是用户栈。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>也就是把接受多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数而且返回结果的新方法。将多参数的函数转换成单参数的形式</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incx</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> incx</span><br><span class="line"> </span><br><span class="line">inc2 = inc(<span class="number">2</span>)</span><br><span class="line">inc5 = inc(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> inc2(<span class="number">5</span>) <span class="comment"># 输出 7</span></span><br><span class="line"><span class="keyword">print</span> inc5(<span class="number">5</span>) <span class="comment"># 输出 10</span></span><br></pre></td></tr></table></figure>

<h2 id="尾调用-尾递归"><a href="#尾调用-尾递归" class="headerlink" title="尾调用/尾递归"></a>尾调用/尾递归</h2><p>某个函数的最后一步是调用另一个函数,这就是尾调用.</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，<strong>只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。</strong> 这就是”<strong>尾调用优化</strong>“的意义。</p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 如果其递归函数的第一个参数是需要返回的计算结果或者是中间变量.</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用for循环执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorialFor</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res = res * i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归, 内存占用O(n) 因为需要保存n个调用记录(中间结果)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归, 理论上内存占用 O(1) 只需要保留一个调用记录, 实际上到go1.13都没有进行优化, 依旧是O(n) , 测试执行会比上面的快一点, 是因为函数调用尾递归调用中在管理stack frames上开销小一点. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n,total <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="keyword">return</span> total&#125;</span><br><span class="line">    <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 测试结果:</span><br><span class="line">BenchmarkTailRecursive/For:-8         	68877586	        17.0 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkTailRecursive/Rec:-8         	10000900	       119 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkTailRecursive/Tail:-8        	11536790	       102 ns/op	       0 B/op	       0 allocs/op</span><br></pre></td></tr></table></figure>
<p>似乎for循环更快. 因为减少了递归调用的压栈/出栈操作和函数调用的开销. </p>
<p><strong>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数</strong> </p>
<p>可用通过外层再包装一层函数来隐藏尾递归优化的多出来的参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过柯里化来做:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">currying</span><span class="params">(fn <span class="keyword">func</span>, total <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(fn <span class="keyword">func</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(n,total)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Factorial = currying(factorial,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用: Factorial(5)</span></span><br></pre></td></tr></table></figure>
<p>当然如果像python那样支持默认参数值的,就可以通过默认参数设置默认值隐藏第二个参数了.</p>
<h2 id="go的尾调用-tail-calls-优化"><a href="#go的尾调用-tail-calls-优化" class="headerlink" title="go的尾调用(tail calls)优化"></a>go的尾调用(tail calls)优化</h2><p>当你要使用递归的时候，你需要意识到栈内存是一直增加的，直到遇到你设置好的 anchor 时，它的内存才开始下降。当我们说 Go 并没有优化递归操作时，我们需要承认一个事实，<strong>Go 并没有尝试着去优化栈内存无限增加这一操作, Go 没有 tail calls 进行任何优化, 调用栈并没有销毁。</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 汇编:</span><br><span class="line">— prog list &quot;TailRecursive&quot; —</span><br><span class="line">0018 (.&#x2F;main.go:17) TEXT TailRecursive+0(SB),$24-24</span><br><span class="line"></span><br><span class="line">0019 (.&#x2F;main.go:17) MOVQ number+0(FP),CX</span><br><span class="line"></span><br><span class="line">0020 (.&#x2F;main.go:17) LOCALS ,$0</span><br><span class="line">0021 (.&#x2F;main.go:17) TYPE number+0(FP)&#123;int&#125;,$8</span><br><span class="line">0022 (.&#x2F;main.go:17) TYPE product+8(FP)&#123;int&#125;,$8</span><br><span class="line">0023 (.&#x2F;main.go:17) TYPE ~anon2+16(FP)&#123;int&#125;,$8</span><br><span class="line"></span><br><span class="line">0024 (.&#x2F;main.go:19) MOVQ product+8(FP),AX</span><br><span class="line">0025 (.&#x2F;main.go:19) ADDQ CX,AX</span><br><span class="line"></span><br><span class="line">0026 (.&#x2F;main.go:21) CMPQ CX,$1</span><br><span class="line">0027 (.&#x2F;main.go:21) JNE ,30</span><br><span class="line"></span><br><span class="line">0028 (.&#x2F;main.go:23) MOVQ AX,~anon2+16(FP)</span><br><span class="line">0029 (.&#x2F;main.go:23) RET ,</span><br><span class="line"></span><br><span class="line">0030 (.&#x2F;main.go:26) MOVQ CX,BX</span><br><span class="line">0031 (.&#x2F;main.go:26) DECQ ,BX</span><br><span class="line"></span><br><span class="line">0032 (.&#x2F;main.go:26) MOVQ BX,(SP)</span><br><span class="line">0033 (.&#x2F;main.go:26) MOVQ AX,8(SP) &#x2F;&#x2F; 依旧不断地把参数压栈, 并未重复利用栈返回</span><br><span class="line">0034 (.&#x2F;main.go:26) CALL ,TailRecursive+0(SB)</span><br><span class="line"></span><br><span class="line">0035 (.&#x2F;main.go:26) MOVQ 16(SP),BX</span><br><span class="line"></span><br><span class="line">0036 (.&#x2F;main.go:26) MOVQ BX,~anon2+16(FP)</span><br><span class="line">0037 (.&#x2F;main.go:26) RET ,</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过chan去模拟尾递归, 这个调用栈会被优化, 因为每个goroutine执行完就返回了, 其会被销毁.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecursiveChannel</span><span class="params">(number <span class="keyword">int</span>, product <span class="keyword">int</span>, result <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    product = product + number</span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span> &#123;</span><br><span class="line">        result &lt;- product</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Go RecursiveChannel(number<span class="number">-1</span>, product, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    RecursiveChannel(<span class="number">4</span>, <span class="number">0</span>, result)</span><br><span class="line">    answer := &lt;-result</span><br><span class="line">    fmt.Printf(<span class="string">"Recursive: %d\n"</span>, answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title>系统化思维导论读书笔记</title>
    <url>/2020/08/12/%E7%B3%BB%E7%BB%9F%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="系统化思维导论读书笔记"><a href="#系统化思维导论读书笔记" class="headerlink" title="系统化思维导论读书笔记"></a>系统化思维导论读书笔记</h1><h2 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h2><ol>
<li>科学判断的模式是: <code>如果...那么...</code> 也就是说任何事情都不能忽略其前提, 不能忽略其适用的场景. </li>
<li>认识一个新的东西的最好办法是先整体上取得宏观认识, 再拆分局部分别进行细节认识和把控. </li>
</ol>
<h2 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h2><ol>
<li>研究任务事情, 决不能试图研究它的所有情况, 简化状态有利于研究. </li>
<li>选择规律定义函数时, 根据自己的能力情况选择, 如果自己的计算能力强一点选择更多的维度, 如果自己的观察能力强一点, 选择更多的观察维度. 这个意思其实就是按照自身的能力特长来选择使用何种定义手段. </li>
</ol>
<h2 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h2><ol>
<li>对于任意给定的转换都会保持一些性质,改变一些性质.</li>
<li>想要理解变化只有观察保持不变的东西, 要理解恒久只有通过观察发生转换的东西.</li>
<li>强连接: 系统的任何一个部分不能单独的工作, 即是高耦合.</li>
</ol>
<h2 id="第6章"><a href="#第6章" class="headerlink" title="第6章"></a>第6章</h2><ol>
<li>黑盒: 理解事务的一种方法, 白箱: 即仿真.</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>计算一个数的二进制表示中1的个数算法比较</title>
    <url>/2020/09/17/%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="计算一个数的二进制表示中1的个数算法比较"><a href="#计算一个数的二进制表示中1的个数算法比较" class="headerlink" title="计算一个数的二进制表示中1的个数算法比较"></a>计算一个数的二进制表示中1的个数算法比较</h1><p>计算一个数的二进制中1的个数, 这是一个经典的面试题, 网上有各种算法. 自己面试也被问过, 没看过的只会想到循环的方法求解. 但是这个效率就不高了. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 笨办法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBitCount1</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> x &amp; (x<span class="number">-1</span>) == (x<span class="number">-1</span>) &#123;</span><br><span class="line">			res++</span><br><span class="line">		&#125;</span><br><span class="line">		x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBitCount2</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	x = x &amp; <span class="number">0x5555555555555555</span> + x &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x5555555555555555</span></span><br><span class="line">	x = x &amp; <span class="number">0x3333333333333333</span> + x &gt;&gt; <span class="number">2</span> &amp; <span class="number">0x3333333333333333</span></span><br><span class="line">	x = x &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span> + x &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span></span><br><span class="line">	x = x &amp; <span class="number">0x00ff00ff00ff00ff</span> + x &gt;&gt; <span class="number">8</span> &amp; <span class="number">0x00ff00ff00ff00ff</span></span><br><span class="line">	x = x &amp; <span class="number">0x0000ffff0000ffff</span> + x &gt;&gt; <span class="number">16</span> &amp; <span class="number">0x0000ffff0000ffff</span></span><br><span class="line">	x = x &amp; <span class="number">0x00000000ffffffff</span> + x &gt;&gt; <span class="number">32</span> &amp; <span class="number">0x00000000ffffffff</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBitCount3</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	x = x &amp; <span class="number">0x5555555555555555</span> + x &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x5555555555555555</span></span><br><span class="line">	x = x &amp; <span class="number">0x3333333333333333</span> + x &gt;&gt; <span class="number">2</span> &amp; <span class="number">0x3333333333333333</span></span><br><span class="line">	x = x &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span> + x &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span></span><br><span class="line">	x = x &gt;&gt; <span class="number">8</span></span><br><span class="line">	x = x &gt;&gt; <span class="number">16</span></span><br><span class="line">	x = x &gt;&gt; <span class="number">32</span></span><br><span class="line">	<span class="comment">// &amp; (1&lt;&lt;7 - 1) 确保1的个数不会超过64个</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(x) &amp; (<span class="number">1</span>&lt;&lt;<span class="number">7</span> - <span class="number">1</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFindBitCount</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span>&#123;</span><br><span class="line">		Num  <span class="keyword">uint64</span></span><br><span class="line">		Ept <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;Num: <span class="keyword">uint64</span>(<span class="number">0</span>), Ept: <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;Num:<span class="keyword">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span><span class="number">-1</span>), Ept:<span class="number">64</span>&#125;,</span><br><span class="line">		&#123;Num:<span class="keyword">uint64</span>(<span class="number">64</span>), Ept:<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;Num:<span class="keyword">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">32</span>), Ept:<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;Num:<span class="keyword">uint64</span>(<span class="number">167381424443</span>), Ept:<span class="number">23</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Func1 with Num:%v"</span>, c.Num), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				findBitCount1(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Func2 with Num:%v"</span>, c.Num), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				findBitCount2(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Func3 with Num:%v"</span>, c.Num), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				findBitCount3(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"OnesCount64 with Num:%v"</span>, c.Num), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				bits.OnesCount64(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: test</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func1_with_Num:0-8         	397047744	         3.07 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func2_with_Num:0-8         	1000000000	         0.634 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func3_with_Num:0-8         	1000000000	         0.587 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;OnesCount64_with_Num:0-8   	1000000000	         0.634 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func1_with_Num:18446744073709551615-8         	13153808	        91.1 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func2_with_Num:18446744073709551615-8         	1000000000	         0.588 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func3_with_Num:18446744073709551615-8         	1000000000	         0.581 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;OnesCount64_with_Num:18446744073709551615-8   	1000000000	         0.570 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func1_with_Num:64-8                           	86061858	        14.1 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func2_with_Num:64-8                           	1000000000	         0.587 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func3_with_Num:64-8                           	1000000000	         0.585 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;OnesCount64_with_Num:64-8                     	1000000000	         0.567 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func1_with_Num:4294967296-8                   	25344757	        48.3 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func2_with_Num:4294967296-8                   	1000000000	         0.575 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func3_with_Num:4294967296-8                   	1000000000	         0.610 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;OnesCount64_with_Num:4294967296-8             	1000000000	         0.569 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func1_with_Num:167381424443-8                 	16672856	        71.8 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func2_with_Num:167381424443-8                 	1000000000	         0.598 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;Func3_with_Num:167381424443-8                 	1000000000	         0.584 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkFindBitCount&#x2F;OnesCount64_with_Num:167381424443-8           	1000000000	         0.577 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok  	test	16.403s</span><br></pre></td></tr></table></figure>

<p>可见标准库还是挺快的, 其中有些代码可以省略的, 但是没有, 注释有其原因说明: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">133</span>  <span class="comment">// OnesCount64 returns the number of one bits ("population count") in x.</span></span><br><span class="line"><span class="number">134</span>  <span class="function"><span class="keyword">func</span> <span class="title">OnesCount64</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="number">135</span>  	<span class="comment">// Implementation: Parallel summing of adjacent bits.</span></span><br><span class="line"><span class="number">136</span>  	<span class="comment">// See "Hacker's Delight", Chap. 5: Counting Bits.</span></span><br><span class="line"><span class="number">137</span>  	<span class="comment">// The following pattern shows the general approach:</span></span><br><span class="line"><span class="number">138</span>  	<span class="comment">//</span></span><br><span class="line"><span class="number">139</span>  	<span class="comment">//   x = x&gt;&gt;1&amp;(m0&amp;m) + x&amp;(m0&amp;m)</span></span><br><span class="line"><span class="number">140</span>  	<span class="comment">//   x = x&gt;&gt;2&amp;(m1&amp;m) + x&amp;(m1&amp;m)</span></span><br><span class="line"><span class="number">141</span>  	<span class="comment">//   x = x&gt;&gt;4&amp;(m2&amp;m) + x&amp;(m2&amp;m)</span></span><br><span class="line"><span class="number">142</span>  	<span class="comment">//   x = x&gt;&gt;8&amp;(m3&amp;m) + x&amp;(m3&amp;m)</span></span><br><span class="line"><span class="number">143</span>  	<span class="comment">//   x = x&gt;&gt;16&amp;(m4&amp;m) + x&amp;(m4&amp;m)</span></span><br><span class="line"><span class="number">144</span>  	<span class="comment">//   x = x&gt;&gt;32&amp;(m5&amp;m) + x&amp;(m5&amp;m)</span></span><br><span class="line"><span class="number">145</span>  	<span class="comment">//   return int(x)</span></span><br><span class="line"><span class="number">146</span>  	<span class="comment">//</span></span><br><span class="line"><span class="number">147</span>  	<span class="comment">// Masking (&amp; operations) can be left away when there's no</span></span><br><span class="line"><span class="number">148</span>  	<span class="comment">// danger that a field's sum will carry over into the next</span></span><br><span class="line"><span class="number">149</span>  	<span class="comment">// field: Since the result cannot be &gt; 64, 8 bits is enough</span></span><br><span class="line"><span class="number">150</span>  	<span class="comment">// and we can ignore the masks for the shifts by 8 and up.</span></span><br><span class="line"><span class="number">151</span>  	<span class="comment">// Per "Hacker's Delight", the first line can be simplified</span></span><br><span class="line"><span class="number">152</span>  	<span class="comment">// more, but it saves at best one instruction, so we leave</span></span><br><span class="line"><span class="number">153</span>  	<span class="comment">// it alone for clarity.</span></span><br><span class="line"><span class="number">154</span>  	<span class="keyword">const</span> m = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line"><span class="number">155</span>  	x = x&gt;&gt;<span class="number">1</span>&amp;(m0&amp;m) + x&amp;(m0&amp;m)</span><br><span class="line"><span class="number">156</span>  	x = x&gt;&gt;<span class="number">2</span>&amp;(m1&amp;m) + x&amp;(m1&amp;m)</span><br><span class="line"><span class="number">157</span>  	x = (x&gt;&gt;<span class="number">4</span> + x) &amp; (m2 &amp; m)</span><br><span class="line"><span class="number">158</span>  	x += x &gt;&gt; <span class="number">8</span></span><br><span class="line"><span class="number">159</span>  	x += x &gt;&gt; <span class="number">16</span></span><br><span class="line"><span class="number">160</span>  	x += x &gt;&gt; <span class="number">32</span></span><br><span class="line"><span class="number">161</span>  	<span class="keyword">return</span> <span class="keyword">int</span>(x) &amp; (<span class="number">1</span>&lt;&lt;<span class="number">7</span> - <span class="number">1</span>)</span><br><span class="line"><span class="number">162</span>  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>随机抽样/洗牌算法--Knuth-Durstenfeld Shuffle &amp;&amp; 蓄水池算法</title>
    <url>/2020/09/14/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95--Knuth-Durstenfeld%20Shuffle%20&amp;&amp;%20%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="随机抽样-洗牌算法–Knuth-Durstenfeld-Shuffle-amp-amp-蓄水池算法"><a href="#随机抽样-洗牌算法–Knuth-Durstenfeld-Shuffle-amp-amp-蓄水池算法" class="headerlink" title="随机抽样/洗牌算法–Knuth-Durstenfeld Shuffle &amp;&amp; 蓄水池算法"></a>随机抽样/洗牌算法–Knuth-Durstenfeld Shuffle &amp;&amp; 蓄水池算法</h2><p>洗牌算法有很多种, 蓄水池算法则是适合大量数据场景或者数据流下的等概率抽样</p>
<h2 id="一种洗牌算法-Knuth-Durstenfeld-Shuffle"><a href="#一种洗牌算法-Knuth-Durstenfeld-Shuffle" class="headerlink" title="一种洗牌算法 Knuth-Durstenfeld Shuffle :"></a>一种洗牌算法 Knuth-Durstenfeld Shuffle :</h2><p><strong>对于一个已知长度n的数组, 可以从数组结尾的位置开始, 每次随机一个[0,i)范围(数组下标从0开始到n-1结束)内的随机数x, i为当前数据在数组中的下标,交换i位置和x位置的数据, 然后i-1并继续重复之前的过程直到到达数组的头部即下标为0的位置以后结束循环.</strong></p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h4><p>设P(n) 为位置n放入i号数据的概率<br>第n位置的概率是 1/n<br>第n-1位置的概率是 1/(n-1) * (1 - P(n)) = 1/(n-1) * (1- 1/n) = 1/n<br>第n-k位置的概率是 1/(n-k) * (1- P(n))(1- P(n-1)) … (1 - P(n-k+1))= 1/n </p>
<p>算法复杂度: O(n) 空间复杂度 O(1)<br>缺点: 需要事先知道确定的数据长度. 如果数据很长或者是个接近无限的数据流,计算一次数据的长度很耗时/遍历一遍所有数据(数据量大到内存放不下, 只能流式读取), </p>
<p>在这种限定下 : 给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。 这种情况就需要使用蓄水池算法.</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原地随机</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(data []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	l:= <span class="built_in">len</span>(data)</span><br><span class="line">	<span class="keyword">var</span> rnd <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n *big.Int</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> i:=l<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">		n, err = rand.Int(rand.Reader,big.NewInt(<span class="keyword">int64</span>(i)))</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		rnd = <span class="keyword">int</span>(n.Int64())</span><br><span class="line">		data[i], data[rnd] = data[rnd], data[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不改变原数据 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffleCopy</span><span class="params">(data []<span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line">	l:= <span class="built_in">len</span>(data)</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,l)</span><br><span class="line">	<span class="built_in">copy</span>(res,data)</span><br><span class="line">	<span class="keyword">var</span> rnd <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n *big.Int</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> i:=l<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">		n, err = rand.Int(rand.Reader,big.NewInt(<span class="keyword">int64</span>(i)))</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		rnd = <span class="keyword">int</span>(n.Int64())</span><br><span class="line">		res[i], res[rnd] = res[rnd], res[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h2><p>算法思路如下：</p>
<ol>
<li>准备: 创建一个m大小的数据池, 当作蓄水池. 通过i对已经处理的数据进行计数</li>
<li>如果接收的数据量小于m，则依次放入蓄水池。(先将前m个数据放入其中)</li>
<li>当接收到第i个数据时，i &gt;= m，在[0, i]范围内取以随机数d，若d的落在[0, m-1]范围内，则用接收到的第i个数据替换蓄水池中的第d个数据。(当池子满了, 就在当前计数范围内随机一个数字d, 如果小于池子的容量, 就用数据i替换池子中编号d对应的数据)</li>
<li>重复步骤3, 直到遍历完所有数据N。</li>
</ol>
<p>当处理完所有的数据时，蓄水池中的<strong>每个数据都是以m/N的概率获得</strong>的。这个算法不需要事先获知N的大小. </p>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明:"></a>证明:</h4><p>抄自:  <a href="https://www.jianshu.com/p/7a9ea6ece2af" target="_blank" rel="noopener">https://www.jianshu.com/p/7a9ea6ece2af</a><br>假设数据开始编号为1.第i个接收到的数据最后能够留在蓄水池中的概率=第i个数据进入过蓄水池的概率*之后第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。</p>
<ol>
<li>当i&lt;=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。</li>
<li>当i&gt;m时，在[1,i]内选取随机数d，如果d&lt;=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。</li>
<li>当i&lt;=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))<em>(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)…第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据不被替换的概率=m/(m+1)</em>(m+1)/(m+2)<em>…</em>(N-1)/N=m/N。</li>
<li>当i&gt;m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。</li>
<li>结合第1点和第3点可知，当i&lt;=m时，第i个接收到的数据最后留在蓄水池中的概率=1<em>m/N=m/N。结合第2点和第4点可知，当i&gt;m时，第i个接收到的数据留在蓄水池中的概率=m/i</em>i/N=m/N。</li>
</ol>
<p>综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现:"></a>实现:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waterPoolSample</span><span class="params">(data []<span class="keyword">interface</span>&#123;&#125;, count <span class="keyword">int</span>)</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; count &#123;</span><br><span class="line">      count = <span class="built_in">len</span>(data)</span><br><span class="line">  &#125;</span><br><span class="line">	pool := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;,count)</span><br><span class="line">	<span class="built_in">copy</span>(pool, data)</span><br><span class="line">	<span class="keyword">var</span> rnd <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n *big.Int</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> i := count; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">		n, err = rand.Int(rand.Reader,big.NewInt(<span class="keyword">int64</span>(i)))</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		rnd = <span class="keyword">int</span>(n.Int64())</span><br><span class="line">		<span class="keyword">if</span> rnd &gt;= count &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		pool[rnd] = data[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式蓄水池"><a href="#分布式蓄水池" class="headerlink" title="分布式蓄水池:"></a>分布式蓄水池:</h2><p>参考 <a href="https://www.jianshu.com/p/7a9ea6ece2af" target="_blank" rel="noopener">https://www.jianshu.com/p/7a9ea6ece2af</a></p>
<p>如果需要抽出m个数据</p>
<ol>
<li>假设有K台机器，将大数据集分成K个数据流，每台机器使用单机版蓄水池抽样处理一个数据流，抽样m个数据，并最后记录处理的数据量为N1, N2, …, Nk, …, NK(假设m&lt;Nk)。N1+N2+…+NK=N。(首先对子数据集Nk执行蓄水池抽样算法, K个执行节点就K个水池, 这样总共抽出m*k个数据)</li>
<li>取[1, N]一个随机数d(N由第一步中计算得来)，若d&lt;N1，则在第一台机器的蓄水池中等概率不放回地（1/m）选取一个数据；若N1&lt;=d&lt;(N1+N2)，则在第二台机器的蓄水池中等概率不放回地选取一个数据；一次类推，重复m次，则最终从N大数据集中选出m个数据。(在最终的m*k个数据中随机抽取m个数据)</li>
</ol>
<p>第2步m/N的概率验证如下：</p>
<ol>
<li>第k台机器中的蓄水池数据被选取的概率为m/(Nk)。</li>
<li>从第k台机器的蓄水池中选取一个数据放进最终蓄水池的概率为Nk/N。</li>
<li>第k台机器蓄水池的一个数据被选中的概率为1/m。（不放回选取时等概率的）</li>
<li>重复m次选取，则每个数据被选中的概率为m<em>(m/Nk</em>Nk/N*1/m)=m/N。</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>go 语言设计与实现 学习笔记</title>
    <url>/2020/09/12/go%20%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="go-语言设计与实现-学习笔记"><a href="#go-语言设计与实现-学习笔记" class="headerlink" title="go 语言设计与实现 学习笔记"></a>go 语言设计与实现 学习笔记</h1><p><a href="https://draveness.me/golang/" target="_blank" rel="noopener">https://draveness.me/golang/</a></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>go的编译过程包括了: 词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成 四个部分.  在类型检查阶段对make进行改写替换成实际底层对应的slice、map、chan创建方法. 中间代码从AST到SSA的过程中进行了几十次迭代优化, 执行50多个过程. </p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>如果数组中元素的个数小于或者等于4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上</strong>，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件.  -&gt; 可能的原因是为了优化编译时间, 在静态区创建后就不用再次设置值, 而直接在栈上创建会需要再设置一次初始值.</p>
<p>无论是在栈上还是静态存储区，数组在内存中其实就是一连串的内存空间，表示数组的方法就是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型占的空间大小，如果我们不知道数组中元素的数量，访问时就可能发生越界，而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，如果没有这些信息，我们就无法知道这片连续的内存空间到底存储了什么数据.</p>
<p>Go 语言对于数组的访问还是有着比较多的检查的，它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用<code>panicIndex</code>，而在运行期间这些插入的函数会负责保证不会发生越界错误。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片内元素的类型是在编译期间确定的，编译器确定了类型之后，会将类型存储在 Extra 字段中帮助程序在运行时动态获取</p>
<p>编译期间的切片是 Slice 类型的，但是在运行时切片由如下的 SliceHeader 结构体表示，其中 Data 字段是指向数组的指针，Len 表示当前切片的长度，而 Cap 表示当前切片的容量，也就是 Data 数组的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片可以理解为一个对数组的抽象层. </p>
<p>Go 语言中的切片有三种初始化的方式：</p>
<ol>
<li>通过下标的方式获得数组或者切片的一部分；是最原始也最接近汇编语言的方式. 如 arr[0:3], 其直接创建slice的结构体, 并设置<code>data, len, cap</code>数值.</li>
<li>使用字面量初始化新的切片；首先创建底层数组并赋值每个值, 其后创建一个指针指向静态存储中的该数组, 最后通过<code>[:]</code>获得切片结构, 可见<code>[:]</code>是创建切片的最底层方法之一.</li>
<li>使用关键字 make 创建切片, 很多工作都需要运行时的参与, 编译器在类型检查时保证传入的容量 cap 一定大于或者等于 len. 当切片发生逃逸或者非常大时，我们需要 runtime.makeslice 函数在堆上初始化. 如果当前的切片不会发生逃逸并且切片非常小的时候，如<code>make([]int, 3, 4)</code>会被直接转换成如下所示的代码：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">n := arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
makeslice会最后调用mallocgc, 其是用于申请内存的函数，这个函数的实现还是比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，<em>而大于 32KB 的一些对象会在堆上初始化</em>.</li>
</ol>
<p>因为大多数对切片类型的操作并不需要直接操作原 slice 结构体，所以 SliceHeader 的引入能够减少切片初始化时的少量开销，这个改动能够减少 约0.2% 的 Go 语言包大小并且能够减少 92 个 panicindex 的调用，占整个 Go 语言二进制的 3.5%.</p>
<p>len 和 cap 被 Go 语言的编译器看成是两种特殊的操作，即 OLEN 和 OCAP，它们会在 SSA 生成阶段被 <code>cmd/compile/internal/gc.epxr</code> 函数转换成 OpSliceLen 和 OpSliceCap 操作</p>
<h4 id="range遍历优化"><a href="#range遍历优化" class="headerlink" title="range遍历优化"></a>range遍历优化</h4><p>使用 range 遍历切片时也会在编译期间转换成形式更简单的代码. 编译器会在编译期间将所有 for/range 循环变成经典的for循环.对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新的变量 ha，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量了。而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，在赋值时也发生了拷贝. </p>
<h4 id="go中append操作会根据是否覆盖原变量的情况进行代码优化"><a href="#go中append操作会根据是否覆盖原变量的情况进行代码优化" class="headerlink" title="go中append操作会根据是否覆盖原变量的情况进行代码优化:"></a>go中append操作会根据是否覆盖原变量的情况进行代码优化:</h4><p>不覆盖:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// append(slice, 1, 2, 3)</span></span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> newlen &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> = growslice(slice, newlen)</span><br><span class="line">    newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line"><span class="keyword">return</span> makeslice(ptr, newlen, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice = append(slice, 1, 2, 3)</span></span><br><span class="line">a := &amp;slice</span><br><span class="line">ptr, <span class="built_in">len</span>, <span class="built_in">cap</span> := slice</span><br><span class="line">newlen := <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint</span>(newlen) &gt; <span class="keyword">uint</span>(<span class="built_in">cap</span>) &#123;</span><br><span class="line">   newptr, <span class="built_in">len</span>, newcap = growslice(slice, newlen)</span><br><span class="line">   vardef(a)</span><br><span class="line">   *a.<span class="built_in">cap</span> = newcap</span><br><span class="line">   *a.ptr = newptr</span><br><span class="line">&#125;</span><br><span class="line">newlen = <span class="built_in">len</span> + <span class="number">3</span></span><br><span class="line">*a.<span class="built_in">len</span> = newlen</span><br><span class="line">*(ptr+<span class="built_in">len</span>) = <span class="number">1</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">*(ptr+<span class="built_in">len</span>+<span class="number">2</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>主要优化就是对于不覆盖的场景返回一个新的slice结构, 对于覆盖的场景就直接修改原来的slice结构中cap len data的值. 这样就不需要创建一个新的结构体了. </p>
<p><code>growslice</code> 方法负责在cap不够新的len时进行扩容:</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">				newcap += newcap / <span class="number">4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = <span class="built_in">cap</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 确定了切片的容量之后，就可以计算切片中新数组占用的内存了，计算的方法就是将目标容量和元素大小相乘，计算新容量时可能会发生溢出或者请求的内存超过上限，在这时就会直接 panic</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 最终会返回一个新的 slice 结构</span></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果切片中元素不是指针类型，那么就会调用 <code>memclrNoHeapPointers</code> 将超出切片当前长度的位置清空并在最后使用 <code>memmove</code> 将原数组内存中的内容拷贝到新申请的内存中. memclrNoHeapPointers 和 memmove 都是用目标机器上的汇编指令实现的.</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy(a, b) 的形式对切片进行拷贝时，编译期间的 cmd/compile/internal/gc.copyany 函数也会分两种情况进行处理，如果当前 copy 不是在运行时调用的，copy(a, b) 会被直接转换成下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> memmove 会负责对内存进行拷贝，在其他情况下，编译器会使用 runtime.slicecopy 函数替换运行期间调用的 copy. </p>
<p><code>memmove</code> 是将整块内存中的内容拷贝到目标的内存区域, 这也就是为什么copy的dest需要指定和source一样或者更大的cap, 如果dest没有初始化足够的cap, 那么拷贝只会将两者容量中最小的容量的数据进行拷贝, 这就产生了时常忽略的错误. </p>
<p>哪怕使用 <code>memmove</code>对内存成块进行拷贝，但是这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><p>如果slice的底层cap容量是够用的, 创建新的slice进行append后再对原slice进行append,会覆盖前一次append的值. 执行如下代码会发现,b的底层数据被覆盖成了4而不是3.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">b := <span class="built_in">append</span>(a, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>) </span><br><span class="line"><span class="built_in">println</span>(b[<span class="number">4</span>]) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="哈希表-map"><a href="#哈希表-map" class="headerlink" title="哈希表 map"></a>哈希表 map</h2><p>哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法.</p>
<p>开放寻址法核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果我们使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组. 当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个不为空的位置.</p>
<p>当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n) 的，它们可能需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>实现拉链法一般会使用数组加上链表, 有一些语言会在拉链法的哈希中引入红黑树以优化性能, 它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间. </p>
<p>哈希函数返回的哈希会帮助我们选择一个桶(链表)，和开放地址法一样，选择桶的方式就是直接对哈希返回的结果取模. 在遍历链表的过程中会遇到以下两种情况：</p>
<ol>
<li>找到键相同的键值对 —— 更新键对应的值；</li>
<li>没有找到键相同的键值对 —— 在链表的末尾追加新键值对</li>
</ol>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0-1 个元素，有时会有 2-3 个. 其装载因子 := 元素数量 / 桶数量</p>
<p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大(常见java 0.75?)时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降</p>
<p>go中使用<code>hmap</code>存储哈希, 其中<code>B</code>字段表示当前哈希表持有的 buckets 数量,<strong>B最大为256</strong>，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 <code>len(buckets) == 2^B</code>; hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入.</p>
<p><strong>B的uint8类型，最大为255。所以最大有2^255个桶，每个桶可装8个kv，还有额外的溢出桶最大容量在4.63x10^77以上.</strong> </p>
<p>哈希表 <code>hmap</code> 的桶就是 <code>bmap</code>, <strong>每一个 bmap 都能存储 8 个键值</strong>对，当哈希表中存储的数据过多，单个桶无法装满时就会使用 <code>extra.overflow</code> 中桶存储溢出的数据, 这两者分别叫做正常桶和溢出桶.<br>溢出桶能减少扩容的频率. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bmap 结构体其实不止包含 tophash 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// tophash 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能</span></span><br><span class="line">	tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	<span class="comment">// 以下都是隐藏字段</span></span><br><span class="line">	  keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>通过<a href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L768-L873" target="_blank" rel="noopener">gc.maplit</a>  初始化哈希. </p>
<p>例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"1"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">"3"</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="string">"5"</span>: <span class="number">6</span>,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当哈希表中的元素数量少于或者等于 25 个时，编译器会直接调用 <code>addMapEntries</code> 将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">hash[<span class="string">"1"</span>] = <span class="number">2</span></span><br><span class="line">hash[<span class="string">"3"</span>] = <span class="number">4</span></span><br><span class="line">hash[<span class="string">"5"</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>一旦<strong>哈希表中元素的数量超过了 25 个，就会在编译期间创建两个数组分别存储键和值的信息</strong>,两个切片 vstatk 和 vstatv 还会被编辑器继续展开，这些键值对会通过一个如下所示的 for 循环加入目标的哈希：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">vstatk := []<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, ... ， <span class="string">"26"</span>&#125;</span><br><span class="line">vstatv := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ... , <span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(vstak); i++ &#123;</span><br><span class="line">    hash[vstatk[i]] = vstatv[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言编译器都会在类型检查期间将make转换成对 <a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L303-L336" target="_blank" rel="noopener">runtime.makemap</a> 的调用</p>
<p>这个函数的执行过程会分成以下几个部分：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用 fastrand 获取一个随机的哈希种子；</li>
<li>根据传入的 hint 计算出需要的最小需要的桶的数量；</li>
<li>使用 runtime.makeBucketArray 创建用于保存桶的数组；<a href="https://github.com/golang/go/blob/dcd3b2c173b77d93be1c391e3b5f932e0779fb1f/src/runtime/map.go#L344-L387" target="_blank" rel="noopener">runtime.makeBucketArray</a> 函数会根据传入的 B 计算出的需要创建的桶数量在内存中分配一片连续的空间用于存储数据. </li>
</ol>
<p><strong>当桶的数量小于 16(2^4) 时，由于数据较少、使用溢出桶的可能性较低，这时就会省略创建溢出桶的过程以减少额外开销；当桶的数量多于 16(2^4) 时，就会额外创建 2^(B−4) 个溢出桶</strong>，根据上述代码，我们能确定在正常情况下，<strong>正常桶和溢出桶在内存中的存储空间是连续的</strong>，只是被 hmap 中的不同字段引用，当溢出桶数量较多时会通过 runtime.newobject 创建新的溢出桶</p>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>对map的访问会根据是否进行存在判断,执行mapaccess1和mapaccess2(判断key存在: v, ok := hash[key]形式)<br><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L394-L450" target="_blank" rel="noopener">runtime.mapaccess1</a> 函数会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 bucketMask 和 add 函数拿到该键值对所在的桶序号和哈希最上面的 8 位数字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">				<span class="keyword">return</span> v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 bucketloop 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它会比较这 8 位数字和桶中存储的 tophash，每一个桶都存储键对应的 tophash，每一次读写操作都会与桶中所有的 tophash 进行比较，<strong>用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 tophash 的概率(相邻的数据哈希的高位可能很接近或相等, 通过低位选桶可以避免其被分到同一个桶的概率, 这样在同一个桶中使用高8位进行访问加速就很少出现top==tophash[i]的可能, 这样就减少了去取得存储的数据与key进行比较的次数, 因为key可以很长很大, 直接进行比较会很消耗性能, 通过高8位的比较可以加速比较速度)</strong>。当发现桶中的 tophash 与传入键的 tophash 匹配之后，我们会通过指针和偏移量获取哈希中存储的键 keys[0] 并与 key 比较，如果两者相同就会获取目标值的指针 values[0] 并返回.  runtime.mapaccess2 只是在 runtime.mapaccess1 的基础上多返回了一个标识键值对是否存在的布尔值.</p>
<p><strong>与数组一样，哈希表可能会在装载因子过高或者溢出桶过多时进行扩容，哈希表的扩容并不是一个原子的过程. 这时并发读写就可能产生问题. 需要进行临界区访问控制.</strong> </p>
<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>依次遍历正常桶和溢出桶中存储的数据，依次执行:判断 tophash 是否相等、key 是否相等的过程，遍历结束后会从循环中跳出.</p>
<p>如果当前桶已经满了，哈希会调用 newoverflow 函数创建新桶或者使用 hmap 预先在 noverflow(溢出桶) 中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 noverflow 计数器.</p>
<p>如果当前键值对在哈希中不存在，哈希为新键值对规划存储的内存地址，通过 typedmemmove 将键移动到对应的内存空间中并返回键对应值的地址 val，如果当前键值对在哈希中存在，那么就会直接返回目标区域的内存地址。哈希并不会在 mapassign 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，真正的赋值操作是在编译期间插入的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">00018</span> (+<span class="number">5</span>) CALL runtime.mapassign_fast64(SB)</span><br><span class="line"><span class="number">00020</span> (<span class="number">5</span>) MOVQ <span class="number">24</span>(SP), DI               ;; DI = &amp;value</span><br><span class="line"><span class="number">00026</span> (<span class="number">5</span>) LEAQ <span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">"88"</span>(SB), AX   ;; AX = &amp;<span class="string">"88"</span></span><br><span class="line"><span class="number">00027</span> (<span class="number">5</span>) MOVQ AX, (DI)                 ;; *DI = AX</span><br></pre></td></tr></table></figure>
<p>runtime.mapassign_fast64 与 runtime.mapassign 函数的实现差不多，我们需要关注的是后面的三行代码，24(SP) 就是该函数返回的值地址，我们通过 LEAQ 指令将字符串的地址存储到寄存器 AX 中，MOVQ 指令将字符串 “88” 存储到了目标地址上完成了这次哈希的写入</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p><a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L571-L683" target="_blank" rel="noopener">runtime.mapassign</a> 函数会在以下两种情况发生时触发哈希的扩容：</p>
<ol>
<li><strong>装载因子已经超过 6.5；</strong> 进行翻倍扩容. </li>
<li><strong>哈希使用了太多溢出桶；</strong> 进行等量扩容. 一旦哈希中出现了过多的溢出桶，它就会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存. 产生场景: <em>当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏</em></li>
</ol>
<p>扩容不是一个原子的过程，所以 runtime.mapassign 函数还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱.</p>
<p>扩容会使用<a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1128-L1240" target="_blank" rel="noopener">runtime.evacuate </a> 将一个旧桶中的数据分流到两个新桶. 等量扩容只会有一个. </p>
<p>当哈希表正在处于扩容状态时，每次向哈希表写入值时都会触发 runtime.growWork 对哈希表的内容进行增量拷贝</p>
<p>总结: <strong>哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，整个扩容过程并不是原子的，而是通过 runtime.growWork 增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流；除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 sameSizeGrow 这一机制，在出现较多溢出桶时会对哈希进行『内存整理』减少对空间的占用</strong></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>在编译期间，delete 关键字会被转换成操作为 ODELETE 的节点，而 ODELETE 会被 cmd/compile/internal/gc.walkexpr 转换成 mapdelete 函数簇中的一个，包括 mapdelete、mapdelete_faststr、mapdelete_fast32 和 mapdelete_fast64</p>
<p>哈希表的删除逻辑与写入逻辑非常相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会对即将操作的桶进行分流，分流结束之后会找到桶中的目标元素完成键值对的删除工作</p>
<p>mapextra中overflow和oldoverflow, 是方便 gc 的，若 key 和 value 都不是指针，则 gc 不需要遍历 buckets，但这会导致 overflow 被回收，为了避免这种情况，在外层保存了 overflow. bucket中的overflow是 uintptr类型，不会被gc标记，在清扫时就被当成白色对象回收了</p>
<h4 id="函数传参值传递对于slice、map、chan的解释"><a href="#函数传参值传递对于slice、map、chan的解释" class="headerlink" title="函数传参值传递对于slice、map、chan的解释"></a>函数传参值传递对于slice、map、chan的解释</h4><p>map、channel这两种类型的值其实是指向runtime.hmap与runtime.hchan的指针。</p>
<p>而slice类型就是runtime.sliceHeader类型。</p>
<p>所以传递slice，因为值传递，所以拷贝了另一个runtime.sliceHeader作为形参；若函数内对slice做了修改需要返回；</p>
<p>而传递map，仍然是值传递，但map的值就是指向runtime.hmap的地址，所以函数内做了修改不需要返回就能生效.</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go 语言中的字符串其实是一个只读的字节数组, 在运行时我们其实还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 []byte 之后就可以进行</p>
<p>每一个字符串在运行时都会使用如下的 StringHeader 结构体表示，在运行时包的内部其实有一个私有的结构 stringHeader，它有着完全相同的结构只是用于存储数据的 Data 字段使用了 unsafe.Pointer 类型. 其结构和silce很像, 缺少了cap, 因为是不可变的.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 语言中，有两种字面量方式可以声明一个字符串，一种是使用双引号，另一种是使用反引号</p>
<p>go的+号拼接字符串时: 如果需要拼接的字符串小于或者等于 5 个，那么就会直接调用 concatstring{2,3,4,5} 等一系列函数，如果超过 5 个就会直接选择 runtime.concatstrings 传入一个数组切片.参见<a href="https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2528-L2586" target="_blank" rel="noopener">cmd/compile/internal/gc.addstr </a> 最终调用<a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L23-L55" target="_blank" rel="noopener">concatstrings</a> 对传入的切片参数进行遍历，先过滤空字符串并计算拼接后字符串的长度, 如果非空字符串的数量为 1 并且当前的字符串不在栈上就可以直接返回该字符串，不需要进行额外的任何操作。在正常情况下，运行时会调用 copy 将输入的多个字符串拷贝到目标字符串所在的内存空间中，新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的</p>
<h4 id="byte与string互转"><a href="#byte与string互转" class="headerlink" title="[]byte与string互转"></a>[]byte与string互转</h4><p>[]byte转string, 会根据传入的缓冲区大小决定是否需要为新的字符串分配一片内存空间，<a href="https://github.com/golang/go/blob/8174f7fb2b64c221f7f80c9f7fd4d7eb317ac8bb/src/runtime/string.go#L229-L231" target="_blank" rel="noopener">runtime.stringStructOf</a> 会将传入的字符串指针转换成 stringStruct 结构体指针，然后设置结构体持有的字符串指针 str 和长度 len，最后通过 memmove 将原 []byte 中的字节全部复制到新的内存空间中。</p>
<p>string转[]byte时, 会使用传入的缓冲区写入,没有传入则会创建一个缓冲区. 之后调用copy将数据拷贝进新的[]byte中. 所以<strong>string与[]byte的互相转化是会因为数据长度的增加而增加性能开销的.</strong>  </p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h4 id="C与GO语言参数和返回值"><a href="#C与GO语言参数和返回值" class="headerlink" title="C与GO语言参数和返回值"></a>C与GO语言参数和返回值</h4><p>当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：</p>
<ol>
<li>六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；</li>
<li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；</li>
</ol>
<p>而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p>
<p>go编译汇编: <code>go tool compile -S -N -l main.go</code> 如果编译时不使用 -N -l 参数，编译器会对汇编代码进行优化</p>
<p>Go 语言使用栈传递参数和接收返回值.</p>
<p><strong>C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。</strong><br>对比一下这两种设计的优点和缺点：</p>
<ol>
<li>C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；</li>
</ol>
<ul>
<li>CPU 访问栈的开销比访问寄存器高几十倍3；</li>
<li>需要单独处理函数参数过多的情况；</li>
</ul>
<ol start="2">
<li>Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；</li>
</ol>
<ul>
<li>不需要考虑超过寄存器数量的参数应该如何传递；</li>
<li>不需要考虑不同架构上的寄存器差异；</li>
<li>函数入参和出参的内存空间需要在栈上进行分配；</li>
</ul>
<p>Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。</p>
<p><strong>Go 语言参数传递选择了传值的方式，无论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝</strong></p>
<ul>
<li>传递结构体时：会对结构体中的全部内容进行拷贝；</li>
<li>传递结构体指针时：会对结构体指针进行拷贝；</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Go 语言中有两种略微不同的接口，一种是带有一组方法的接口(用iface表示)，另一种是不带任何方法的 interface{}(用eface结构表示).</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes</span></span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 bytes</span></span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_type 是 Go 语言类型的运行时表示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="keyword">uintptr</span> <span class="comment">//size 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</span></span><br><span class="line">	ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">	hash       <span class="keyword">uint32</span> <span class="comment">// hash 字段能够帮助我们快速确定类型是否相等；</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="keyword">uint8</span></span><br><span class="line">	fieldAlign <span class="keyword">uint8</span></span><br><span class="line">	kind       <span class="keyword">uint8</span></span><br><span class="line">	equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span> // <span class="title">equal</span> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 <span class="title">Go</span> 语言二进制包大小从 <span class="title">typeAlg</span> 结构体中迁移过来的</span></span><br><span class="line">	gcdata     *<span class="keyword">byte</span></span><br><span class="line">	str        nameOff</span><br><span class="line">	ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>itab 结构体是接口类型的核心组成部分，每一个 itab 都占 32 字节的空间，我们可以将其看成接口类型和具体类型的组合，它们分别用 inter 和 _type 两个字段表示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 32 bytes</span></span><br><span class="line">	inter *interfacetype</span><br><span class="line">	_type *_type </span><br><span class="line">	hash  <span class="keyword">uint32</span> <span class="comment">// hash 是对 _type.hash 的拷贝，当我们想将 interface 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 _type 是否一致；</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// fun 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 fun 数组中保存的元素数量是不确定的；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>//go:noinline</code>可以用于禁止内联编译</p>
<p>go的四种接口和方法对象组合中<code>只有使用指针实现接口，使用结构体初始化变量</code>无法通过编译.</p>
<p>Go 语言的接口类型不是任意类型. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NilOrNot</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *TestStruct</span><br><span class="line">	fmt.Println(s == <span class="literal">nil</span>)      <span class="comment">// #=&gt; true</span></span><br><span class="line">	fmt.Println(NilOrNot(s))   <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 NilOrNot 函数时发生了隐式的类型转换，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，*TestStruct 类型会转换成 interface&#123;&#125; 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 TestStruct，所以转换后的变量与 nil 不相等</span></span><br></pre></td></tr></table></figure>

<p><em>go在进行类型断言的时候通过hash值比较进行类型判断</em>.</p>
<p>动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是一种在面向对象语言中常见的特性. 如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现.</p>
<p>在关闭编译器优化的情况下，动态派发生成的指令会带来 ~18% 左右的额外性能开销。开启编译器优化后，动态派发的额外开销会降低至 约5%. 与使用接口带来的好处相比，动态派发的额外开销往往可以忽略.</p>
<p>使用结构体来实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口. 动态派发的过程只是放大了参数拷贝带来的影响</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>reflect.TypeOf 能获取类型信息，reflect.ValueOf 能获取数据的运行时表示, 类型 Type 是反射包定义的一个接口, MethodByName 可以获取当前类型对应方法的引用、Implements 可以判断当前类型是否实现了某个接口, 反射包中 Value 被声明成了结构体</p>
<p>Go 语言反射的三大法则3，其中包括：</p>
<ol>
<li>从 interface{} 变量可以反射出反射对象； interface{} -&gt; 反射对象</li>
<li>从反射对象可以获取 interface} 变量； 反射对象 -&gt; interface{} , 想换成原始类型还得显式转换.</li>
<li>要修改反射对象，其值必须可设置；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := reflect.ValueOf(i)</span><br><span class="line">	v.SetInt(<span class="number">10</span>) <span class="comment">// 此处panic</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// panic: reflect: reflect.flag.mustBeAssignable using unaddressable value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := reflect.ValueOf(&amp;i)</span><br><span class="line">	v.Elem().SetInt(<span class="number">10</span>) <span class="comment">// 想要修改反射对象的值就得先获取指针.</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>go中const变量是无法获取到地址的. 就无法通过以上反射修改其值.</p>
<p>reflect.TypeOf 函数的实现原理其实并不复杂，它只是将一个 interface{} 变量转换成了内部的 emptyInterface 表示，然后从中获取相应的类型信息.</p>
<p>当我们想要将一个变量转换成反射对象时，Go 语言会在编译期间完成类型转换的工作，将变量的类型和值转换成了 interface{} 并等待运行期间使用 reflect 包获取接口中存储的信息。</p>
<p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口. </p>
<p>由于方法都是按照字母序存储的，reflect.implements 会维护两个用于遍历接口和类型方法的索引 i 和 j 判断类型是否实现了接口，因为最多只会进行 n 次比较（类型的方法数量），所以整个过程的时间复杂度是 O(n).</p>
<p>当我们想要在 Go 语言中清空一个切片或者哈希表时，我们一般都会使用以下的方法将切片中的元素置零，但是依次去遍历切片和哈希表看起来是非常耗费性能的事, 实际上编译器会直接使用<a href="https://github.com/golang/go/blob/05c02444eb2d8b8d3ecd949c4308d8e2323ae087/src/runtime/memclr_386.s#L12-L16" target="_blank" rel="noopener">runtime.memclrNoHeapPointers</a> 清空切片中的数据,生成的代码会经过编译器优化.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		arr[i] = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 优化后: 因为是连续空间, 所以直接清空一片空间.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="number">0</span> &#123;</span><br><span class="line">    	hp = &amp;a[<span class="number">0</span>]</span><br><span class="line">    	hn = <span class="built_in">len</span>(a)*sizeof(elem(a))</span><br><span class="line">    	memclrNoHeapPointers(hp, hn)</span><br><span class="line">    	i = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-和-range"><a href="#for-和-range" class="headerlink" title="for 和 range"></a>for 和 range</h2><p>循环同时使用 for 和 range 两个关键字，编译器会在编译期间将所有 for/range 循环变成的经典循环.</p>
<p>遍历哈希表时会使用 runtime.mapiterinit 函数初始化遍历开始的元素.Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以<strong>引入了随机数保证遍历的随机性</strong>, Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性.</p>
<p>从桶中找到下一个遍历的元素时在大多数情况下都会直接操作内存获取目标键值的内存地址，不过如果哈希表处于扩容期间就会调用 <a href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L511-L552" target="_blank" rel="noopener">runtime.mapaccessK</a> 函数获取键值对. 遍历完正常桶后会依次遍历溢出桶.</p>
<p>字符串遍历时会将其转为rune类型. </p>
<p>形如 for v := range ch {} 的语句最终会被转换成如下的格式:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ha := a</span><br><span class="line">hv1, hb := &lt;-ha</span><br><span class="line"><span class="keyword">for</span> ; hb != <span class="literal">false</span>; hv1, hb = &lt;-ha &#123;</span><br><span class="line">    v1 := hv1</span><br><span class="line">    hv1 = <span class="literal">nil</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该循环会使用 &lt;-ch 从管道中取出等待处理的值，这个操作会调用 runtime.chanrecv2 并阻塞当前的协程，当 runtime.chanrecv2 返回时<em>会根据布尔值 hb 判断当前的值是否存在，如果不存在就意味着当前的管道已经被关闭了</em>，如果存在就会为 v1 赋值并清除 hv1 变量中的数据，然后会重新陷入阻塞等待新数据</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>在多个文件或者 Channel 发生状态改变之前，select 会一直阻塞当前线程或者 Goroutine.</p>
<ol>
<li>select 能在 Channel 上进行非阻塞的收发操作；如果存在default,则会在不存在可以收发的channel后, 执行default,default可以不阻塞goroutine. 当存在可以收发的channel时会处理该channel的case.</li>
<li>select 在遇到多个 Channel 同时响应时会<em>随机挑选</em> case 执行；</li>
</ol>
<p>select 在 Go 语言的源代码中不存在对应的结构体，但是 select 控制结构中的 case 却使用 <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L28-L34" target="_blank" rel="noopener">runtime.scase</a> 结构体来表示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> scase <span class="keyword">struct</span> &#123;</span><br><span class="line">	c           *hchan  <span class="comment">// 存储 case 中使用的 Channel</span></span><br><span class="line">	elem        unsafe.Pointer  <span class="comment">// 接收或者发送数据的变量地址</span></span><br><span class="line">	kind        <span class="keyword">uint16</span> <span class="comment">// 表示 runtime.scase 的种类, 总共4种</span></span><br><span class="line">	pc          <span class="keyword">uintptr</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// runtime.scase的种类: </span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	caseNil = <span class="literal">iota</span></span><br><span class="line">	caseRecv</span><br><span class="line">	caseSend</span><br><span class="line">	caseDefault</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>select 语句在编译期间会被转换成 OSELECT 节点。每一个 OSELECT 节点都会持有一组 OCASE 节点，如果 OCASE 的执行条件是空，那就意味着这是一个 default 节点</p>
<p>对于select的4种不同情况的编译器处理与优化: </p>
<ol>
<li>空的 select 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态. 直接将类似 select {} 的空语句转换成调用 runtime.block 函数</li>
<li>如果当前的 select 条件只包含一个 case，那么就会将 select 改写成 if 条件语句<br>改写成类似<code>v, ok := &lt;-ch // case ch &lt;- v</code> 这样. 这会判断ch是否关闭, 不关闭尝试读取数据. </li>
<li>当 select 中仅包含两个 case，并且其中一个是 default 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作. 当 case 中表达式的类型是 OSEND 时，编译器会使用 if/else 语句和 runtime.selectnbsend 函数改写代码,它提供了向 Channel 非阻塞地发送数据的能力. 同样接收也会改写成if/else语句. </li>
<li>其他情况的常规流程下, 先将所有的 case 转换成包含 Channel 以及类型等信息的 runtime.scase 结构体, 再调用运行时函数 runtime.selectgo 从多个准备就绪的 Channel 中选择一个可执行的 runtime.scase 结构体, 最后通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case. </li>
</ol>
<p>其中由selectgo函数负责选择待执行的case. <a href="https://github.com/golang/go/blob/d1969015b4ac29be4f518b94817d3f525380639d/src/runtime/select.go#L118-L497" target="_blank" rel="noopener">runtime.selectgo</a> 函数首先会进行执行必要的初始化操作并决定处理 case 的两个顺序 — 轮询顺序 pollOrder(加入随机性) 和加锁顺序 lockOrder(按照 Channel 的地址排序后确定加锁顺序). 之后它会分三个阶段查找或者等待某个 Channel 准备就绪：</p>
<ol>
<li>查找是否已经存在准备就绪的 Channel，即可以执行收发操作；</li>
<li>将当前 Goroutine 加入 Channel 对应的收/发队列上并等待其他 Goroutine 的唤醒；</li>
<li>当前 Goroutine 被唤醒之后找到满足条件的 Channel 并进行处理；</li>
</ol>
<p>其会根据不同情况通过 goto 跳转到函数内部的不同标签执行相应的逻辑, 包括:</p>
<ul>
<li>bufrecv：可以从缓冲区读取数据；</li>
<li>bufsend：可以向缓冲区写入数据；</li>
<li>recv：可以从休眠的发送方获取数据；</li>
<li>send：可以向休眠的接收方发送数据；</li>
<li>rclose：可以从关闭的 Channel 读取 EOF；</li>
<li>sclose：向关闭的 Channel 发送数据；</li>
<li>retc：结束调用并返回；</li>
</ul>
<p><strong>随机的轮询顺序可以避免 Channel 的饥饿问题，保证公平性；而根据 Channel 的地址顺序(字母顺序排序)确定加锁顺序能够避免死锁的发生。</strong></p>
<h4 id="根据-Channel-的地址顺序确定加锁顺序如何做到避免死锁的"><a href="#根据-Channel-的地址顺序确定加锁顺序如何做到避免死锁的" class="headerlink" title="根据 Channel 的地址顺序确定加锁顺序如何做到避免死锁的?"></a>根据 Channel 的地址顺序确定加锁顺序如何做到避免死锁的?</h4><p>lockOrder 的主要作用是避免死锁，如果两个 Goroutine 都需要锁定 ChannelA 和 ChannelB 才能执行任务，当两者尝试去依照不同的顺序进行锁定时，就可能发生死锁，以下是同时发生的：</p>
<p>Goroutine1 先锁定 A，这时发现 B 被锁定了，它是会有 A 的锁，等待 B 的释放<br>Goroutine2 先锁定 B，这时发现 A 被锁定了，它会持有 B 的锁，等待 A 的释放<br>如果锁定的顺序相同，这种情况就不会出现了，Goroutine1 和 2 都按照字母序来锁定 Channel，先获得 A 的 Goroutine 就可以先执行</p>
<h4 id="selectgo的三个阶段工作"><a href="#selectgo的三个阶段工作" class="headerlink" title="selectgo的三个阶段工作"></a>selectgo的三个阶段工作</h4><ol>
<li>查找已经准备就绪的 Channel。<br>其会循环会遍历所有的 case 并找到需要被唤起的 runtime.sudog 结构，在这个阶段，我们会根据 case 的四种类型分别处理：</li>
</ol>
<ul>
<li>caseNil：当前 case 不包含 Channel；<br>  这种 case 会被跳过；</li>
<li>caseRecv：当前 case 会从 Channel 中接收数据；<ul>
<li>如果当前 Channel 的 sendq 上有等待的 Goroutine，就会跳到 recv 标签并从缓冲区读取数据,同时将等待的 Goroutine 中的数据放入到缓冲区中相同的位置；</li>
<li>如果当前 Channel 的缓冲区不为空，就会跳到 bufrecv 标签处从缓冲区获取数据；</li>
<li>如果当前 Channel 已经被关闭，就会跳到 rclose 做一些清除的收尾工作；</li>
</ul>
</li>
<li>caseSend：当前 case 会向 Channel 发送数据；<ul>
<li>如果当前 Channel 已经被关，闭就会直接跳到 sclose 标签，触发 panic 尝试中止程序；</li>
<li>如果当前 Channel 的 recvq 上有等待的 Goroutine，就会跳到 send 标签向 Channel 发送数据；</li>
<li>如果当前 Channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区；</li>
</ul>
</li>
<li>caseDefault：当前 case 为 default 语句；<br>  表示前面的所有 case 都没有被执行，这里会解锁所有 Channel 并返回，意味着当前 select 结构中的收发都是非阻塞的；</li>
</ul>
<ol start="2">
<li><p>如果不能立刻找到活跃的 Channel 就会进入循环的下一阶段，按照需要将当前的 Goroutine 加入到 Channel 的 sendq 或者 recvq 队列中. 除了将当前 Goroutine 对应的 runtime.sudog 结构体加入队列之外，这些 runtime.sudog 结构体都会被串成链表附着在 Goroutine 上。在入队之后会调用 runtime.gopark 函数挂起当前 Goroutine 等待调度器的唤醒。</p>
</li>
<li><p>等到 select 中的一些 Channel 准备就绪之后，当前 Goroutine 就会被调度器唤醒。这时会继续执行 runtime.selectgo 函数的第三阶段，从 runtime.sudog 结构体中获取数据. 会先获取当前 Goroutine 接收到的参数 sudog 结构，我们会依次对比所有 case 对应的 sudog 结构找到被唤醒的 case(链表遍历)，获取该 case 对应的索引并返回.</p>
</li>
</ol>
<p>由于当前的 select 结构找到了一个 case 执行，那么剩下 case 中没有被用到的 sudog 就会被忽略并且释放掉。为了不影响 Channel 的正常使用，我们还是需要将这些废弃的 sudog 从 Channel 中出队。</p>
<p>当我们在循环中发现缓冲区中有元素或者缓冲区未满时就会通过 goto 关键字跳转到 bufrecv 和 bufsend 两个代码段执行channel的数据收发, 这会调用 Channel 运行时函数 runtime.send 和 runtime.recv，这两个函数会直接与处于休眠状态的 Goroutine 打交道. 有两个特殊情况:<br>    1. 从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；<br>    2. 向一个关闭的 Channel 发送数据就会直接 panic 造成程序崩溃：</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>样例代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPost</span><span class="params">(db *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    tx := db.Begin()</span><br><span class="line">    <span class="keyword">defer</span> tx.Rollback() <span class="comment">// 哪怕事务真的执行成功了，那么调用 tx.Commit() 之后再执行 tx.Rollback() 也不会影响已经提交的事务</span></span><br><span class="line">    <span class="keyword">if</span> err := tx.Create(&amp;Post&#123;Author: <span class="string">"Draveness"</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tx.Commit().Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向 defer 关键字传入的函数会在函数返回之前运行, 会在调用时就执行, 解决办法就是使用给defer匿名函数,这样虽然传入时值拷贝,但是拷贝的是函数的指针, 在返回时才执行函数, 就不会导致defer语句中数据在调用时就被生成.  </p>
<p>defer的<a href="https://github.com/golang/go/blob/cfe3cd903f018dec3cb5997d53b1744df4e53909/src/runtime/runtime2.go#L853-L878" target="_blank" rel="noopener">数据结构</a>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">	siz     <span class="keyword">int32</span> <span class="comment">// 参数和结果的内存大小</span></span><br><span class="line">	started <span class="keyword">bool</span> </span><br><span class="line">	sp      <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">	pc      <span class="keyword">uintptr</span> <span class="comment">// 调用方程序计数器</span></span><br><span class="line">	fn      *funcval  <span class="comment">// 传入的函数指针</span></span><br><span class="line">	_panic  *_panic  <span class="comment">// 触发延迟调用的结构体, 可能为空. </span></span><br><span class="line">	link    *_defer <span class="comment">// 所有的结构体都会通过 link 字段串联成链表</span></span><br><span class="line">	... <span class="comment">// 其他垃圾回收使用的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defer 在编译器看来也是函数调用, 将 defer 关键字都转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L218-L258" target="_blank" rel="noopener">runtime.deferproc</a> 函数(负责创建新的延迟调用), 还在所有调用 defer 的函数结尾插入了 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L526-L571" target="_blank" rel="noopener">runtime.deferreturn</a> (负责在函数调用结束时执行所有的延迟调用).</p>
<p>在deferproc中会创建/获得_defer结构体,设置它的函数指针 fn、程序计数器 pc 和栈指针 sp 并将相关的参数拷贝到相邻的内存空间中, 最后调用<a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L1320-L1322" target="_blank" rel="noopener">runtime.return0</a> (避免无线递归调用deferreturn,唯一一个不会触发延迟调用的函数)</p>
<p>有三种途径获得_defer结构体: 1. 从调度器的延迟调用缓存池 sched.deferpool 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；2. 从 Goroutine 的延迟调用缓存池 pp.deferpool 中取出结构体；3. 通过 runtime.mallocgc 创建一个新的结构体</p>
<p>之后将_defer机构体追加到链表的最前端. 执行会从链表最前端开始执行, 这就是为啥后进先执行的原因. 执行时调用 <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/runtime/asm_386.s#L614-L624" target="_blank" rel="noopener">runtime.jmpdefer</a> 函数传入需要执行的函数和参数,跳转到defer的代码执行, 在执行结束之后跳转回 runtime.deferreturn, 其中会多次判断当前 Goroutine 的 _defer 链表中是否有未执行的剩余结构，在所有的延迟函数调用都执行完成之后，该函数才会返回.</p>
<p>defer可以读取/修改函数的命名返回值: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回2</span></span><br></pre></td></tr></table></figure>

<h2 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic 和 recover"></a>panic 和 recover</h2><ul>
<li>panic 只会触发当前 Goroutine 的延迟函数调用, 不会触发调用方的(<strong>goroutine实际上都是平行的存在, 不存在树状父子关系</strong>)；</li>
<li>recover 只有在 defer 函数中调用才会生效；</li>
<li>panic 允许在 defer 中嵌套多次调用, 多次嵌套调用 panic 也不会影响 defer 函数的正常执行；<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"in main"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"panic again and again"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"panic again"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic once"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// in main</span></span><br><span class="line"><span class="comment">// panic: panic once</span></span><br><span class="line"><span class="comment">//	panic: panic again</span></span><br><span class="line"><span class="comment">//	panic: panic again and again</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>调用panic会创建结构: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">	argp      unsafe.Pointer <span class="comment">// 指向 defer 调用时参数的指针</span></span><br><span class="line">	arg       <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用 panic 时传入的参数</span></span><br><span class="line">	link      *_panic <span class="comment">// 指向了更早调用的 runtime._panic 结构, 多个panic之间通过 link 的关联形成一个链表</span></span><br><span class="line">	recovered <span class="keyword">bool</span> <span class="comment">// recovered 表示当前 runtime._panic 是否被 recover 恢复</span></span><br><span class="line">	aborted   <span class="keyword">bool</span> <span class="comment">// aborted 表示当前的 panic 是否被强行终止</span></span><br><span class="line"> <span class="comment">// 结构体中的 pc、sp 和 goexit 三个字段都是为了修复 runtime.Goexit 的问题引入的2。该函数能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 defer 中的 panic 和 recover 取消，引入这三个字段的目的就是为了解决这个问题。</span></span><br><span class="line">	pc        <span class="keyword">uintptr</span></span><br><span class="line">	sp        unsafe.Pointer</span><br><span class="line">	goexit    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gopanic的执行过程:</p>
<ol>
<li>创建新的 runtime._panic 结构并添加到所在 Goroutine _panic 链表的最前面；</li>
<li>在循环中不断从当前 Goroutine 的 _defer 中链表获取 runtime._defer 并调用 runtime.reflectcall 运行延迟调用函数；</li>
<li>调用 runtime.fatalpanic 中止整个程序,其中打印 panic 消息之后会通过 <a href="https://github.com/golang/go/blob/cbaa666682386fe5350bf87d7d70171704c90fe4/src/runtime/sys_darwin.go#L231-L233" target="_blank" rel="noopener">runtime.exit</a> 退出当前程序并返回错误码(正常退出也是这个函数).</li>
</ol>
<p>其中还包括 恢复程序的 recover 分支中的代码; 通过内联优化 defer 调用性能的代码 ; 修复 runtime.Goexit 异常情况的代码</p>
<p>编译器会将关键字 recover 转换成 <a href="https://github.com/golang/go/blob/22d28a24c8b0d99f2ad6da5fe680fa3cfa216651/src/runtime/panic.go#L1080-L1094" target="_blank" rel="noopener">runtime.gorecover</a> 如果当前 Goroutine 没有调用 panic，那么该函数会直接返回 nil. </p>
<p>runtime.recovery 在调度过程中会将函数的返回值设置成 1。从 runtime.deferproc 的注释中我们会发现，当 runtime.deferproc 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 runtime.deferreturn,跳转到 runtime.deferreturn 函数之后，程序就已经从 panic 中恢复了并执行正常的逻辑</p>
<h4 id="程序崩溃和恢复的过程总结："><a href="#程序崩溃和恢复的过程总结：" class="headerlink" title="程序崩溃和恢复的过程总结："></a>程序崩溃和恢复的过程总结：</h4><ol>
<li>编译器会负责做转换关键字的工作；<ul>
<li>将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；</li>
<li>将 defer 转换成 deferproc 函数；</li>
<li>在调用 defer 的函数末尾调用 deferreturn 函数；</li>
</ul>
</li>
<li>在运行过程中遇到 gopanic 方法时，会从 Goroutine 的链表依次取出 _defer 结构体并执行；</li>
<li>如果调用延迟执行函数时遇到了 gorecover 就会将 _panic.recovered 标记成 true 并返回 panic 的参数；<ul>
<li>在这次调用结束之后，gopanic 会从 _defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 recovery 函数进行恢复程序；</li>
<li>recovery 会根据传入的 pc 和 sp 跳转回 deferproc；</li>
<li>编译器自动生成的代码会发现 deferproc 的返回值不为 0，这时会跳回 deferreturn 并恢复到正常的执行流程；</li>
</ul>
</li>
<li>如果没有遇到 gorecover 就会依次遍历所有的 _defer 结构，并在最后调用 fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；</li>
</ol>
<h2 id="make-和-new"><a href="#make-和-new" class="headerlink" title="make 和 new"></a>make 和 new</h2><p>make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel；<br>new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针;</p>
<p>在类型检查阶段, make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型</p>
<p>在中间代码生成阶段, neew会通过cmd/compile/internal/gc.callnew 函数会将关键字转换成 ONEWOBJ 类型的节点. </p>
<p>无论是直接使用 new，还是使用 var 初始化变量，它们在编译器看来就是 ONEWOBJ 和 ODCL 节点. </p>
<p>如果通过 var 或者 new 创建的变量不需要在当前作用域外生存，例如不用作为返回值返回给调用方，那么就不需要初始化在堆上</p>
<h2 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文 Context"></a>上下文 Context</h2><p>context.Context 是 Go 语言在 1.7 版本中引入标准库的接口,用于传递调用链上游的一些信息，该接口定义了四个需要实现的方法，其中包括：</p>
<ol>
<li>Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；</li>
<li>Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 Channel；</li>
<li>Err — 返回 context.Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；<ul>
<li>如果 context.Context 被取消，会返回 Canceled 错误；</li>
<li>如果 context.Context 超时，会返回 DeadlineExceeded 错误；</li>
</ul>
</li>
<li>Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	Err() error</span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure>
context 包中提供的 <code>context.Background、context.TODO、context.WithDeadline 和 context.WithValue</code> 函数会返回实现该接口的私有结构体</li>
</ol>
<p>每一个 context.Context 都会从最顶层的 Goroutine 一层一层传递到最下层。context.Context 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。多个 Goroutine 同时订阅 ctx.Done() 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作.  </p>
<p> context.Background、context.TODO都是返回的emptyCtx, 而emptyCtx是实现Context接口的基本空组件.  context.Background 和 context.TODO 函数其实也只是互为别名，没有太大的差别。它们只是在使用和语义上稍有不同：</p>
<ul>
<li>context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生（Derived）出来；</li>
<li>context.TODO 应该只在不确定应该使用哪种上下文时使用；</li>
</ul>
<p>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 context.Background 作为起始的上下文向下传递。</p>
<p>Context接口中，Done方法的返回值是一个只读channel，当取消信号发出时，这个channel被关闭. </p>
<p><strong>针对多个goroutine监听同一个channel做相同操作的场景, 不用发多个信号, 直接关闭channel是最好的办法</strong></p>
<p><em>即使使用了context, 所有信号的发出、接受和处理，包括goroutine树形结构的维护都是需要我们自己在代码中手动去做的，context并不能替我们完成, Context的主要作用有两个：传递取消信号（包括定时取消和手动取消），和传递数据。但这两种功能都需要我们时刻记得要把context传递下去，而且对于取消信号，还需要手动监听手动处理。context并不会帮我们把goroutine停掉。</em></p>
<h4 id="取消信号"><a href="#取消信号" class="headerlink" title="取消信号"></a>取消信号</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 父上下文不会触发取消信号,当前函数会直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err()) <span class="comment">// 父上下文已经被取消</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">	<span class="comment">// 如果父上下文没有被取消，child 会被加入 parent 的 children 列表中，等待 parent 释放取消信号</span></span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 默认情况下会同时监听父子的Done channel</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err()) <span class="comment">// 在父关闭时取消子的上下文</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭上下文中的 Channel 并向所有的子上下文同步取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>context.WithDeadline 方法在创建 context.timerCtx 的过程中，判断了父上下文的截止日期与当前日期，并通过 time.AfterFunc 创建定时器，当时间超过了截止日期后会调用 context.timerCtx.cancel 方法同步取消信号。WithTimeout其实是直接调用WithDeadline的. context.timerCtx 结构体内部不仅通过嵌入了context.cancelCtx 结构体继承了相关的变量和方法，还通过持有的定时器 timer 和截止时间 deadline 实现了定时取消这一功能. context.timerCtx.cancel 方法不仅调用了 context.cancelCtx.cancel，还会停止持有的定时器减少不必要的资源浪费</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> context.WithValue 函数能从父上下文中创建一个子上下文，传值的子上下文使用 context.valueCtx 类型, 这样就生成了树状的层层包裹的结构. 通过Value方法查找上下文中的键值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key) <span class="comment">// 如果 context.valueCtx 中存储的键值对与 context.valueCtx.Value 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到在某个父上下文中返回 nil 或者查找到对应的值. PS: 这里返回nil是因为最顶层是emptyCtx, 其Value直接返回nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步原语与锁"><a href="#同步原语与锁" class="headerlink" title="同步原语与锁"></a>同步原语与锁</h2><h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span> <span class="comment">// 表示当前互斥锁的状态, 最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放. 在默认情况下，互斥锁的所有状态位都是 0</span></span><br><span class="line">	sema  <span class="keyword">uint32</span> <span class="comment">// 用于控制锁状态的信号量, </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Mutex 有两种模式 — 正常模式和饥饿模式.  相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时.</p>
<ul>
<li>在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』. </li>
<li>饥饿模式是在 Go 语言 1.9 版本引入的优化，引入的目的是保证互斥锁的公平性（Fairness）. 在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</li>
</ul>
<p>加锁和解锁过程，它们分别使用 sync.Mutex.Lock 和 sync.Mutex.Unlock 方法. 这两个方法就是CAS自旋方式. </p>
<p>在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li>sync.runtime_canSpin 在以下条件下需要返回 true：<ul>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ul>
</li>
</ol>
<p>一旦当前 Goroutine 能够进入自旋就会调用sync.runtime_doSpin 和 runtime.procyield 并执行 30 次的 PAUSE 指令，该指令只会占用 CPU 并消耗 CPU 时间</p>
<p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 state 字段中存储的不同信息 — mutexLocked、mutexStarving、mutexWoken 和 mutexWaiterShift, 计算了新的互斥锁状态之后，就会使用 CAS 函数 atomic.CompareAndSwapInt32 更新该状态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">	<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出</p>
<p>解锁: </p>
<ol>
<li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li>
<li>如果该函数返回的新状态不等于 0，这段代码会调用 sync.Mutex.unlockSlow 方法开始慢速解锁</li>
</ol>
<h4 id="Mutex加锁与解锁总结"><a href="#Mutex加锁与解锁总结" class="headerlink" title="Mutex加锁与解锁总结"></a>Mutex加锁与解锁总结</h4><p>加锁：</p>
<ul>
<li>如果互斥锁处于初始化状态，就会直接通过置位 mutexLocked 加锁；</li>
<li>如果互斥锁处于 mutexLocked 并且在普通模式下工作，就会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 sync.runtime_SemacquireMutex 函数将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒当前 Goroutine；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；</li>
</ul>
<p>解锁：</p>
<ul>
<li>当互斥锁已经被解锁时，那么调用 sync.Mutex.Unlock 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，就会直接返回；在其他情况下会通过 sync.runtime_Semrelease 唤醒对应的 Goroutine；</li>
</ul>
<h4 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex <span class="comment">// 复用互斥锁提供的能力</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">// 用于写等待读</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span> <span class="comment">// 用于读等待写</span></span><br><span class="line">	readerCount <span class="keyword">int32</span> <span class="comment">// 存储了当前正在执行的读操作的数量</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span> <span class="comment">// 表示当写操作被阻塞时等待的读操作个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』。</em></p>
<p>小结: </p>
<ul>
<li>调用 sync.RWMutex.Lock 尝试获取写锁时；<ul>
<li>每次 sync.RWMutex.RUnlock 都会将 readerWait 其减一，当它归零时该 Goroutine 就会获得写锁；</li>
<li>将 readerCount 减少 rwmutexMaxReaders 个数以阻塞后续的读操作；</li>
</ul>
</li>
<li>调用 sync.RWMutex.Unlock 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>
<h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy <span class="comment">// 保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span> <span class="comment">// 存储着状态和信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>sync.noCopy 是一个特殊的私有结构体，tools/go/analysis/passes/copylock 包中的分析器会在编译期间检查被拷贝的变量中是否包含 sync.noCopy 结构体，如果包含该结构体就会在运行时报出错误.</strong></p>
<p>虽然 sync.WaitGroup.Add 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，也就是所有任务都执行完成时，就会通过 sync.runtime_Semrelease 唤醒处于等待状态的所有 Goroutine。</p>
<p>小结:</p>
<ul>
<li>sync.WaitGroup 必须在 sync.WaitGroup.Wait 方法返回之后才能被重新使用；</li>
<li>sync.WaitGroup.Done 只是对 sync.WaitGroup.Add 方法的简单封装，我们可以向 sync.WaitGroup.Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 sync.WaitGroup 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<h4 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="keyword">uint32</span> <span class="comment">// 用于标识代码块是否执行过的 done</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: </p>
<ul>
<li>sync.Once.Do 方法中传入的函数只会被执行一次，哪怕函数中发生了 panic；</li>
<li>两次调用 sync.Once.Do 方法传入不同的函数也只会执行第一次调用的函数；</li>
</ul>
<h4 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h4><p>Go 语言标准库中的 sync.Cond 一个条件变量，它可以让一系列的 Goroutine 都在满足特定条件时被唤醒。每一个 sync.Cond 结构体在初始化时都需要传入一个互斥锁.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy  noCopy <span class="comment">// 用于保证结构体不会在编译期间拷贝</span></span><br><span class="line">	L       Locker <span class="comment">//  用于保护内部的 notify 字段，Locker 接口类型的变量</span></span><br><span class="line">	notify  notifyList <span class="comment">// 一个 Goroutine 的链表，它是实现同步机制的核心结构</span></span><br><span class="line">	checker copyChecker  <span class="comment">// 用于禁止运行期间发生的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//head 和 tail 分别指向的链表的头和尾，wait 和 notify 分别表示当前正在等待的和已经通知到的 Goroutine</span></span><br><span class="line">	wait <span class="keyword">uint32</span></span><br><span class="line">	notify <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">	head *sudog</span><br><span class="line">	tail *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Go 语言切换 Goroutine 时经常会使用的方法: 调用 runtime.goparkunlock 将当前 Goroutine 陷入休眠状态, 它会直接让出当前处理器的使用权并等待调度器的唤醒.</em></p>
<p>sync.Cond 不是一个常用的同步机制，在遇到长时间条件无法满足时，与使用 for {} 进行忙碌等待相比，sync.Cond 能够让出处理器的使用权。在使用的过程中我们需要注意以下问题：</p>
<ol>
<li>sync.Cond.Wait 方法在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>
<li>sync.Cond.Signal 方法唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>
<li>sync.Cond.Broadcast 会按照一定顺序广播通知等待的全部 Goroutine；</li>
</ol>
<h4 id="扩展原语"><a href="#扩展原语" class="headerlink" title="扩展原语"></a>扩展原语</h4><p>Go 语言还在子仓库 sync 中提供了四种扩展原语，x/sync/errgroup.Group、x/sync/semaphore.Weighted、x/sync/singleflight.Group 和 x/sync/syncmap.Map，其中的 x/sync/syncmap.Map 在 1.9 版本中被移植到了标准库中</p>
<ol>
<li>ErrGroup: 如果返回错误, 这一组G中至少有一个错误, 如果返回空,则所有G成功执行. <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/errgroup/errgroup.go#L18-L25" target="_blank" rel="noopener">x/sync/errgroup.Group</a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancel <span class="function"><span class="keyword">func</span><span class="params">()</span> // 创建 <span class="title">context</span>.<span class="title">Context</span> 时返回的取消函数，用于在多个 <span class="title">Goroutine</span> 之间同步取消信号</span></span><br><span class="line">	wg sync.WaitGroup <span class="comment">// 用于等待一组 Goroutine 完成子任务的同步原语</span></span><br><span class="line">	errOnce sync.Once <span class="comment">// 用于保证只接收一个子任务返回的错误；</span></span><br><span class="line">	err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>x/sync/errgroup.Group 在出现错误或者等待结束后都会调用 context.Context 的 cancel 方法同步取消信号；</li>
<li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃；</li>
</ul>
<ol start="2">
<li>带权重的信号量 <a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/semaphore/semaphore.go#L28-L33" target="_blank" rel="noopener">x/sync/semaphore.Weighted</a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">	size    <span class="keyword">int64</span> <span class="comment">// 当前信号量的上限</span></span><br><span class="line">	cur     <span class="keyword">int64</span> <span class="comment">// 计数器, 计数范围0-size</span></span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	waiters list.List <span class="comment">// 其中存储着等待获取资源的 Goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>x/sync/semaphore.Weighted.Acquire 和 x/sync/semaphore.Weighted.TryAcquire 方法都可以用于获取资源，前者会阻塞地获取信号量，后者会非阻塞地获取信号量；</li>
<li>x/sync/semaphore.Weighted.Release 方法会按照 FIFO 的顺序唤醒可以被唤醒的 Goroutine；</li>
<li>如果一个 Goroutine 获取了较多地资源，由于 x/sync/semaphore.Weighted.Release 的释放策略可能会等待比较长的时间；</li>
</ul>
<ol start="3">
<li><a href="https://github.com/golang/sync/blob/cd5d95a43a6e21273425c7ae415d3df9ea832eeb/singleflight/singleflight.go#L33-L36" target="_blank" rel="noopener">x/sync/singleflight.Group</a> 是 Go 语言扩展包中提供了另一种同步原语，它能够在一个服务中抑制对下游的多次重复请求。</li>
</ol>
<p>在资源的获取非常昂贵时（例如：访问缓存、数据库），就很适合使用 x/sync/singleflight.Group 对服务进行优化。我们来了解一下它的使用方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">    requestGroup singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context, request Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">    v, err, _ := requestGroup.Do(request.Hash(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        rows, err := <span class="comment">// select * from tables</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Response&#123;</span><br><span class="line">        rows: rows,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为请求的哈希在业务上一般表示相同的请求，所以上述代码使用它作为请求的键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// val 和 err 字段都只会在执行传入的函数时赋值一次并在 sync.WaitGroup.Wait 返回时被读取</span></span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line">    <span class="comment">// dups 和 chans 两个字段分别存储了抑制的请求数量以及用于同步结果的 Channel</span></span><br><span class="line">	dups  <span class="keyword">int</span></span><br><span class="line">	chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>x/sync/singleflight.Group.Do 和 x/sync/singleflight.Group.DoChan 一个用于同步阻塞调用传入的函数，一个用于异步调用传入的参数并通过 Channel 接收函数的返回值；</li>
<li>x/sync/singleflight.Group.Forget 方法可以通知 x/sync/singleflight.Group 在持有的映射表中删除某个键，接下来对该键的调用就不会等待前面的函数返回了；</li>
<li>一旦调用的函数返回了错误，所有在等待的 Goroutine 也都会接收到同样的错误；</li>
</ul>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>Go 1.10 之前的计时器都使用最小四叉堆实现. 所有计时器的结构体都会共享全局的 []*timer即最小四叉堆. G会在时间驱动事件: 计时器到期/加入触发时间更早的新计时器时被唤醒. 由于操作需要获取全局唯一的呼哧锁互斥锁,会影响计时器性能.</p>
<p>Go 1.10 将全局的四叉堆分割成了 64 个更小的四叉堆5。在理想情况下，四叉堆的数量应该等于处理器的数量，但是这需要实现动态的分配过程，所以经过权衡最终选择初始化 64 个四叉堆，以牺牲内存占用的代价换取性能的提升。</p>
<p>如果当前机器上的处理器 P 的个数超过了 64，多个处理器上的计时器就可能存储在同一个桶中。每一个计时器桶都由一个运行 runtime.timerproc#76f4fd8 函数的 Goroutine 处理. 将全局计时器分片的方式，虽然能够降低锁的粒度，提高计时器的性能，但是 runtime.timerproc#76f4fd8 造成的处理器和线程之间频繁的上下文切换却成为了影响计时器性能的首要因素。</p>
<p>在1,14的实现中，计时器桶已经被移除，所有的计时器都以最小四叉堆的形式存储在处理器 runtime.p 中。目前计时器都交由处理器的网络轮询器和调度器触发，这种方式能够充分利用本地性、减少线上上下文的切换开销.</p>
<p><strong>运行时使用状态机的方式处理全部的计时器，其中包括 10 种状态和 7 种操作。</strong></p>
<p>timerNoStatus    还没有设置状态<br>timerWaiting    等待触发<br>timerRunning    运行计时器函数<br>timerDeleted    被删除<br>timerRemoving    正在被删除<br>timerRemoved    已经被停止并从堆中删除<br>timerModifying    正在被修改<br>timerModifiedEarlier    被修改到了更早的时间<br>timerModifiedLater    被修改到了更晚的时间<br>timerMoving    已经被修改正在被移动</p>
<ul>
<li>“timerRunning、timerRemoving、timerModifying” “和” “timerMoving” “—“ “停留的时间都比较短；”</li>
<li>“timerWaiting、timerRunning、timerDeleted、timerRemoving、timerModifying、timerModifiedEarlier、timerModifiedLater” “和” “timerMoving” “—“ “计时器在处理器的堆上；”</li>
<li>“timerNoStatus” “和” “timerRemoved” “—“ “计时器不在堆上；”</li>
<li>“timerModifiedEarlier” “和” “timerModifiedLater” “—“ “计时器虽然在堆上，但是可能位于错误的位置上，需要重新排序；”</li>
</ul>
<p>runtime.addtimer — 向当前处理器增加新的计时器；<br>runtime.deltimer — 将计时器标记成 timerDeleted 删除处理器中的计时器；<br>runtime.modtimer — 网络轮询器会调用该函数修改计时器；<br>runtime.resettimer — 修改已经失效的计时器的到期时间，将其变成活跃的计时器；<br>runtime.cleantimers — 清除队列头中的计时器，能够提升程序创建和删除计时器的性能；<br>runtime.adjusttimers — 调整处理器持有的计时器堆，包括移动会稍后触发的计时器、删除标记为 timerDeleted 的计时器；<br>runtime.runtimer — 检查队列头中的计时器，在其准备就绪时运行该计时器；</p>
<p>go会在两个模块中触发计时器:</p>
<ol>
<li>调度器调度时会检查处理器中的计时器是否准备就绪；</li>
<li>系统监控会检查是否有未执行的到期计时器；</li>
</ol>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>目前的 Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：</p>
<ol>
<li>先从 Channel 读取数据的 Goroutine 会先接收到数据；</li>
<li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；</li>
</ol>
<p>无锁（lock-free）队列更准确的描述是使用乐观并发控制的队列。乐观并发控制也叫乐观锁.乐观并发控制本质上是基于验证的协议，我们使用原子指令 CAS（compare-and-swap 或者 compare-and-set）在多线程中同步数据，无锁队列的实现也依赖这一原子指令。</p>
<p>Channel 在运行时的内部表示是 runtime.hchan，该结构体中包含了一个用于保护成员变量的互斥锁，从某种程度上说，Channel 是一个用于同步和通信的有锁队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">	sendx    <span class="keyword">uint</span>  </span><br><span class="line">	recvx    <span class="keyword">uint</span></span><br><span class="line">	recvq    waitq</span><br><span class="line">	sendq    waitq</span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>qcount — Channel 中的元素个数；<br>dataqsiz — Channel 中的循环队列的长度；<br>buf — Channel 的缓冲区数据指针；<br>sendx — Channel 的发送操作处理到的位置；<br>recvx — Channel 的接收操作处理到的位置；<br>elemsize 和 elemtype 分别表示当前 Channel 能够收发的元素类型和大小；sendq 和 recvq 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 runtime.waitq 表示，链表中所有的元素都是 runtime.sudog 结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 Channel 中收发元素的类型和缓冲区的大小初始化 runtime.hchan 结构体和缓冲区：</p>
<ul>
<li>如果当前 Channel 中不存在缓冲区，那么就只会为 runtime.hchan 分配一段内存空间；</li>
<li>如果当前 Channel 中存储的类型不是指针类型，就会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li>
<li>在默认情况下会单独为 runtime.hchan 和缓冲区分配内存；</li>
</ul>
<p>向 Channel 发送数据时遇到的几种情况：</p>
<ol>
<li>如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 sendx 所在的位置上；</li>
<li>如果不满足上面的两种情况，就会创建一个 runtime.sudog 结构并将其加入 Channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li>
</ol>
<p>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</p>
<ol>
<li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 runnext 属性，但是并不会立刻触发调度；</li>
<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时就会将自己加入 Channel 的 sendq 队列并调用 runtime.goparkunlock 触发 Goroutine 的调度让出处理器的使用权；</li>
</ol>
<p>Channel 中接收数据时可能会发生的五种情况：</p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 runtime.gopark 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 函数会直接返回；</li>
<li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，就会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 recvx 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>Channel 接收数据时，会触发 Goroutine 调度的两个时机：</p>
<ol>
<li>当 Channel 为空时；</li>
<li>当缓冲区中不存在数据并且也不存在数据的发送者时；</li>
</ol>
<p>关闭channel就是将recvq 和 sendq 两个队列中的数据加入到 Goroutine 列表 gList 中,同时清除所有sudog上未被处理的元素,最后为gList中的所有G调用 runtime.goready 触发调度.</p>
<p><em>go的channel中会有一个readG和writeG的队列结构, 保存了读写该chan的goroutine的指针信息, 这样在chan中数据交互时通过runtime去调度对应的G进入运行队列. 所以对于无buffer的chan, 如果写端先执行会一直等待直到读端读取数据才会写入, 并且这里还对读写的位置进行了优化, 写就直接写到等待的G的地址空间中.</em></p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>处理器持有一个由可运行的 Goroutine 组成的运行队列 runq，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行. 处理器 P 是线程M和 Goroutine 的中间层. </p>
<p>Go 调度器对 Goroutine 的上下文切换约为 0.2us，相比于操作系统的线程上下文切换消耗约1us左右时间来说, 减少了 80% 的额外开销</p>
<p><em>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms, 就会触发抢占.</em> </p>
<p>基于协作的抢占式调度的工作原理：</p>
<ol>
<li>编译器会在调用函数前插入 runtime.morestack；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt；</li>
<li>当发生函数调用时，可能会执行编译器插入的 runtime.morestack 函数，它调用的 runtime.newstack 会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt；</li>
<li>如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；</li>
</ol>
<p>Go 语言在 1.14 版本中实现了非协作的抢占式调度,以增加触发抢占式调度的时间点以减少存在的边缘情况. 目前的抢占式调度也只会在垃圾回收扫描任务时触发.</p>
<p>抢占式调度过程：</p>
<ol>
<li>程序启动时，在 runtime.sighandler 函数中注册 SIGURG 信号的处理函数 runtime.doSigPreempt；</li>
<li>在触发垃圾回收的栈扫描时会调用 runtime.suspendG 挂起 Goroutine，该函数会执行下面的逻辑：</li>
<li>将 _Grunning 状态的 Goroutine 标记成可以被抢占，即将 preemptStop 设置成 true；</li>
<li>调用 runtime.preemptM 触发抢占；</li>
<li>runtime.preemptM 会调用 runtime.signalM 向线程发送信号 SIGURG；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 runtime.doSigPreempt；</li>
<li>runtime.doSigPreempt 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 runtime.sigctxt.pushCall；</li>
<li>runtime.sigctxt.pushCall 会修改寄存器并在程序回到用户态时执行 runtime.asyncPreempt；</li>
<li>汇编指令 runtime.asyncPreempt 会调用运行时函数 runtime.asyncPreempt2；</li>
<li>runtime.asyncPreempt2 会调用 runtime.preemptPark；</li>
<li>runtime.preemptPark 会修改当前 Goroutine 的状态到 _Gpreempted 并调用 runtime.schedule 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>选择 SIGURG 作为触发异步抢占的信号的原因: </p>
<ol>
<li>该信号需要被调试器透传；</li>
<li>该信号不会被内部的 libc 库使用并拦截；</li>
<li>该信号可以随意出现并且不触发任何后果；</li>
<li>我们需要处理多个平台上的不同信号；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决全部问题，但是这种真抢占式调度时调度器走向完备的开始.</p>
<p>非均匀内存访问（Non-uniform memory access，NUMA）调度器现在只是 Go 语言的提案，因为该提案过于复杂，而目前的调度器的性能已经足够优异，所以暂时没有实现该提案。该提案的原理就是通过拆分全局资源，让各个处理器能够就近获取，减少锁竞争并增加数据的局部性。</p>
<p><em>在目前的运行时中，线程、处理器、网络轮询器、运行队列、全局内存分配器状态、内存分配缓存和垃圾收集器都是全局资源。</em></p>
<p>NUMA调度器实现: 堆栈、全局运行队列和线程池会按照 NUMA 节点进行分区，网络轮询器和计时器会由单独的处理器持有.<br><img src="../../../media/qownnotes-media-JmLqSj-2095154484.png" alt="qownnotes-media-JmLqSj"></p>
<p><a href="https://img.draveness.me/2020-02-02-15805792666185-go-numa-scheduler-architecture.png" target="_blank" rel="noopener">https://img.draveness.me/2020-02-02-15805792666185-go-numa-scheduler-architecture.png</a></p>
<p>G — 表示 Goroutine，它是一个待执行的任务；<br>M — 表示操作系统的线程，它由操作系统的调度器调度和管理；<br>P — 表示处理器，它可以被看做运行在线程上的本地调度器；</p>
<p>G中包含有ID: goid ,该字段对开发者不可见，Go 团队认为引入 ID 会让部分 Goroutine 变得更特殊，从而限制语言的并发能力</p>
<p>G的状态:</p>
<ul>
<li>_Gidle    刚刚被分配并且还没有被初始化</li>
<li>_Grunnable    没有执行代码，没有栈的所有权，存储在运行队列中</li>
<li>_Grunning    可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</li>
<li>_Gsyscall    正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</li>
<li>_Gwaiting    由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</li>
<li>_Gdead    没有被使用，没有执行代码，可能有分配的栈</li>
<li>_Gcopystack    栈正在被拷贝，没有执行代码，不在运行队列上</li>
<li>_Gpreempted    由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</li>
<li>_Gscan    GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</li>
</ul>
<p><img src="../../../media/qownnotes-media-JRjXla-1607225346.png" alt="qownnotes-media-JRjXla"></p>
<p><strong>调度器最多可以创建 10000 个线程M，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。</strong> 在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数.</p>
<p>M的结构体中存在两个字段: g0 是持有调度栈的 Goroutine，curg 是在当前线程上运行的用户 Goroutine. g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。</p>
<p>因为调度器在启动时就会创建 GOMAXPROCS 个处理器，所以 Go 语言程序的处理器P数量一定会等于 GOMAXPROCS</p>
<p>P的状态有:</p>
<ol>
<li>_Pidle    处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</li>
<li>_Prunning    被线程 M 持有，并且正在执行用户代码或者调度器</li>
<li>_Psyscall    没有执行用户代码，当前线程陷入系统调用</li>
<li>_Pgcstop    被线程 M 持有，当前处理器由于垃圾回收被停止</li>
<li>_Pdead    当前处理器已经不被使用</li>
</ol>
<p><em>在调度器初始函数执行的过程中会将 maxmcount 设置成 10000，这也就是一个 Go 语言程序能够创建的最大线程数.</em></p>
<p>在调度器启动时,会堆allp中处理器数量进行操作保证与期望的数量GOMAXPROCS相等. 之后将除 allp[0] 之外的处理器 P 全部设置成 _Pidle 并加入到全局的空闲队列中；</p>
<p>在创建G时, runtime.newproc1 会从处理器或者调度器的缓存中获取新的结构体(复用已有的或者创建新的)，也可以调用 runtime.malg 函数创建新的结构体</p>
<p>新创建的G可能会在全局的运行队列上也可能在处理器P本地的运行队列上. 如果P的runnext指向的G为空, 直接设置该G为P的下一个执行任务, 如果next存在且本地队列还有空间则加入本地队列, 否则加入全局队列</p>
<p><strong>P的本地的运行队列是一个使用数组构成的环形链表，由p的结构体中runq表示, 它最多可以存储 256 个待执行任务G, 超过数量的G都会被放到全局队列(由调度器持有)中. 进入IO阻塞的G可能被放到全局的队列中, 这就使得同一个G可能在不同的P上执行.</strong> </p>
<p>Go的调度循环:<br>runtime.schedule 函数的会从不同地方查找待执行的 Goroutine：</p>
<ol>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 schedtick 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine；</li>
<li>如果前两种方法都没有找到 Goroutine，就会通过 runtime.findrunnable 进行阻塞地查找 Goroutine；当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待。</li>
</ol>
<p>findrunnable执行以下过程: </p>
<ol>
<li>从本地运行队列、全局运行队列中查找；</li>
<li>从网络轮询器中查找是否有 Goroutine 等待运行；</li>
<li>通过 runtime.runqsteal 函数尝试从其他随机的处理器中窃取待运行的 Goroutine，在该过程中还可能窃取处理器中的计时器；</li>
</ol>
<p>go的调度器执行逻辑循环:  schedule -&gt; execute -&gt; gogo -&gt; goexit0 -&gt;schedule …</p>
<p><em>Go 语言的调用惯例: 正常的函数调用都会使用 CALL 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码</em></p>
<p>触发调度的几个路径：</p>
<ul>
<li>主动挂起 — runtime.gopark -&gt; runtime.park_m -&gt;schedule</li>
<li>系统调用 — runtime.exitsyscall -&gt; runtime.exitsyscall0 -&gt;schedule</li>
<li>协作式调度 — runtime.Gosched -&gt; runtime.gosched_m -&gt; runtime.goschedImpl -&gt;schedule</li>
<li>系统监控 — runtime.sysmon -&gt; runtime.retake -&gt; runtime.preemptone -&gt;schedule</li>
</ul>
<p>runtime.gopark函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列,当 Goroutine 等待的特定条件满足后，运行时会调用 runtime.goready 将因为调用 runtime.gopark 而陷入休眠的 Goroutine 唤醒(设置_Grunnable并加入运行队列等待调度器调度).</p>
<p>为了处理特殊的系统调用，我们甚至在 Goroutine 中加入了 _Gsyscall 状态</p>
<p>Go 语言通过 <a href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/syscall/asm_linux_386.s#L18" target="_blank" rel="noopener">syscall.Syscall</a> 和 <a href="https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/syscall/asm_linux_386.s#L69" target="_blank" rel="noopener">syscall.RawSyscall</a> 等使用汇编语言编写的方法封装了操作系统提供的所有系统调用.  RawSyscall用于不需要运行时参与的系统调用, 以提升性能, 只有立刻返回的系统调用才能使用RawSyscall, 如SYS_EPOLL_WAIT（超时时间为 0）、SYS_TIME、SYS_EPOLL_CREATE等</p>
<p>陷入系统调用时 runtime.reentersyscall 进行的操作: </p>
<ol>
<li>禁止线程上发生的抢占，防止出现内存不一致的问题；</li>
<li>保证当前函数不会触发栈分裂或者增长；</li>
<li>保存当前的程序计数器 PC 和栈指针 SP 中的内容；</li>
<li>将 Goroutine 的状态更新至 _Gsyscall；</li>
<li>将 Goroutine 的处理器和线程暂时分离并更新处理器的状态到 _Psyscall；</li>
<li>释放当前线程上的锁；</li>
</ol>
<p>该方法 runtime.reentersyscall 会使处理器P和线程M的分离，当前线程会陷入系统调用等待返回，当前线程上的锁被释放后，会有其他 Goroutine 抢占处理器资源P.</p>
<p>系统调用结束以后, 会调用退出系统调用的函数 runtime.exitsyscall 为当前 Goroutine 重新分配资源.<br>如果调用 exitsyscallfast 函数不成功就使用相对较慢的exitsyscall0, 最终调用schedule触发调度.</p>
<p>exitsyscallfast 中包含两个不同的分支：</p>
<ol>
<li>如果 Goroutine 的原处理器处于 _Psyscall 状态，就会直接调用 wirep 将 Goroutine 与处理器进行关联；</li>
<li>如果调度器中存在闲置的处理器，就会调用 acquirep 函数使用闲置的处理器处理当前 Goroutine；</li>
</ol>
<p>exitsyscall0 会将当前 Goroutine 切换至 _Grunnable 状态，并移除线程 M 和当前 Goroutine 的关联：</p>
<ol>
<li>当我们通过 pidleget 获取到闲置的处理器时就会在该处理器上执行 Goroutine；</li>
<li>在其它情况下，我们会将当前 Goroutine 放到全局的运行队列中，等待调度器的调度；</li>
</ol>
<p>runtime.Gosched 就是主动让出处理器, 它会将Goroutine 的状态到 _Grunnable，让出当前的处理器并将 Goroutine 重新放回全局队列, 最后触发schedule.</p>
<p> runtime.LockOSThread 和 runtime.UnlockOSThread 让我们有能力绑定 Goroutine 和线程,<br><strong>Goroutine 应该在调用操作系统服务或者依赖线程状态的非 Go 语言库时调用 runtime.LockOSThread 函数</strong></p>
<p>在LockOSThread中会设置线程的 lockedg 字段和 Goroutine 的 lockedm 字段，这两行代码会绑定线程和 Goroutine.</p>
<p><strong>Go 语言程序创建的线程M数可能会多于 GOMAXPROCS . 当线程M处于阻塞状态后，如果其他线程都处于running状态, 这个时候会创建一个新的线程来运行当前处理器P队列中的Gorountine, 触发的时机可能包括 — 垃圾回收、系统监控. Go 语言本身对于程序中运行的线程上限为10000. Go 语言在启动线程时会设置 PTHREAD_CREATE_DETACHED，当线程执行完成后会自动回收和重用。</strong> Go使用pthread_attr_setdetachstate(3THR) 告知系统pthread库不需要Join该线程的结束.</p>
<p><strong>协程不是银弹, 在调用一些 C 语言的库时，例如 C 图形库，就需要绑定线程，协程在这时可能就不适用了。</strong></p>
<p>一定存在极端的边界条件让使用 Goroutine 和直接使用线程性能差不多，例如程序中全都是 I/O 操作，不过在实际的服务中很难出现，程序的执行都会同时使用到 CPU 和 I/O 两种资源.</p>
<ul>
<li><strong>io 与系统调用不能混淆，一个 io 过程可能包括多次系统调用。</strong></li>
<li><strong>（经过一个系统调用发现文件描述符还未可用而）阻塞的 io 首先会导致 G 的挂起，此时 G 与 M 分离，且不在任何 P 的运行队列中，当前的 P 会调度下一个 G，这个阶段不涉及新线程的创建。</strong></li>
<li><strong>被 io 挂起的 G 由网络轮询器维护，直到文件描述符可用。</strong></li>
<li><strong>网络轮询器既会被（在独立线程中的）系统监控 Goroutine 触发，也会被其他各个活跃线程上的 Goroutine 触发。</strong></li>
<li><strong>当文件描述符可用时，G 会重新加入到原来的 P 中等待被调度。</strong></li>
<li><strong>当 G 被重新调度时，会重新发起读/写系统调用。</strong></li>
<li><strong>当 G 进行系统调用的时候，对应的 M 和 P 也阻塞在系统调用，并不会立刻发生抢占，只有当这个阻塞持续时间过长（10 ms）时，才会将 P（及之上的其他 G）抢占并分配到空闲的 M 上，此时如果没有空闲的，才会创建新的线程。</strong></li>
</ul>
<p>线程 M 会持有自己的 g0, 全局也有一个 g0</p>
<h2 id="网络轮询器"><a href="#网络轮询器" class="headerlink" title="网络轮询器"></a>网络轮询器</h2><p>网络轮询器不仅用于监控网络 I/O，还能用于监控文件的 I/O，它利用了操作系统提供的 I/O 多路复用模型来提升 I/O 设备的利用率以及程序的性能</p>
<p>操作系统中包含阻塞 I/O、非阻塞 I/O、信号驱动 I/O 与异步 I/O 以及 I/O 多路复用五种 I/O 模型</p>
<p>I/O 多路复用被用来处理同一个事件循环中的多个 I/O 事件。I/O 多路复用需要使用特定的系统调用，最常见的系统调用就是 select，该函数可以同时监听最多 1024 个文件描述符的可读或者可写状态. 除了标准的 select 函数之外，操作系统中还提供了一个比较相似的 poll 函数，它使用链表存储文件描述符，摆脱了 1024 的数量上限.</p>
<p>多路复用函数会阻塞的监听一组文件描述符，当文件描述符的状态转变为可读或者可写时，select 会返回可读或者可写事件的个数，应用程序就可以在输入的文件描述符中查找哪些可读或者可写，然后执行相应的操作。select 有比较多的限制：</p>
<ol>
<li>监听能力有限 — 最多只能监听 1024 个文件描述符；</li>
<li>内存拷贝开销大 — 需要维护一个较大的数据结构存储文件描述符，该结构需要拷贝到内核中；</li>
<li>时间复杂度 O(n) — 返回准备就绪的事件个数后，需要遍历所有的文件描述符；</li>
</ol>
<p>Go实现了对不同操作系统上的I/O多路复用操作的多个版本的网络轮询模块, 如epoll、kqueue、evport、solaries.在编译时通过目标平台选择特定的代码分支. </p>
<p>各系统的网络轮询器接口都实现以下函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span> // 初始化轮询器 通过<span class="title">sync</span>.<span class="title">Once</span>保证只调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span> //创建事件,加入监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delta <span class="keyword">int64</span>)</span> <span class="title">gList</span> // 返回一组准备就绪的<span class="title">G</span>, <span class="title">delta</span>&gt;0则无限期等待文件描述符就绪, ==0则非阻塞轮询网络, &lt;0则阻塞特定时间轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span> // 唤醒轮询器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollIsPollDescriptor</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">bool</span> // 判断文件描述符是否被轮询器使用.</span></span><br></pre></td></tr></table></figure>
<p>操作系统中 I/O 多路复用函数会监控文件描述符的可读或者可写，而 Go 语言网络轮询器会监听 runtime.pollDesc 结构体的状态，该结构会封装操作系统的文件描述符. runtime.pollDesc 结构体会使用 link 字段串联成一个链表存储在 runtime.pollCache. runtime.pollCache 是运行时包中的全局变量,运行时会在第一次调用 runtime.pollCache.alloc 方法时初始化总大小约为 4KB 的 runtime.pollDesc 结构体，runtime.persistentalloc 会保证这些数据结构初始化在不会触发垃圾回收的内存中，让这些数据结构只能被内部的 epoll 和 kqueue 模块引用.调用 runtime.pollCache.free 方法释放已经用完的 runtime.pollDesc 结构，它会直接将结构体插入链表的最前面.</p>
<p><em>目前的计时器由网络轮询器管理和触发</em></p>
<h4 id="进入IO等待"><a href="#进入IO等待" class="headerlink" title="进入IO等待"></a>进入IO等待</h4><p>当我们在文件描述符上执行读写操作时，如果文件描述符不可读或者不可写，当前 Goroutine 就会执行 runtime.poll_runtime_pollWait 检查 runtime.pollDesc 的状态并调用 runtime.netpollblock 等待文件描述符的可读或者可写, netpollblock会使用运行时提供的 runtime.gopark 让出当前线程，将 Goroutine 转换到休眠状态并等待运行时的唤醒.</p>
<h4 id="轮询等待"><a href="#轮询等待" class="headerlink" title="轮询等待"></a>轮询等待</h4><p>Go 语言的运行时会在调度或者系统监控中调用 runtime.netpoll 轮询网络:</p>
<ol>
<li>根据传入的 delay 计算 epoll 系统调用需要等待的时间；delay 的单位是纳秒</li>
<li>调用 epollwait 等待可读或者可写事件的发生；</li>
<li>在循环中依次处理 epollevent 事件；将G加入运行队列</li>
</ol>
<p><strong>网络轮询器并不是由运行时中的某一个线程独立运行的，运行时中的调度和系统调用会通过 runtime.netpoll 与网络轮询器交换消息,而系统监控则是专用的线程来等待epoll返回，获取待执行的 Goroutine 列表，并将待执行的 Goroutine 加入运行队列等待处理。所有的文件 I/O、网络 I/O 和计时器都是由网络轮询器管理的</strong></p>
<h2 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h2><p>在支持多任务的操作系统中，守护进程（Daemon）是在后台运行的计算机程序。守护进程不会由用户直接操作，它一般会在操作系统启动时自动运行。Kubernetes 的 DaemonSet 和 Go 语言的系统监控都使用类似设计提供一些通用的功能. 在系统监控内部启动了一个不会中止的循环，在循环的内部会轮询网络、抢占长期运行或者处于系统调用的 Goroutine 以及触发垃圾回收.</p>
<p>当 Go 语言程序启动时，运行时会在第一个 Goroutine 中调用 runtime.main 启动主程序，该函数会在系统栈中创建新的线程.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123; <span class="comment">// webassembly不创建sysmon</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时执行系统监控不需要处理器P，通过系统调用 clone 创建一个新的线程, 系统监控的 Goroutine 会直接在创建的线程M上运行, </p>
<p>系统监控在每次循环开始时都会通过 usleep 挂起当前线程，该函数的参数是微秒，运行时会遵循以下的规则决定休眠时间：</p>
<ol>
<li>初始的休眠时间是 20μs；</li>
<li>最长的休眠时间是 10ms；</li>
<li>当系统监控在 50 个循环中都没有唤醒 Goroutine 时，休眠时间在每个循环都会倍增；</li>
</ol>
<p>当程序趋于稳定之后，系统监控的触发时间就会稳定在 10ms。会在循环中完成以下的工作：</p>
<ul>
<li>检查死锁 </li>
<li>运行计时器 — 获取下一个需要被触发的计时器；</li>
<li>轮询网络 — 获取需要处理的到期文件描述符；</li>
<li>抢占处理器 — 抢占运行时间较长的或者处于系统调用的 Goroutine；</li>
<li>垃圾回收 — 在满足条件时触发垃圾收集回收内存；</li>
</ul>
<p>检查死锁逻辑: </p>
<ol>
<li>收集数据: 存在的M(根据下一个线程id和释放线程数计算)和G数量,空闲的M数量,锁定的M数量,进入系统调用的M数量, P上计时器是否存在. 得到正在运行的M数量</li>
<li>若正在运行的M数量&gt;0则无死锁, 若&lt;0则状态不一致, 若==0则进行进一步判断</li>
<li>若存在 Goroutine 处于 _Grunnable、_Grunning 和 _Gsyscall 状态时，意味着程序发生了死锁；</li>
<li>当所有的 Goroutine 都处于 _Gidle、_Gdead 和 _Gcopystack 状态时，意味着主程序调用了 runtime.goexit；</li>
<li>当存在等待的 Goroutine 并且不存在正在运行的 Goroutine, 若处理器中存在等待的计时器，那么所有的 Goroutine 陷入休眠状态是合理的，不过如果不存在等待的计时器，运行时就会直接报错并退出程序</li>
</ol>
<p>当前调度器需要执行垃圾回收或者所有处理器都处于闲置状态时，如果没有需要触发的计时器，那么系统监控可以暂时陷入休眠.休眠的时间会依据强制 GC 的周期 forcegcperiod 和计时器下次触发的时间确定，runtime.notesleep 会使用信号量同步系统监控即将进入休眠的状态。当系统监控被唤醒之后，我们会重新计算当前时间和下一个计时器需要触发的时间、调用 runtime.noteclear 通知系统监控被唤醒并重置休眠的间隔。如果在这之后，我们发现下一个计时器需要触发的时间小于当前时间，这也就说明所有的线程可能正在忙于运行 Goroutine，系统监控会启动新的线程来触发计时器，避免计时器的到期时间有较大的偏差.</p>
<p>如果上一次轮询网络已经过去了 10ms，那么系统监控还会在循环中轮询网络，检查是否有待执行的文件描述符</p>
<p>系统调用会在循环中调用 runtime.retake 函数抢占处于运行或者系统调用中的处理器，该函数会遍历运行时的全部处理器. 每个处理器都存储了一个 runtime.sysmontick 结构体:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sysmontick <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 分别存储了处理器的调度次数、处理器上次调度时间、系统调用的次数以及系统调用的时间</span></span><br><span class="line">	schedtick   <span class="keyword">uint32</span></span><br><span class="line">	schedwhen   <span class="keyword">int64</span></span><br><span class="line">	syscalltick <span class="keyword">uint32</span></span><br><span class="line">	syscallwhen <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runtime.retake 中的循环包含了两种不同的抢占逻辑:</p>
<ol>
<li><strong>当处理器处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，会通过 runtime.preemptone 通知当前G去停止执行,让出P给其他G；</strong></li>
<li><strong>当处理器处于 _Psyscall(系统调用) 状态时，在满足以下情况下会调用 runtime.handoffp 让出处理器的使用权：处理器的运行队列不为空或者不存在空闲处理器时且系统调用时间超过了 10ms 时；</strong></li>
</ol>
<p>如果需要触发垃圾回收，sysmon会将用于垃圾回收的 Goroutine 加入全局队列，让调度器选择合适的处理器去执行.</p>
<h2 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h2><p>编程语言的内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free-List Allocator）</p>
<ol>
<li>当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置. 有较快的执行速度，以及较低的实现复杂度；但是线性分配器无法在内存被释放时重用内存.线性分配器的使用需要配合具有拷贝特性的垃圾回收算法，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略</li>
<li>空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表. 时间复杂度就是 O(n). 选择策略有: </li>
</ol>
<ul>
<li>首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；</li>
<li>循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；</li>
<li>最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；</li>
<li>隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；</li>
</ul>
<p>Go的分配策略类似隔离适应,将内存分割成由 4、8、16、32 字节的内存块组成的链表, 根据申请大小找到对应的链表查找空闲内存. </p>
<p>线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的的机制，它比 glibc 中的 malloc 函数还要快很多2。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存根据将对象根据大小分类，并按照类别实施不同的分配策略。</p>
<p>Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，<em>运行时根据对象的大小将对象分成微对象、小对象和大对象三种</em>：</p>
<ol>
<li>微对象    (0, 16B)</li>
<li>小对象    [16B, 32KB]</li>
<li>大对象    (32KB, +∞)</li>
</ol>
<p><strong>程序中的绝大多数对象的大小都在 32KB 以下</strong></p>
<p>内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存.</p>
<p><strong>线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，就会使用中心缓存作为补充解决小对象的内存分配问题；在遇到 32KB 以上的对象时，内存分配器就会选择页堆直接分配大量的内存。</strong></p>
<p>Go 语言程序的 1.10 版本在启动时会初始化整片虚拟内存区域，<strong>三个区域 spans、bitmap 和 arena 分别预留了 512MB、16GB 以及 512GB 的虚拟内存空间</strong></p>
<ul>
<li>spans 区域存储了指向内存管理单元 runtime.mspan 的指针，每个内存单元会管理几页的内存空间，每页大小为 8KB；</li>
<li>bitmap 用于标识 arena 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否包含空闲；</li>
<li>arena 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；</li>
</ul>
<p>对于任意一个地址，我们都可以根据 arena 的基地址计算该地址所在的页数并通过 spans 数组获得管理该片内存的管理单元 runtime.mspan，spans 数组中多个连续的位置可能对应同一个 runtime.mspan。</p>
<p>Go 语言在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上一段中介绍的过程找到管理该对象的 runtime.mspan。这些都建立在堆区的内存是连续的这一假设上。这种设计虽然简单并且方便，但是在 C 和 Go 混合使用时会导致程序崩溃:</p>
<ol>
<li>分配的内存地址会发生冲突，导致堆的初始化和扩容失败；</li>
<li>没有被预留的大块内存可能会被分配给 C 语言的二进制，导致扩容后的堆不连续；</li>
</ol>
<p><strong>稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限，还能解决 C 和 Go 混合使用时的地址空间冲突问题。</strong> 不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂.</p>
<p>运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个单元都会管理 64MB 的内存空间.不同平台和架构的二维数组大小可能完全不同，如果我们的 Go 语言服务在 Linux 的 x86-64 架构上运行，二维数组的一维大小会是 1，而二维大小是 4,194,304，因为每一个指针占用 8 字节的内存空间，所以元信息的总大小为 32MB。由于每个 runtime.heapArena 都会管理 64MB 的内存，<em>整个堆区最多可以管理 256TB 的内存</em>，这比之前的 512GB 多好几个数量级。代价是大约会增加 1% 的垃圾回收开销</p>
<p>因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下的四种状态:</p>
<ol>
<li>None    内存没有被保留或者映射，是地址空间的默认状态</li>
<li>Reserved    运行时持有该地址空间，但是访问该内存会导致错误</li>
<li>Prepared    内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 Ready 状态</li>
<li>Ready    可以被安全访问</li>
</ol>
<p><img src="../../../media/qownnotes-media-AxKSRs-232961597.png" alt="qownnotes-media-AxKSRs"></p>
<ul>
<li>runtime.sysAlloc 会从操作系统中获取一大块可用的内存空间，可能为几百 KB 或者几 MB；</li>
<li>runtime.sysFree 会在程序发生内存不足（Out-of Memory，OOM）时调用并无条件地返回内存；</li>
<li>runtime.sysReserve 会保留操作系统中的一片内存区域，对这片内存的访问会触发异常；</li>
<li>runtime.sysMap 保证内存区域可以快速转换至准备就绪；</li>
<li>runtime.sysUsed 通知操作系统应用程序需要使用该内存区域，需要保证内存区域可以安全访问；</li>
<li>runtime.sysUnused 通知操作系统虚拟内存对应的物理内存已经不再需要了，它可以重用物理内存；</li>
<li>runtime.sysFault 将内存区域转换成保留状态，主要用于运行时的调试；</li>
</ul>
<p><img src="../../../media/qownnotes-media-LZFCTM-1064873095.png" alt="qownnotes-media-LZFCTM"></p>
<p>所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会被分配一个线程缓存 runtime.mcache 用于处理微对象和小对象的分配，它们会持有内存管理单元 runtime.mspan。</p>
<p>每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 runtime.mheap 持有的 134 个中心缓存 runtime.mcentral 中获取新的内存单元，中心缓存属于全局的堆结构体 runtime.mheap，它会从操作系统中申请内存。</p>
<p>在 amd64 的 Linux 操作系统上，runtime.mheap 会持有 4,194,304 runtime.heapArena，每一个 runtime.heapArena 都会管理 64MB 的内存，<strong>单个 Go 语言程序的内存上限也就是 256TB</strong>。</p>
<p>runtime.mspan 是 Go 语言内存管理的基本单元,串联后形成双向链表. 每个 runtime.mspan 都管理 npages 个大小为 8KB 的页，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍</p>
<p>运行时会使用 runtime.mSpanStateBox 结构体存储内存管理单元的状态 runtime.mSpanState:<br>该状态可能处于 mSpanDead、mSpanInUse、mSpanManual 和 mSpanFree 四种情况。当 runtime.mspan 在空闲堆中，它会处于 mSpanFree 状态；当 runtime.mspan 已经被分配时，它会处于 mSpanInUse、mSpanManual 状态，这些状态会在遵循以下规则发生转换：</p>
<ul>
<li>在垃圾回收的任意阶段，可能从 mSpanFree 转换到 mSpanInUse 和 mSpanManual；</li>
<li>在垃圾回收的清除阶段，可能从 mSpanInUse 和 mSpanManual 转换到 mSpanFree；</li>
<li>在垃圾回收的标记阶段，不能从 mSpanInUse 和 mSpanManual 转换到 mSpanFree；</li>
</ul>
<p>设置 runtime.mspan 结构体状态的读写操作必须是原子性的避免垃圾回收造成的线程竞争问题。</p>
<p><strong>Go 语言的内存管理模块中一共包含 67 种跨度类, 每个类决定了内存管理单元中存储的对象大小和个数.</strong><br>运行时中还包含 ID 为 0 的特殊跨度类，它能够管理大于 32KB 的特殊对象</p>
<p>runtime.mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。<strong>每一个线程缓存都持有 67 * 2 个 runtime.mspan</strong>，这些内存管理单元都存储在结构体的 alloc 字段中</p>
<p>访问中心缓存中的内存管理单元需要使用互斥锁</p>
<p><strong>微对象 (0, 16B) — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；</strong><br><strong>小对象 [16B, 32KB] — 依次尝试使用线程缓存、中心缓存和堆分配内存；</strong><br><strong>大对象 (32KB, +∞) — 直接在堆上分配内存；</strong></p>
<p><strong>微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收</strong><br><strong>微分配器管理的对象不可以是指针类型，</strong></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>三色标记:</p>
<ul>
<li>白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；</li>
<li>黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li>
<li>灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li>
</ul>
<p>根是灰色, 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；<br>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；<br>重复上述两个步骤直到对象图中不存在灰色对象；之后垃圾收集器可以回收这些白色的垃圾.</p>
<p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的任意一种：</p>
<ul>
<li>强三色不变性 — <strong>黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</strong></li>
<li>弱三色不变性 — <strong>黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；</strong></li>
</ul>
<p>Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障(保证强三色不变性,有存活可能的对象都标记成灰色)和 Yuasa 提出的删除写屏障</p>
<p><strong>Go 语言运行时的默认配置会在堆内存达到上一次垃圾收集的 2 倍时，触发新一轮的垃圾收集，这个行为可以通过环境变量 GOGC 调整，在默认情况下它的值为 100，即增长 100% 的堆内存才会触发 GC</strong></p>
<p>因为并发垃圾收集器会与程序一起运行，所以它无法准确的控制堆内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存大小的可控. 垃圾收集调步算法是跟随 v1.5 一同引入的，该算法的目标是优化堆的增长速度和垃圾收集器的 CPU 利用率，而在 v1.10 版本中又对该算法进行了优化，将原有的目的堆大小拆分成了软硬两个目标</p>
<p>垃圾收集的根对象一般包括全局变量和栈对象. </p>
<p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色, 在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收</p>
<p>GO使用使用三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制将垃圾收集的暂停时间优化至毫秒级以下</p>
<p>垃圾收集的多个阶段过程:</p>
<ol>
<li>清理终止阶段；<ol>
<li>暂停程序，所有的处理器在这时会进入安全点（Safe point）；</li>
<li>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；</li>
</ol>
</li>
<li>标记阶段；<ol>
<li>将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；</li>
<li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象(栈+堆)都会被直接标记成黑色；</li>
<li>开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；</li>
<li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；</li>
<li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；</li>
</ol>
</li>
<li>标记终止阶段；<ol>
<li>暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；</li>
<li>清理处理器上的线程缓存;</li>
</ol>
</li>
<li>清理阶段；<ol>
<li>将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；</li>
<li>恢复用户程序，所有新创建的对象会标记成白色；</li>
<li>后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理(惰性清除)；</li>
</ol>
</li>
</ol>
<h2 id="栈内存管理"><a href="#栈内存管理" class="headerlink" title="栈内存管理"></a>栈内存管理</h2><p>栈寄存器在是 CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈，Go 语言的汇编代码中包含 BP 和 SP 两个栈寄存器，它们分别存储了栈的基址指针和栈顶的地址. BP 和 SP 之间的内存就是当前函数的调用栈.(栈向下增长, 栈区内存都是从高地址向低地址扩展的). 申请或者释放栈内存时只需要修改 SP 寄存器的值.</p>
<p>不同cpu架构的线程默认栈大小不同, <strong>linux x86_64是2MB</strong>, RLIMIT_STACK的系统参数可以修改线程栈大小.</p>
<p><em>线程和进程都是代码执行的上下文（Context of Execution）.</em></p>
<p>在 C 语言中，栈上的变量被函数作为返回值返回给调用方是一个常见的错误. 即需要分配到堆上的对象分配到了栈上 , 导致了悬挂指针. </p>
<p>在编译器优化中，逃逸分析（Escape analysis）是用来决定指针动态作用域的方法。Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 new、make 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：</p>
<ol>
<li><strong>指向栈对象的指针不能存在于堆中；</strong></li>
<li><strong>指向栈对象的指针不能在栈对象回收后存活；</strong></li>
</ol>
<p>通过以下几个步骤实现静态分析的全过程：</p>
<ol>
<li>构建带权重的有向图，其中顶点 cmd/compile/internal/gc.EscLocation 表示被分配的变量，边 cmd/compile/internal/gc.EscEdge 表示变量之间的分配关系，权重表示寻址和取地址的次数；</li>
<li>遍历对象分配图并查找违反两条不变性的变量分配关系，如果堆上的变量指向了栈上的变量，那么栈上的变量就需要分配在堆上；</li>
<li>记录从函数的调用参数到堆以及返回值的数据流，增强函数参数的逃逸分析；</li>
</ol>
<p>为了保证内存的绝对安全，编译器可能会将一些变量错误地分配到堆上，但是因为这些对也会被垃圾收集器处理，所以不会造成内存泄露以及悬挂指针等安全问题</p>
<p><em>GO在1.3实现连续栈以后在1.4中将初始栈大小降为 2KB.</em></p>
<p>分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：</p>
<ol>
<li>如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）；</li>
<li>一旦 Goroutine 使用的内存越过了分段栈的扩缩容阈值，运行时就会触发栈的扩容和缩容，带来额外的工作量；</li>
</ol>
<p>连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：</p>
<ol>
<li>内存空间中分配更大的栈内存空间；</li>
<li>将旧栈中的所有内容复制到新的栈中；</li>
<li>将指向旧栈对应变量的指针重新指向新栈； 由于指向栈对象的指针不能存在于堆中，所以指向栈中变量的指针只能在栈上，只需要调整栈中的所有变量就可以保证内存的安全</li>
<li>销毁并回收旧栈的内存空间；</li>
</ol>
<p>因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，通过<em>在 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容.</em> 这一机制来减少扩/缩容的次数.</p>
<p><strong>我们可以认为 Go 语言的Goroutine栈内存都是分配在线程堆上的</strong></p>
<p>从调度器和内存分配的经验来看，如果运行时只使用全局变量来分配内存的话，势必会造成线程之间的锁竞争进而影响程序的执行效率，栈内存由于与线程关系比较密切，所以我们在每一个线程缓存 runtime.mcache 中都加入了栈缓存减少锁竞争影响。</p>
<p>运行时使用全局的 runtime.stackpool 和线程缓存中的空闲链表分配 32KB 以下的栈内存，使用全局的 runtime.stackLarge 和堆内存分配 32KB 以上的栈内存，提高本地分配栈内存的性能。</p>
<p>G的栈分配:</p>
<ol>
<li>如果栈空间较小，使用全局栈缓存或者线程缓存上固定大小的空闲链表分配内存；</li>
<li>如果栈空间较大，从全局的大栈缓存 runtime.stackLarge 中获取内存空间；</li>
<li>如果栈空间较大并且 runtime.stackLarge 空间不足，在堆上申请一片大小足够内存空间；</li>
</ol>
<p>编译器会在 cmd/internal/obj/x86.stacksplit 函数中为函数调用插入 runtime.morestack 运行时检查，它会在几乎所有的函数调用之前检查当前 Goroutine 的栈内存是否充足，如果当前栈需要扩容，我们会保存一些栈的相关信息并调用 runtime.newstack 检查是否需要被抢占调度并创建新的栈</p>
<p><strong>如果要触发栈的缩容，新栈的大小会是原始栈的一半，不过如果新栈的大小低于程序的最低限制 2KB，那么缩容的过程就会停止。运行时只会在栈内存使用不足 1/4 时进行缩容</strong> – 减少频繁缩栈</p>
<h2 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h2><p>Linux 中的共享对象会使用 ELF 格式并提供了一组操作动态链接器的接口:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br><span class="line"><span class="comment">// dlopen函数会根据传入的文件名加载对应的动态库并返回一个句柄（Handle）；我们可以直接使用 dlsym 函数在该句柄中搜索特定的符号，也就是函数或者变量，它会返回该符号被加载到内存中的地址。因为待查找的符号可能不存在于目标动态库中，所以在每次查找后我们都应该调用 dlerror 查看当前查找的结果</span></span><br></pre></td></tr></table></figure>

<p>插件是一个带有公开函数和变量的 main 包，我们需要使用如下所示的命令编译插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -buildmode=plugin ...</span><br></pre></td></tr></table></figure>
<p>该命令会生成一个共享对象 .so 文件. 当该文件被加载到 Go 语言程序时会使用下面的结构体 plugin.Plugin 表示，该结构体中包含文件的路径以及包含的符号等信息:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">	pluginpath <span class="keyword">string</span></span><br><span class="line">	syms       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin包中使用的两个 C 语言函数 pluginOpen 和 pluginLookup；pluginOpen 只是简单包装了一下C标准库中的 dlopen 和 dlerror 函数并在加载成功后返回指向动态库的句柄. 这让它们的函数签名看起来更像是 Go 语言中的函数签名，方便在 Go 语言中调用.</p>
<p>Open操作会执行以下步骤:</p>
<ol>
<li>准备 C 语言函数 pluginOpen 的参数；</li>
<li>通过 cgo 调用 C 语言函数 pluginOpen 并初始化加载的模块；</li>
<li>查找加载模块中的 init 函数并调用该函数；</li>
<li>通过插件的文件名和符号列表构建 plugin.Plugin 结构体并返回；</li>
</ol>
<p>Lookup方法在Open的返回中查找符号Symbol,其是interface{}的别名,可以将其转换为变量或函数.</p>
<p><em>使用plugin时，plugin经常要和主程序同时（更确切的说是同一环境下）build才行。如果主程序有改动或者build的路径更换，plugin不同时更新的话，加载plugin时就会报某个package版本错误的问题，导致加载失败。</em></p>
<p><em>工程上的很多决定就是以 Benchmark 为导向的，设定一个测试用例，然后尽可能地提高效率，当然用例到最后也只是一个参考, 所以测试用例的覆盖和模拟准确度很重要.</em> </p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>图灵完备的一个重要特性是计算机程序可以生成另一个程序. <em>Go 语言中的测试就使用了代码生成机制，go test 命令会扫描包中的测试用例并生成程序、编译并执行它们</em></p>
<p>元编程(Metaprogramming)是一种编程技术，在这种技术中，计算机程序能够将程序视为它们的数据。元编程其实是一种使用代码生成代码的方式，无论是编译期间生成代码，还是在运行时改变代码的行为都是其一种.</p>
<p>Go 语言的代码生成机制会读取包含预编译指令的注释，然后执行注释中的命令读取包中的文件，它们将文件解析成抽象语法树并根据语法树生成新的 Go 语言代码和文件，生成的代码会在项目的编译期间与其他代码一起编译和运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate command argument...</span></span><br></pre></td></tr></table></figure>
<p><strong>go generate 不会被 go build 等命令自动执行</strong>，该命令需要显式的触发，手动执行该命令时会在文件中扫描上述形式的注释并执行后面的执行命令，需要注意的是 go:generate 和前面的 // 之间没有空格，这种不包含空格的注释一般是 Go 语言的编译器指令，而我们<strong>在代码中的正常注释都应该保留这个空格</strong></p>
<p>官方案例:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pill.go</span></span><br><span class="line"><span class="keyword">package</span> painkiller</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate stringer -type=Pill</span></span><br><span class="line"><span class="keyword">type</span> Pill <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Placebo Pill = <span class="literal">iota</span></span><br><span class="line">	Aspirin</span><br><span class="line">	Ibuprofen</span><br><span class="line">	Paracetamol</span><br><span class="line">	Acetaminophen = Paracetamol</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>调用 <code>go generate</code> 命令后生成<code>pill_string.go</code>文件:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by "stringer -type=Pill"; DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> painkiller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="params">()</span></span> &#123; <span class="comment">// 生成一个签名为 _ 的函数，通过编译器保证枚举类型的值不会改变</span></span><br><span class="line">	<span class="comment">// An "invalid array index" compiler error signifies that the constant values have changed.</span></span><br><span class="line">	<span class="comment">// Re-run the stringer command to generate them again.</span></span><br><span class="line">	<span class="keyword">var</span> x [<span class="number">1</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	_ = x[Placebo<span class="number">-0</span>]</span><br><span class="line">	_ = x[Aspirin<span class="number">-1</span>]</span><br><span class="line">	_ = x[Ibuprofen<span class="number">-2</span>]</span><br><span class="line">	_ = x[Paracetamol<span class="number">-3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里重点学习这种节省空间的定义方法,通过同一个底层字符串来优化数据获取效率.</span></span><br><span class="line"><span class="keyword">const</span> _Pill_name = <span class="string">"PlaceboAspirinIbuprofenParacetamol"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _Pill_index = [...]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">23</span>, <span class="number">34</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Pill)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= Pill(<span class="built_in">len</span>(_Pill_index)<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Pill("</span> + strconv.FormatInt(<span class="keyword">int64</span>(i), <span class="number">10</span>) + <span class="string">")"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _Pill_name[_Pill_index[i]:_Pill_index[i+<span class="number">1</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比另一个实现,可见其主要是使用了查表法的思想.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pill)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> p &#123;</span><br><span class="line">    <span class="keyword">case</span> Placebo:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Placebo"</span></span><br><span class="line">    <span class="keyword">case</span> Aspirin:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Aspirin"</span></span><br><span class="line">    <span class="keyword">case</span> Ibuprofen:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Ibuprofen"</span></span><br><span class="line">    <span class="keyword">case</span> Paracetamol: <span class="comment">// == Acetaminophen</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Paracetamol"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Pill(%d)"</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可参考<a href="https://blog.golang.org/generate" target="_blank" rel="noopener">blog</a>  stringer的<a href="https://github.com/golang/tools/blob/d1954cc86c824f62dd7845fadb8b09b089425026/cmd/stringer/stringer.go" target="_blank" rel="noopener">代码实现</a></p>
<h2 id="JSON标准库"><a href="#JSON标准库" class="headerlink" title="JSON标准库"></a>JSON标准库</h2><p>Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性. </p>
<p>Go 语言的字段一般都是驼峰命名法，JSON 中下划线的命名方式相对比较常见. 使用标签这一特性直接建立键与字段之间的映射关系.</p>
<p>常见的两个标签是 string 和 omitempty，前者表示当前的整数或者浮点数是由 JSON 中的字符串表示的，而另一个字段 omitempty 会在字段为零值时，直接在生成的 JSON 中忽略对应的键值对.</p>
<p>编/解码中会依次递归的尝试判断数据的类型种类,并在成功时返回,即一个个试看到底是哪种数据.</p>
<p>无论是序列化还是反序列化，都会遵循自顶向下的编码和解码过程，使用递归的方式处理 JSON 对象</p>
<p><strong>JSON 的标准里其实只有 number 类型，float64 是 Go 做的统一转换，如果想转回 int 类型需要用 struct 给标准库一个提示用于反序列化</strong></p>
<h2 id="HTTP标准库"><a href="#HTTP标准库" class="headerlink" title="HTTP标准库"></a>HTTP标准库</h2><p>HTTP/3 在 UDP 协议上实现了新的传输层协议 QUIC 并使用 QUIC 传输数据，这也意味着 HTTP 既可以跑在 TCP 上，也可以跑在 UDP 上</p>
<p>作为文本传输协议，HTTP 协议的协议头都是文本数据，HTTP 请求头的首行会包含请求的方法、路径和协议版本，接下来是多个 HTTP 协议头以及携带的负载:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span><br><span class="line"><span class="attribute">Host</span>: draveness.me</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-us</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Content-Length</span>: &lt;length&gt;</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机。因为 TCP 协议是基于字节流的，所以基于 TCP 协议的应用层协议都需要自己划分消息的边界.在应用层协议中，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）。HTTP 协议其实同时实现了上述两种方案，在多数情况下 HTTP 协议都会在协议头中加入 Content-Length 表示负载的长度，消息的接收者解析到该协议头之后就可以确定当前 HTTP 请求/响应结束的位置，分离不同的 HTTP 消息. 当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界.</p>
<p>客户端 net/http.Client 是级别较高的抽象，它提供了 HTTP 的一些细节，包括 Cookies 和重定向；而 net/http.Transport 结构体会处理 HTTP/HTTPS 协议的底层实现细节，其中会包含连接重用、构建请求以及发送请求等功能.</p>
<p>Http客户端请求会使用连接池获取和初始化连接. TCP连接是四元组唯一(目的IP:目的端口:源IP:源端口), 相同的四元组的连接可以被复用的.</p>
<p>我们可以在标准库的 net/http.Transport 中调用 net/http.Transport.RegisterProtocol 方法为不同的协议注册 net/http.RoundTripper 的实现</p>
<p>服务路由URL与处理逻辑通过哈希映射, HTTP 服务器在处理请求时就会使用该哈希查找处理器</p>
<p>如果当前 HTTP 服务接收到了海量的请求，会在内部创建大量的 Goroutine，这可能会使整个服务质量明显降低无法处理请求.</p>
<h2 id="数据库标准库"><a href="#数据库标准库" class="headerlink" title="数据库标准库"></a>数据库标准库</h2><p>Go 语言的标准库 database/sql 就为访问关系型数据提供了通用的接口，这样不同数据库只要实现标准库中的接口，应用程序就可以通过标准库中的方法访问</p>
<p>结构化查询语言（Structured Query Language、SQL）是在关系型数据库系统中使用的领域特定语言（Domain-Specific Language、DSL）</p>
<p>所有关系型数据库都需要实现的驱动接口:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">	Open(name <span class="keyword">string</span>) (Conn, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">	Prepare(query <span class="keyword">string</span>) (Stmt, error)</span><br><span class="line">	Close() error</span><br><span class="line">	Begin() (Tx, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> database/sql.Register 方法可以注册自定义的数据库驱动, MySQL 驱动会在 init 中调用上述方法将实现 database/sql/driver.Driver 接口的结构体注册到全局的驱动列表中. 之后通过驱动名获得结构体. 结构体 database/sql.DB 在刚刚初始化时不会包含任何的数据库连接，它持有的数据库连接池会在真正应用程序申请连接时在单独的 Goroutine 中获取</p>
<p>Go的sql库是面向接口编程思想的体现 —— 只依赖抽象的接口，不要依赖具体的实现</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>取余操作&amp;#37的优化</title>
    <url>/2020/09/16/%E5%8F%96%E4%BD%99%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="取余操作的优化"><a href="#取余操作的优化" class="headerlink" title="取余操作的优化"></a>取余操作的优化</h1><p><code>a%b</code> 这个取余操作据说会比较慢, 如果这个b刚好是2的n次方, 那么有一种优化方式是使用 <code>a &amp; (2^n-1)</code><br>也就是说 <code>a &amp; (b -1)</code> 因为 <code>a = x * b + y(余数)</code>, 那么 <code>a</code> 和 <code>b-1</code>(低位每位都是1) 取&amp; 就是获得了 y的值. </p>
<p>具体这个方式能快多少? 测了就知道:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doPercent</span><span class="params">(n <span class="keyword">int</span>, divisor <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n % divisor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAnd</span><span class="params">(n <span class="keyword">int</span>, divisor <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n &amp; (divisor <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMod</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	testCase := []<span class="keyword">struct</span>&#123;</span><br><span class="line">		N <span class="keyword">int</span></span><br><span class="line">		Div <span class="keyword">int</span></span><br><span class="line">		Expect <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">4</span>,</span><br><span class="line">			Div: <span class="number">2</span>,</span><br><span class="line">			Expect: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">15</span>,</span><br><span class="line">			Div: <span class="number">8</span>,</span><br><span class="line">			Expect: <span class="number">7</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">5</span>,</span><br><span class="line">			Div: <span class="number">8</span>,</span><br><span class="line">			Expect: <span class="number">5</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">5</span>,</span><br><span class="line">			Div: <span class="number">1</span>,</span><br><span class="line">			Expect: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">0</span>,</span><br><span class="line">			Div: <span class="number">2</span>,</span><br><span class="line">			Expect: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">1</span>&lt;&lt;<span class="number">31</span>,</span><br><span class="line">			Div: <span class="number">1</span>&lt;&lt;<span class="number">30</span>,</span><br><span class="line">			Expect: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c  := <span class="keyword">range</span> testCase &#123;</span><br><span class="line">		t.Run(fmt.Sprintf(<span class="string">"n: %v, div: %v, expect: %v"</span>, c.N, c.Div,c.Expect), <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">			assert.Equal(t, c.Expect, doPercent(c.N,c.Div))</span><br><span class="line">			assert.Equal(t, c.Expect, doAnd(c.N,c.Div))</span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMod</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	testCase := []<span class="keyword">struct</span>&#123;</span><br><span class="line">		N <span class="keyword">int</span></span><br><span class="line">		Div <span class="keyword">int</span></span><br><span class="line">		Expect <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">4</span>,</span><br><span class="line">			Div: <span class="number">2</span>,</span><br><span class="line">			Expect: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">15</span>,</span><br><span class="line">			Div: <span class="number">8</span>,</span><br><span class="line">			Expect: <span class="number">7</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">1</span>&lt;&lt;<span class="number">13</span>+ <span class="number">1</span>&lt;&lt; <span class="number">10</span> + <span class="number">12345</span>,</span><br><span class="line">			Div: <span class="number">8</span>,</span><br><span class="line">			Expect: <span class="number">7</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			N: <span class="number">1</span>&lt;&lt;<span class="number">30</span> + <span class="number">13</span>,</span><br><span class="line">			Div: <span class="number">1</span>&lt;&lt;<span class="number">16</span>,</span><br><span class="line">			Expect: <span class="number">0</span>,</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> testCase &#123;</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"test do percent with n: %v, div: %v"</span>,c.N,c.Div),<span class="function"><span class="keyword">func</span> <span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">				doPercent(c.N,c.Div)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"test do and with n: %v, div: %v"</span>,c.N,c.Div),<span class="function"><span class="keyword">func</span> <span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">				doAnd(c.N,c.Div)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>benchmark结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: test</span><br><span class="line">BenchmarkMod&#x2F;test_do_percent_with_n:_4,_div:_2-8         	984819216	         1.18 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_and_with_n:_4,_div:_2-8             	1000000000	         0.592 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_percent_with_n:_15,_div:_8-8        	876655876	         1.21 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_and_with_n:_15,_div:_8-8            	1000000000	         0.665 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_percent_with_n:_21561,_div:_8-8     	1000000000	         1.21 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_and_with_n:_21561,_div:_8-8         	1000000000	         0.574 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_percent_with_n:_1073741837,_div:_65536-8         	1000000000	         1.21 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkMod&#x2F;test_do_and_with_n:_1073741837,_div:_65536-8             	1000000000	         0.620 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok  	test	7.878s</span><br></pre></td></tr></table></figure>

<p>可见效率吊打使用%啊! 性能优化真的是与算法关系+系统体系结构关系太大了. </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程与尾调用学习</title>
    <url>/2020/09/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%B0%BE%E8%B0%83%E7%94%A8%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="函数式编程与尾调用-学习"><a href="#函数式编程与尾调用-学习" class="headerlink" title="函数式编程与尾调用 学习"></a>函数式编程与尾调用 学习</h1><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程: 函数式编程最常见的技术就是对一个集合做Map、Reduce和Filter操作，map对集合成员做了映射操作，生成新的集合；reduce就是降维操作，化整为零；filter顾名思义通过过滤器生成新的集合。</p>
<p>其特点是把函数当成变量来用.</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归算法在使用栈（stack，先进后出）来执行数据操作的时候是非常方便的，它比循环操作更快，并且代码的简洁性好。</p>
<p>递归带来的效率问题主要是函数调用带来的额外开销（函数的入栈出栈），以及栈容量的限制（次数太多可能会stack overflow）</p>
<h4 id="递归算法："><a href="#递归算法：" class="headerlink" title="递归算法："></a>递归算法：</h4><p>优点：代码简洁、清晰，并且容易验证正确性。（如果你真的理解了算法的话，否则你更晕）<br>缺点：它的运行需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理（还有可能出现堆栈溢出的情况），比如参数传递需要压栈等操作，会对执行效率有一定影响。但是，对于某些问题，如果不使用递归，那将是极端难看的代码。</p>
<h4 id="循环算法："><a href="#循环算法：" class="headerlink" title="循环算法："></a>循环算法：</h4><p>优点：速度快，结构简单。<br>缺点：并不能解决所有的问题。有的问题适合使用递归而不是循环。如果使用循环并不困难的话，最好使用循环。</p>
<p>系统栈（也叫核心栈、内核栈）是内存中属于操作系统空间的一块区域，其主要用途为： (1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出； (2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。<br>用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。<br>我们编写的递归程序属于用户程序，因此使用的是用户栈。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>也就是把接受多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数而且返回结果的新方法。将多参数的函数转换成单参数的形式</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incx</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> incx</span><br><span class="line"> </span><br><span class="line">inc2 = inc(<span class="number">2</span>)</span><br><span class="line">inc5 = inc(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> inc2(<span class="number">5</span>) <span class="comment"># 输出 7</span></span><br><span class="line"><span class="keyword">print</span> inc5(<span class="number">5</span>) <span class="comment"># 输出 10</span></span><br></pre></td></tr></table></figure>

<h2 id="尾调用-尾递归"><a href="#尾调用-尾递归" class="headerlink" title="尾调用/尾递归"></a>尾调用/尾递归</h2><p>某个函数的最后一步是调用另一个函数,这就是尾调用.</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，<strong>只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。</strong> 这就是”<strong>尾调用优化</strong>“的意义。</p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 如果其递归函数的第一个参数是需要返回的计算结果或者是中间变量.</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用for循环执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorialFor</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res = res * i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归, 内存占用O(n) 因为需要保存n个调用记录(中间结果)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归, 理论上内存占用 O(1) 只需要保留一个调用记录, 实际上到go1.13都没有进行优化, 依旧是O(n) , 测试执行会比上面的快一点, 是因为函数调用尾递归调用中在管理stack frames上开销小一点. </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n,total <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="keyword">return</span> total&#125;</span><br><span class="line">    <span class="keyword">return</span> factorial(n<span class="number">-1</span>, n*total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 测试结果:</span><br><span class="line">BenchmarkTailRecursive/For:-8         	68877586	        17.0 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkTailRecursive/Rec:-8         	10000900	       119 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkTailRecursive/Tail:-8        	11536790	       102 ns/op	       0 B/op	       0 allocs/op</span><br></pre></td></tr></table></figure>
<p>似乎for循环更快. 因为减少了递归调用的压栈/出栈操作和函数调用的开销. </p>
<p><strong>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数</strong> </p>
<p>可用通过外层再包装一层函数来隐藏尾递归优化的多出来的参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorial(n, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过柯里化来做:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">currying</span><span class="params">(fn <span class="keyword">func</span>, total <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(fn <span class="keyword">func</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(n,total)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Factorial = currying(factorial,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用: Factorial(5)</span></span><br></pre></td></tr></table></figure>
<p>当然如果像python那样支持默认参数值的,就可以通过默认参数设置默认值隐藏第二个参数了.</p>
<h2 id="go的尾调用-tail-calls-优化"><a href="#go的尾调用-tail-calls-优化" class="headerlink" title="go的尾调用(tail calls)优化"></a>go的尾调用(tail calls)优化</h2><p>当你要使用递归的时候，你需要意识到栈内存是一直增加的，直到遇到你设置好的 anchor 时，它的内存才开始下降。当我们说 Go 并没有优化递归操作时，我们需要承认一个事实，<strong>Go 并没有尝试着去优化栈内存无限增加这一操作, Go 没有 tail calls 进行任何优化, 调用栈并没有销毁。</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过chan去模拟尾递归, 这个调用栈会被优化, 因为每个goroutine执行完就返回了, 其会被销毁.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecursiveChannel</span><span class="params">(number <span class="keyword">int</span>, product <span class="keyword">int</span>, result <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    product = product + number</span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span> &#123;</span><br><span class="line">        result &lt;- product</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Go RecursiveChannel(number<span class="number">-1</span>, product, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">汇编:</span><br><span class="line">— prog list <span class="string">"TailRecursive"</span> —</span><br><span class="line"><span class="number">0018</span> (./main.<span class="keyword">go</span>:<span class="number">17</span>) TEXT TailRecursive+<span class="number">0</span>(SB),$<span class="number">24</span><span class="number">-24</span></span><br><span class="line"></span><br><span class="line"><span class="number">0019</span> (./main.<span class="keyword">go</span>:<span class="number">17</span>) MOVQ number+<span class="number">0</span>(FP),CX</span><br><span class="line"></span><br><span class="line"><span class="number">0020</span> (./main.<span class="keyword">go</span>:<span class="number">17</span>) LOCALS ,$<span class="number">0</span></span><br><span class="line"><span class="number">0021</span> (./main.<span class="keyword">go</span>:<span class="number">17</span>) TYPE number+<span class="number">0</span>(FP)&#123;<span class="keyword">int</span>&#125;,$<span class="number">8</span></span><br><span class="line"><span class="number">0022</span> (./main.<span class="keyword">go</span>:<span class="number">17</span>) TYPE product+<span class="number">8</span>(FP)&#123;<span class="keyword">int</span>&#125;,$<span class="number">8</span></span><br><span class="line"><span class="number">0023</span> (./main.<span class="keyword">go</span>:<span class="number">17</span>) TYPE ~anon2+<span class="number">16</span>(FP)&#123;<span class="keyword">int</span>&#125;,$<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">0024</span> (./main.<span class="keyword">go</span>:<span class="number">19</span>) MOVQ product+<span class="number">8</span>(FP),AX</span><br><span class="line"><span class="number">0025</span> (./main.<span class="keyword">go</span>:<span class="number">19</span>) ADDQ CX,AX</span><br><span class="line"></span><br><span class="line"><span class="number">0026</span> (./main.<span class="keyword">go</span>:<span class="number">21</span>) CMPQ CX,$<span class="number">1</span></span><br><span class="line"><span class="number">0027</span> (./main.<span class="keyword">go</span>:<span class="number">21</span>) JNE ,<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="number">0028</span> (./main.<span class="keyword">go</span>:<span class="number">23</span>) MOVQ AX,~anon2+<span class="number">16</span>(FP)</span><br><span class="line"><span class="number">0029</span> (./main.<span class="keyword">go</span>:<span class="number">23</span>) RET ,</span><br><span class="line"></span><br><span class="line"><span class="number">0030</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) MOVQ CX,BX</span><br><span class="line"><span class="number">0031</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) DECQ ,BX</span><br><span class="line"></span><br><span class="line"><span class="number">0032</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) MOVQ BX,(SP)</span><br><span class="line"><span class="number">0033</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) MOVQ AX,<span class="number">8</span>(SP) <span class="comment">// 依旧不断地把参数压栈, 并未重复利用栈返回</span></span><br><span class="line"><span class="number">0034</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) CALL ,TailRecursive+<span class="number">0</span>(SB)</span><br><span class="line"></span><br><span class="line"><span class="number">0035</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) MOVQ <span class="number">16</span>(SP),BX</span><br><span class="line"></span><br><span class="line"><span class="number">0036</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) MOVQ BX,~anon2+<span class="number">16</span>(FP)</span><br><span class="line"><span class="number">0037</span> (./main.<span class="keyword">go</span>:<span class="number">26</span>) RET ,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    RecursiveChannel(<span class="number">4</span>, <span class="number">0</span>, result)</span><br><span class="line">    answer := &lt;-result</span><br><span class="line">    fmt.Printf(<span class="string">"Recursive: %d\n"</span>, answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="幂等性-纯函数"><a href="#幂等性-纯函数" class="headerlink" title="幂等性(纯函数)"></a>幂等性(纯函数)</h2><p>在学习这种编程思想的时候, 发现有一种代码书写理念很有意义: <strong>尽可能地将输入/输出数据的控制权交给调用者, 尽量避免在执行者内部创建输入/输出数据. 代码本身只执行功能, 不影响输入输出, 确保功能方法是幂等的</strong> </p>
<p>在计算机程序中，如果一个函数满足下面的几个条件，那么这个函数就是一个纯函数：</p>
<ol>
<li>这个函数在相同的参数下一定会产生相同的结果。即函数的返回值不依赖于任何隐藏在函数内的信息或者状态，而这些隐藏的内容在程序的运行期还可能会变化。且函数不应依赖于任何从 I/O 设备中输入的信息。</li>
<li>对函数的返回结果进行操作不会引起任何语义上的副作用或者输出，比如导致可变对象的变化或者输出数据到 I/O 设备去。</li>
</ol>
<p>例如下面的代码test的方法就不够好, 这个方法在内部创建的一个数组并把这个数组返回输出给调用者. 这样就违反了上面的理念: 使用相同的a多次调用test返回的slice切片不是同一个slice. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    b:= <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(a))</span><br><span class="line">    <span class="keyword">for</span> k,v:=<span class="keyword">range</span> a&#123;</span><br><span class="line">        b[k] = v*<span class="number">3</span>+<span class="number">34</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们可以通过改写这个方法:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(in []<span class="keyword">int</span>, out []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> k,v:=<span class="keyword">range</span> in&#123;</span><br><span class="line">        out[k] = v*<span class="number">3</span>+<span class="number">34</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 test的调用者负责创建这个out的数组. 那如果传递的参数不是指针或slice/map/chan结构该怎么做?我个人理解这种情况要么改成传递指针, 要么干脆就违反幂等, 因为导出是指针真的就有点丑且容易出错了..</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂等的写法容易出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(in <span class="keyword">int</span>, out *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    (*out) = in * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常的写法更不容易出错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(in <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> in * <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数是数据"><a href="#函数是数据" class="headerlink" title="函数是数据"></a>函数是数据</h2><p>把函数看作是一种数据类型使用, 这种思想就是数学上的变量方程的一种提现, 比如: <code>f(x) = f(x-1) + 2</code>这样的递推式. 使用这种思想, 可以很好的契合递归调用的思路. 利用计算机中的栈的天然递归特性, 来高效的完成方程式的求解. 在go实际开发中, 一个很好的应用例子就是配置参数的初始化与默认值设置. 这样的好处是由调用者自己控制使用什么,不用什么,设置什么, 如果没有设置也会有默认值,并且在增加变动配置项的时候不再需要去改动原有的代码逻辑(startServer不需要修改), 保持了代码的可扩展性和最小变化性. </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	startServer(</span><br><span class="line">		WithPort(<span class="number">8080</span>),</span><br><span class="line">		WithTimeout(<span class="number">1</span> * time.Second),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	port    <span class="keyword">int</span></span><br><span class="line">	timeout time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerOpt <span class="function"><span class="keyword">func</span><span class="params">(*Config)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPort</span><span class="params">(port <span class="keyword">int</span>)</span> <span class="title">ServerOpt</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *Config)</span></span> &#123;</span><br><span class="line">		cfg.port = port</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(timeout time.Duration)</span> <span class="title">ServerOpt</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(cfg *Config)</span></span> &#123;</span><br><span class="line">		cfg.timeout = timeout</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(opts ...ServerOpt)</span></span> &#123;</span><br><span class="line">	cfg := &amp;Config&#123;</span><br><span class="line">	    port : <span class="number">80</span>,</span><br><span class="line">	    timeout: <span class="number">300</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, fn := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		fn(cfg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式应用思考"><a href="#函数式应用思考" class="headerlink" title="函数式应用思考"></a>函数式应用思考</h2><p>在对数组进行遍历处理的时候,我们可以考虑多种方法:</p>
<ol>
<li>使用递推/尾递归的方式,虽然这样效率慢很多,go也没有进行尾递归优化, 但是却充分提现了函数式的思想, 将需要的输出数据由调用者控制.</li>
<li>使用遍历的方式</li>
<li>使用数学函数递推公式的方式<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum1</span><span class="params">(x <span class="keyword">int</span> ,a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> sum1(x+a[<span class="number">0</span>], a[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum1</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    f:= <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> sum1(<span class="number">0</span>,a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递推, 上面的sum1就比下面的sum2好, 因为下面的不满足尾递归的形式, 不能充分进行尾递归优化来减少调用栈.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(x <span class="keyword">int</span>, a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> x + sum2(a[<span class="number">0</span>], a[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum2</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sum2(<span class="number">0</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum3</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, v:=<span class="keyword">range</span> a&#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数学函数递推公式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum4</span><span class="params">(x *<span class="keyword">int</span>, a []<span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(x *<span class="keyword">int</span>, a[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    (*x) = (*x) + a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> sum4(x,a[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum4</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    sum4(&amp;x, a)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当然对于这个简单的场景, 使用遍历还是最快的, 毕竟函数调用中栈的切换是个开销:<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSum</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span>&#123;</span><br><span class="line">		Num  []<span class="keyword">int</span></span><br><span class="line">		Ept <span class="keyword">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;Num: []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;, Ept: <span class="number">55</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Sum1:"</span>), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				Sum1(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Sum2:"</span>), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				Sum2(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Sum3:"</span>), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				Sum3(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		b.Run(fmt.Sprintf(<span class="string">"Sum4:"</span>), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N; i++ &#123;</span><br><span class="line">				Sum4(c.Num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
测试结果: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: test</span><br><span class="line">BenchmarkSum&#x2F;Sum1:-8         	19798750	        62.2 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkSum&#x2F;Sum2:-8         	18605296	        64.4 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkSum&#x2F;Sum3:-8         	100000000	        11.1 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">BenchmarkSum&#x2F;Sum4:-8         	18347358	        66.7 ns&#x2F;op	       0 B&#x2F;op	       0 allocs&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok  	test	4.983s</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>尾递归</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title>i3wm+wine下微信去黑边框tips</title>
    <url>/2020/12/15/i3wm+wine%E4%B8%8B%E5%BE%AE%E4%BF%A1%E5%8E%BB%E9%BB%91%E8%BE%B9%E6%A1%86tips/</url>
    <content><![CDATA[<h2 id="i3wm-wine下微信去黑边框tips"><a href="#i3wm-wine下微信去黑边框tips" class="headerlink" title="i3wm+wine下微信去黑边框tips"></a>i3wm+wine下微信去黑边框tips</h2><p>使用i3wm很久了, 很喜欢这个操作手感. 但是又需要用到微信, 无奈使用wine装了一下, 发现打开后在i3下会有一个黑色的边框围绕着微信的界面, 这个边框会在切换workspace的时候挡住了其他ws的界面..很烦, 最近发现一个方法可以手动消除这个边框(每次运行都要执行…)</p>
<ul>
<li>微信版本: 3.0.0.47</li>
<li>wine版本: wine-6.0-rc1</li>
<li>i3版本(i3-gap): i3 version 4.19 (2020-11-15) © 2009 Michael Stapelberg and contributors</li>
<li>系统: Fedora 33</li>
</ul>
<p>首先设置wechat.exe在启动以后是<code>floating enable</code>的<br>在i3的配置文件中设置如下:<br><code>for_window [class=&quot;(?i)wechat.exe&quot;] floating enable,focus</code></p>
<p>启动微信后, 会发现存在黑框, 登录以后, 使用i3的fullscreen功能快捷键 执行2次, 第一次全屏的时候就只能看到黑框, 第2次恢复微信界面. 再点击一次微信上的最大化按钮, 此时黑框就变成了一个小的框. 这时执行:<br><code>wmctrl -l -G -p -x | grep &quot;wechat.exe.wechat.exe&quot; |grep -v &quot;微信&quot; |awk &#39;{print $1}&#39;|xargs -I {} xdotool windowunmap {}</code><br>就消灭了黑框了. </p>
<p>这个shell可以设置成i3的快捷键触发</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>wine</tag>
        <tag>wechat</tag>
        <tag>i3wm</tag>
      </tags>
  </entry>
  <entry>
    <title>我在i3wm下的折腾之路</title>
    <url>/2021/01/06/%E6%88%91%E5%9C%A8I3(I3WM)%E4%B8%8B%E7%9A%84%E6%8A%98%E8%85%BE%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="我在I3-I3WM-下的折腾之路"><a href="#我在I3-I3WM-下的折腾之路" class="headerlink" title="我在I3(I3WM)下的折腾之路"></a>我在I3(I3WM)下的折腾之路</h2><p>很久之前我就开始一直使用<code>Linux</code>系统作为主要使用平台了, 期间也经历过从<code>kylin</code>到<code>Ubuntu</code>再到<code>Fedora</code>的过程, 最终稳定在<code>Fedora</code>下使用了大概有4年了. 或许有人会很奇怪, 我为什么选择<code>Fedora</code>而不是<code>Arch</code>或<code>Ubuntu</code>, 其实主要是我之前在<code>RedHat</code>实习过, 用习惯了它, 加上他的<code>workstation</code>更新比较稳定. 我从29一直更新到了33, 虽然有些小问题但是最终都折腾解决了, 自己比较懒, 想在折腾和稳定性之间找一个平衡点, 所以就沿用至今. 这里插一句, 我比较倾向于使用开源的软件, 所有即使工作了大家都用<code>Mac</code>我还是用的<code>Fedora</code>, 使用体验怎么说呢: 好坏参半, 很多时间花在了折腾的路上, 但是很多Linux下的学习经验用MAC的人也体会不到..</p>
<p><code>Fedora</code>下我曾经使用的<code>Gnome</code>, 但是有一次折腾过程中发现了<code>I3</code>, 如获至宝, 使用至今, 那个键盘切来切去控制一切的感觉很爽(很装逼).</p>
<p><code>Fedora</code>下安装<code>I3</code>很方便, 参考官方的<a href="https://fedoramagazine.org/getting-started-i3-window-manager/" target="_blank" rel="noopener">fedoramagazine</a> , 关于<code>I3</code>的配置文件如何设置, 请参考官方的<a href="https://i3wm.org/docs/userguide.html" target="_blank" rel="noopener">用户手册</a> , 我自己根据这个折腾了很多, 后续我慢慢整理分享出来.</p>
<p>首先先放上几张我的系统效果图吧:</p>
<p><img src="/images/2021-01-06_10-58.png" alt=""></p>
<p>我是使用的双屏幕, 同时因为工作中使用到微信/QQ等工具, 在<code>Linux</code>上折腾起来很麻烦, 所有就又搞了一个虚拟机, 使用的<code>VirtualBox</code>+<code>Winddows 7</code>. </p>
<p>这里我反反复复经历过好几次想剔除掉虚拟机, 后来都失败了, 最终还是回归到使用虚拟机的道路上(真香TT)…那就先从折腾虚拟机的过程说起吧.</p>
<p>先说一下, 我在<code>I3</code>的配置中通过一个统一的启动脚本来控制登录后的自动执行的程序<code>exec --no-startup-id $HOME/.config/i3/autoload.sh &amp;</code>, 后续很多执行逻辑都写这个脚本里面了, 后面会给出详细说明.</p>
<h2 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h2><p>开源软件<code>VirtualBox</code>, 这个谷歌或百度一下就知道怎么安装和制作一个虚拟机系统了. 我这里重点说下使用体验: <code>extension pack</code> 必装!!! 不然无法体会两个系统共享剪切板和文件系统的那种爽快.</p>
<p>我的I3配置中, 将<code>VirtualBox</code>设置的自动启动到一个<code>workspace</code>中并把这个<code>ws</code>固定分配在一个屏幕中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set $ws10 &quot;10:vm&quot;</span><br><span class="line">workspace $ws10 output eDP-1 DP-1</span><br><span class="line">bindsym $mod+0 workspace $ws10</span><br><span class="line">assign [class&#x3D;&quot;(?i)virtual&quot;] $ws10</span><br><span class="line">for_window [class&#x3D;&quot;(?i)virtual&quot;] focus</span><br></pre></td></tr></table></figure>
<p>为了能在虚拟机下的微信/QQ/钉钉等软件收到消息后在linux系统下弹出提示(即使我切换到其他ws也能知道当前虚拟机下又消息了), 我做了很多折腾:</p>
<h4 id="通知管理"><a href="#通知管理" class="headerlink" title="通知管理"></a>通知管理</h4><p>首先, 在<code>Linux</code>下安装<code>dunst</code>这个工具,用于进行桌面消息通知. 其效果如下(也可访问其<a href="https://dunst-project.org" target="_blank" rel="noopener">官网</a>查看):</p>
<p><img src="https://dunst-project.org/static/image.png" alt=""></p>
<p>其配置文件我改的不多. 我采用的是<code>systemd</code>服务机制确保其在后台一直驻留:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.<span class="built_in">local</span>/share/systemd/user/dunst.service</span></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=dunst service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/dunst -conf $HOME/.config/i3/dunstrc</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=2</span><br><span class="line">ExecReload=kill -HUP $MAINPID</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>

<p>然后在启动脚本中通过<code>systemctl --user start dunst.service</code>启动服务</p>
<h4 id="传递消息"><a href="#传递消息" class="headerlink" title="传递消息"></a>传递消息</h4><p>为了能在传递消息, 首先我给虚拟机设置了一个独立的虚拟网卡, 在VB中配置成<code>Host-only</code>的网络, 然后在VB的主机网络管理中将这个<code>vboxnet0</code>设置成手动配置网卡的方式, 手动指定一个固定的内网地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPv4地址: 192.168.56.1</span><br><span class="line">IPv4网络掩码: 255.255.255.0</span><br><span class="line">DHCP服务: 关闭</span><br></pre></td></tr></table></figure>

<p>虚拟机配置了双网络, 一个就是上面这个<code>Host-only</code>, 另一个是一个<code>NAT</code>网络(用于访问外网)</p>
<p>在虚拟机中将<code>Host-only</code>这个网卡的地址手动绑定为<code>192.168.56.2</code></p>
<p>在<code>Linux</code>中部署一个自己写的程序的服务端, 监听<code>192.168.56.1:23456</code>这个地址, 一旦收到信息就调用<code>notify-send</code> 发送消息.</p>
<p>在<code>Linux</code>下的这个服务端<code>systemd</code>的<code>service</code>文件以及登录启动方式和上面的<code>dunst</code>基本一致.</p>
<p>之后在虚拟机中使用<code>AutoHotkey</code>来监听系统中消息到来时任务栏的闪烁事件, 一旦触发就调用自己写的程序的客户端通过网络将消息发到<code>Linux</code>系统下的<code>192.168.56.1:23456</code>地址. </p>
<p><code>AutoHotkey</code>设置开机启动, 其脚本<code>AutoHotkey.ahk</code>为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; borrow from http:&#x2F;&#x2F;www.autohotkey.com&#x2F;board&#x2F;topic&#x2F;36510-detect-flashingblinking-window-on-taskbar&#x2F;?p&#x3D;229583</span><br><span class="line"></span><br><span class="line">DetectHiddenWindows, On</span><br><span class="line">Script_Hwnd :&#x3D; WinExist(&quot;ahk_class AutoHotkey ahk_pid &quot; DllCall(&quot;GetCurrentProcessId&quot;))</span><br><span class="line">DetectHiddenWindows, Off</span><br><span class="line"></span><br><span class="line">; Register shell hook to detect flashing windows.</span><br><span class="line">DllCall(&quot;RegisterShellHookWindow&quot;, &quot;uint&quot;, Script_Hwnd)</span><br><span class="line">OnMessage(DllCall(&quot;RegisterWindowMessage&quot;, &quot;str&quot;, &quot;SHELLHOOK&quot;), &quot;ShellEvent&quot;)</span><br><span class="line">;...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShellEvent(wParam, lParam) &#123;</span><br><span class="line"></span><br><span class="line">    if (wParam &#x3D; 0x8006) ; HSHELL_FLASH</span><br><span class="line">    &#123;   ; lParam contains the ID of the window which flashed:</span><br><span class="line"></span><br><span class="line">	    WinGetTitle, win_title, ahk_id %lParam%</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译以后执行执行就可以</p>
<h4 id="虚拟机中点击url直接在Linux中打开"><a href="#虚拟机中点击url直接在Linux中打开" class="headerlink" title="虚拟机中点击url直接在Linux中打开"></a>虚拟机中点击url直接在Linux中打开</h4><p>工作中经常遇到别人给你发个链接, 你想打开来看, 又不想在虚拟机中打开, 总是需要拷贝一下, 再到<code>Linux</code>下粘贴打开, 很麻烦!</p>
<p>我的思路就是利用上面的通知系统, 点击<code>url</code>时直接将<code>url</code>发到<code>Linux</code>, 然后在<code>Linux</code>服务端检查是否是一个<code>url</code>, 如果是就通过调用浏览器打开</p>
<p>那么在<code>windows</code>下就得修改注册表中对于<code>url</code>的默认打开程序,我这里在<code>windows</code>中安装了<code>chrome</code>, 并将其设置为默认浏览器. 然后修改其调用的程序, 改成我自己的客户端程序<code>notify.exe</code>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA]</span><br><span class="line">@&#x3D;&quot;Chrome HTML Document&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA\DefaultIcon]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe,0&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA\shell]</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA\shell\open]</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA\shell\open\command]</span><br><span class="line">@&#x3D;&quot;\&quot;C:\\Users\\Administrator\\Desktop\\notify.exe\&quot; \&quot;%1\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\360seurl]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\360seurl\UserChoice]</span><br><span class="line">&quot;Progid&quot;&#x3D;&quot;360seurl&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\ftp]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\ftp\UserChoice]</span><br><span class="line">&quot;Progid&quot;&#x3D;&quot;ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\htmlfile]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\htmlfile\UserChoice]</span><br><span class="line">&quot;Progid&quot;&#x3D;&quot;htmlfile&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice]</span><br><span class="line">&quot;Progid&quot;&#x3D;&quot;ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\https]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice]</span><br><span class="line">&quot;Progid&quot;&#x3D;&quot;ChromeHTML.SWC66KHLYIBC7ZKM7ZSF3B7DIA&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\irc]</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\irc\UserChoice]</span><br></pre></td></tr></table></figure>

<h4 id="我写的这个服务端与客户端一体化的小程序"><a href="#我写的这个服务端与客户端一体化的小程序" class="headerlink" title="我写的这个服务端与客户端一体化的小程序"></a>我写的这个服务端与客户端一体化的小程序</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"regexp"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"sync/atomic"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> browserType = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	chrome browserType = <span class="literal">iota</span></span><br><span class="line">	ie</span><br><span class="line">	firefox</span><br><span class="line">	safari</span><br><span class="line">	urlPattern <span class="keyword">string</span> = <span class="string">`(?:(?:https?:\/\/)?(?:[a-z0-9.\-]+|www|[a-z0-9.\-])[.](?:[^\s()&lt;&gt;]+|\((?:[^\s()&lt;&gt;]+|(?:\([^\s()&lt;&gt;]+\)))*\))+(?:\((?:[^\s()&lt;&gt;]+|(?:\([^\s()&lt;&gt;]+\)))*\)|[^\s!()\[\]&#123;&#125;;:\'".,&lt;&gt;?]))`</span></span><br><span class="line">	cooldown          = <span class="number">800</span> <span class="comment">// 1000ms</span></span><br><span class="line">	chromeBin         = <span class="string">"/usr/bin/google-chrome"</span></span><br><span class="line">	firefoxBin        = <span class="string">"/usr/bin/firefox"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	host, api     <span class="keyword">string</span></span><br><span class="line">	port, timeout <span class="keyword">int</span></span><br><span class="line">	serverMode    <span class="keyword">bool</span></span><br><span class="line">	browser       browserType</span><br><span class="line">	limit         <span class="keyword">int32</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">"h"</span>, <span class="string">"192.168.56.1"</span>, <span class="string">"the host address"</span>)</span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">"p"</span>, <span class="number">34567</span>, <span class="string">"the port number"</span>)</span><br><span class="line">	flag.StringVar(&amp;api, <span class="string">"u"</span>, <span class="string">"/"</span>, <span class="string">"the url api to get"</span>)</span><br><span class="line">	flag.IntVar(&amp;timeout, <span class="string">"t"</span>, <span class="number">5000</span>, <span class="string">"the timeout, unit ms"</span>)</span><br><span class="line">	flag.BoolVar(&amp;serverMode, <span class="string">"s"</span>, <span class="literal">false</span>, <span class="string">"the server mode, else run in send msg mode"</span>)</span><br><span class="line">	flag.IntVar(&amp;browser, <span class="string">"b"</span>, chrome, <span class="string">"the browser to open url"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsg</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		Timeout: time.Duration(timeout) * time.Millisecond,</span><br><span class="line">	&#125;</span><br><span class="line">	_, err := client.Get(<span class="string">"http://"</span> + host + <span class="string">":"</span> + strconv.Itoa(port) + api + <span class="string">"?msg="</span> + url.QueryEscape(msg))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(url <span class="keyword">string</span>, browser browserType)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> browser &#123;</span><br><span class="line">	<span class="keyword">case</span> chrome:</span><br><span class="line">		runCmd(chromeBin, url)</span><br><span class="line">	<span class="keyword">case</span> firefox:</span><br><span class="line">		runCmd(firefoxBin, url)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		runCmd(chromeBin, url)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCmd</span><span class="params">(path <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(path, args...)</span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	runCmd(<span class="string">"notify-send"</span>, <span class="string">"您有新的消息: "</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr := host + <span class="string">":"</span> + strconv.Itoa(port)</span><br><span class="line">	log.Println(<span class="string">"run in server mode, address: http://"</span> + addr)</span><br><span class="line">	urlValid := regexp.MustCompile(urlPattern)</span><br><span class="line">	http.HandleFunc(api, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		atomic.AddInt32(&amp;limit, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">defer</span> atomic.AddInt32(&amp;limit, <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt32(&amp;limit) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			w.WriteHeader(http.StatusOK)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		msg, err := url.QueryUnescape(r.URL.Query().Get(<span class="string">"msg"</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			w.Write([]<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">			w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> urlValid.Match([]<span class="keyword">byte</span>(msg)) &#123;</span><br><span class="line">			<span class="keyword">go</span> open(msg, browser)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> notify(msg)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Duration(cooldown) * time.Millisecond)</span><br><span class="line">		w.WriteHeader(http.StatusOK)</span><br><span class="line">	&#125;)</span><br><span class="line">	s := &amp;http.Server&#123;</span><br><span class="line">		Addr:           addr,</span><br><span class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	log.Fatal(s.ListenAndServe())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">if</span> !serverMode &#123;</span><br><span class="line">		<span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> flag.NArg() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			msg = flag.Args()[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		sendMsg(msg)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	server()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build -o notify main.go</span><br><span class="line">$ GOOS=windows GOARCH=amd64 go build -o notify.exe -ldflags -H=windowsgui main.go</span><br></pre></td></tr></table></figure>

<p>编译windows版本的时候<code>-ldflags -H=windowsgui</code>可以避免执行程序时候出现<code>cmd</code>弹窗.</p>
<h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>在<code>I3</code>下使用<code>copyq</code>替代系统的剪切板, 在<code>I3</code>的配置中设置<code>F3</code>来显示<code>copyq</code>的界面,选择需要粘贴的历史剪切记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym F3 exec --no-startup-id copyq toggle</span><br></pre></td></tr></table></figure>

<h4 id="快捷输入"><a href="#快捷输入" class="headerlink" title="快捷输入"></a>快捷输入</h4><p><code>copyq</code>还提供了一个快捷输入的途径, 我经常拿它来粘贴一些常用的地址或指令:<br>比如我在<code>copyq</code>中设置一个<code>important</code>的标签页, 将<code>www.google.com</code>插入为一个项目,并设置固定位置到<code>0</code>的位置, 然后我在<code>I3</code>中配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+F3 exec --no-startup-id sleep 0.2 &amp;&amp; copyq tab important select 0 paste &amp;&amp; copyq tab Clipboard select 0</span><br></pre></td></tr></table></figure>
<p>那么只要我使用<code>$mod+F3</code>按键, 就能在当前的输入框中粘贴<code>www.google.com</code>这个字符串. 如此我设置了一堆, 感觉甚是好用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+F3 exec --no-startup-id sleep 0.2 &amp;&amp; copyq tab important select 0 paste &amp;&amp; copyq tab Clipboard select 0</span><br><span class="line">bindsym $mod+F4 exec --no-startup-id sleep 0.2 &amp;&amp; copyq tab important select 1 paste &amp;&amp; copyq tab Clipboard select 0</span><br><span class="line">bindsym $mod+F5 exec --no-startup-id sleep 0.2 &amp;&amp; copyq tab important select 2 paste &amp;&amp; copyq tab Clipboard select 0</span><br></pre></td></tr></table></figure>

<h4 id="纯文本粘贴"><a href="#纯文本粘贴" class="headerlink" title="纯文本粘贴"></a>纯文本粘贴</h4><p>我的<code>copyq</code>设置的支持复制富文本方式, 在其中的<code>命令/全局快捷键</code>管理选项中可以添加一个粘贴为纯文本的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copyq: </span><br><span class="line">var text &#x3D; clipboard()</span><br><span class="line">copy(text)</span><br><span class="line">copySelection(text)</span><br><span class="line">paste()</span><br></pre></td></tr></table></figure>
<p>为其配置一个快捷键<code>ctrl+shift+v</code>, 那么就可以对于复制的富文本仅仅粘贴为纯文本, 规避一些复制粘贴的麻烦.</p>
<h4 id="文本快速处理"><a href="#文本快速处理" class="headerlink" title="文本快速处理"></a>文本快速处理</h4><p>有时, 我在写文字的时候, 遇到想给几行文字每行开头加个<code>1.2.3..</code>之类的序号, 或者想移出它们, 或者对于<code>markdown</code>格式的文本想每行前都加个<code>-</code>, 或者想对一行逗号分割的字符串组给每个字符串都加减引号, 或者想直接输入当前日期, 那么我时常会一行一行的处理, 很麻烦有没有?</p>
<p>于是, 我写了个结合<code>xclip</code>和<code>copyq</code>的脚本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [[ "$1" = "num" ]];then</span><br><span class="line">    xclip -out -selection primary |awk 'BEGIN&#123;i=1;&#125;&#123;if($0 != "")&#123;if($1 ~ /[0-9]+\./)&#123;$1="";print $0;&#125;else&#123;print i". "$0;i++;&#125;&#125;else&#123;print $0&#125;&#125;' |xclip -in -selection clipboard| copyq paste</span><br><span class="line">elif [[ "$1" = "dot" ]];then</span><br><span class="line">    xclip -out -selection primary |awk '&#123;if($0 != "")&#123;if($1 != "*")&#123;print "* "$0&#125;else&#123;$1="";print $0;    &#125;&#125;else&#123;print $0&#125;&#125;' |xclip -in -selection clipboard| copyq paste</span><br><span class="line">elif [[ "$1" = "plus" ]];then</span><br><span class="line">    xclip -out -selection primary |awk '&#123;if($0 != "")&#123;if($1 != "-")&#123;print "- "$0&#125;else&#123;$1="";print $0;    &#125;&#125;else&#123;print $0&#125;&#125;' |xclip -in -selection clipboard| copyq paste</span><br><span class="line">elif [[ "$1" = "quote" ]];then</span><br><span class="line">    xclip -out -selection primary | awk '&#123;if($0 != "")&#123;if($0 ~ /["'\'']/)&#123;gsub("\"","",$0);gsub("'\''","",$0);print $0 &#125;else&#123;if($0 ~ /,/)&#123;gsub(/ *, */,"\",\"",$0);print "\""$0"\"" &#125;else&#123;gsub(/ +/,"\" \"",$0);print "\""$0"\""&#125; &#125; &#125;else&#123;print $0&#125; &#125;'|xclip -in -selection clipboard| copyq paste</span><br><span class="line">elif [[ "$1" = "date" ]];then</span><br><span class="line">    echo -n "$(date +'%Y-%m-%d %H:%M:%S')"|xclip -in -selection clipboard | copyq paste</span><br><span class="line">else</span><br><span class="line">    xclip -out -selection primary |xclip -in -selection clipboard</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>然后在<code>I3</code>中给它们绑定按键, 之后只有选定那些文件, 就能一键处理好需要加减开头标记的文字并粘贴回编辑器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+i exec --no-startup-id ~&#x2F;.config&#x2F;i3&#x2F;lineformat.sh num &#x2F;&#x2F; 每行前加数字和.</span><br><span class="line">bindsym $mod+u exec --no-startup-id ~&#x2F;.config&#x2F;i3&#x2F;lineformat.sh dot &#x2F;&#x2F; 每行前加*和空格</span><br><span class="line">bindsym $mod+o exec --no-startup-id ~&#x2F;.config&#x2F;i3&#x2F;lineformat.sh plus &#x2F;&#x2F; 每行前加-和空格</span><br><span class="line">bindsym $mod+y exec --no-startup-id ~&#x2F;.config&#x2F;i3&#x2F;lineformat.sh quote &#x2F;&#x2F; 给每个字符串加引号或者去除引号</span><br><span class="line">bindsym $mod+t exec --no-startup-id ~&#x2F;.config&#x2F;i3&#x2F;lineformat.sh date &#x2F;&#x2F; 输入当前日期</span><br></pre></td></tr></table></figure>

<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>一键截图是必不可少的功能, 怎么实现呢?</p>
<p>经历几次选择后,我最终使用了<code>flameshot</code> . 相比于<code>shutter</code>来说<code>flameshot</code>的功能更丰富, 而且 <code>shutter</code>曾经因为<code>Fedora</code>大版本更新, 引起的<code>perl</code>的版本更新, 从而导致执行出错. <code>flameshot</code>则更加稳定.</p>
<p>在<code>I3</code>中我配置了<code>bindsym $mod+F2 exec --no-startup-id flameshot gui -p ~/share/screenshot/</code></p>
<p>然后在启动脚本<code>autoload.sh</code>中我设置了<code>flameshot &amp;</code> 让其自动开机启动.</p>
<p>这样每次我需要截图的时候就直接<code>$mod+F2</code>进入截图模式, 保存后会自动默认写入<code>~/share/screenshot/</code>文件夹下. 还可以直接粘贴到输入框, 结合VB的<code>extend</code>共享剪切板机制, 直接可以粘贴到微信/QQ等应用中, 完全感受不到我在操作虚拟机有没有?</p>
<h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>输入法这个真的是硬伤, 折腾过多次, 也折腾过很久. 不忍吐槽一下:默认的<code>Ibus</code>真的有点垃圾了..我使用的<code>Rime</code>输入法, 在<code>Fcitx</code>框架下, 使用搜狗也是可以的, 但是我不喜欢它那个收集信息的感觉..</p>
<p><code>Rime</code>的配置和词库, 来来回回折腾过很久. 最终配置稳定在如下样子, 这里我喜欢用<code>CapsLock</code>切换中英文输入, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果要把 Caps Lock 設爲只改變字母的大小寫而不做中西文切換，可將 Caps_Lock 對應的切換方式設爲 noop</span><br><span class="line"># 如果要以 Caps Lock 切換到西文模式，默認輸出小寫字母，請置 ascii_composer&#x2F;good_old_caps_lock: false</span><br><span class="line"># 如果要以 Caps Lock 切換到西文模式，默認輸出大寫字母，請使用以下設置：</span><br><span class="line"># patch:</span><br><span class="line">#  ascii_composer&#x2F;good_old_caps_lock: true</span><br><span class="line">#  ascii_composer&#x2F;switch_key:</span><br><span class="line">#    Caps_Lock: clear</span><br><span class="line">#    Shift_L: commit_code</span><br><span class="line">#    Shift_R: commit_text</span><br><span class="line">#    Eisu_toggle: clear</span><br><span class="line">#    Control_L: noop </span><br><span class="line">#    Control_R: noop</span><br><span class="line">patch:</span><br><span class="line">  ascii_composer:</span><br><span class="line">    good_old_caps_lock: false</span><br><span class="line">    switch_key:</span><br><span class="line">      Caps_Lock: commit_code</span><br><span class="line">      Control_L: noop</span><br><span class="line">      Control_R: noop</span><br><span class="line">      Shift_L: noop</span><br><span class="line">      Shift_R: inline_ascii</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      - &#123;accept: &quot;Control+p&quot;, send: Up, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+n&quot;, send: Down, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+b&quot;, send: Left, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+f&quot;, send: Right, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+a&quot;, send: Home, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+e&quot;, send: End, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+d&quot;, send: Delete, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+k&quot;, send: &quot;Shift+Delete&quot;, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+h&quot;, send: BackSpace, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+g&quot;, send: Escape, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+bracketleft&quot;, send: Escape, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Alt+v&quot;, send: Page_Up, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Control+v&quot;, send: Page_Down, when: composing&#125;</span><br><span class="line">      - &#123;accept: ISO_Left_Tab, send: Page_Up, when: composing&#125;</span><br><span class="line">      - &#123;accept: &quot;Shift+Tab&quot;, send: Page_Up, when: composing&#125;</span><br><span class="line">      - &#123;accept: Tab, send: Page_Down, when: composing&#125;</span><br><span class="line">      - &#123;accept: minus, send: Page_Up, when: has_menu&#125;</span><br><span class="line">      - &#123;accept: equal, send: Page_Down, when: has_menu&#125;</span><br><span class="line">      - &#123;accept: comma, send: Page_Up, when: paging&#125;</span><br><span class="line">      - &#123;accept: period, send: Page_Down, when: has_menu&#125;</span><br><span class="line">  menu:</span><br><span class="line">    page_size: 5</span><br><span class="line">  preset_color_schemes:</span><br><span class="line">    light:</span><br><span class="line">      name: register                                     # 作者名</span><br><span class="line">      author: &quot;register &lt;registerdedicated@gmail.com&gt;&quot;   # 作者</span><br><span class="line"></span><br><span class="line">      horizontal: true                                   # 候选条横向显示</span><br><span class="line">      inline_preedit: true                               # 启用内嵌编码模式，候选条首行不显示拼音</span><br><span class="line">      candidate_format: &quot;%c\u2005%@\u2005&quot;               # 用 1&#x2F;6 em 空格 U+2005 来控制编号 %c 和候选词 %@ 前后的空间。</span><br><span class="line"></span><br><span class="line">      corner_radius: 5                                   # 候选条圆角半径</span><br><span class="line">      border_height: 7                                   # 窗口边界高度，大于圆角半径才生效</span><br><span class="line">      border_width: 7                                    # 窗口边界宽度，大于圆角半径才生效</span><br><span class="line">      back_color: 0xFFFFFF                               # 候选条背景色</span><br><span class="line">      border_color: 0xE0B693                             # 边框色</span><br><span class="line">      font_face: &quot;PingFangSC-Regular&quot;                    # 候选词字体</span><br><span class="line">      font_point: 18                                     # 预选栏文字字号</span><br><span class="line">      label_font_face: &quot;PingFangSC-Light&quot;                # 候选词编号字体</span><br><span class="line">      label_font_point: 14                               # 预选栏编号字号</span><br><span class="line">      candidate_text_color: 0x000000                     # 预选项文字颜色</span><br><span class="line">      text_color: 0x000000                               # 拼音行文字颜色，24位色值，16进制，BGR顺序</span><br><span class="line">      comment_text_color: 0x999999                       # 拼音等提示文字颜色</span><br><span class="line">      hilited_text_color: 0xFF6941                       # 高亮拼音 (需要开启内嵌编码)</span><br><span class="line">      hilited_candidate_text_color: 0xFF6941             # 第一候选项文字颜色</span><br><span class="line">      hilited_candidate_back_color: 0xFFFFFF             # 第一候选项背景背景色</span><br><span class="line">      hilited_comment_text_color: 0xFF6941               # 注解文字高亮</span><br><span class="line"></span><br><span class="line">  punctuator:</span><br><span class="line">    full_shape:</span><br><span class="line">        &quot; &quot; : &#123; commit: &quot;　&quot; &#125;</span><br><span class="line">        &quot;,&quot; : &#123; commit: ， &#125;</span><br><span class="line">        &quot;.&quot; : &#123; commit: 。 &#125;</span><br><span class="line">        &quot;&lt;&quot; : [ 《, 〈, «, ‹ ]</span><br><span class="line">        &quot;&gt;&quot; : [ 》, 〉, », › ]</span><br><span class="line">        &quot;&#x2F;&quot; : [ 、, ／, &quot;&#x2F;&quot;, ÷ ]</span><br><span class="line">        &quot;?&quot; : &#123; commit: ？ &#125;</span><br><span class="line">        &quot;;&quot; : &#123; commit: ； &#125;</span><br><span class="line">        &quot;:&quot; : ：</span><br><span class="line">        &quot;&#39;&quot; : &#123; pair: [ &quot;‘&quot;, &quot;’&quot; ] &#125;</span><br><span class="line">        &quot;\&quot;&quot; : &#123; pair: [ &quot;“&quot;, &quot;”&quot; ] &#125;</span><br><span class="line">        &quot;\\&quot; : [ 、, ＼, &quot;\\&quot; ]</span><br><span class="line">        &quot;|&quot; : [ ・, ｜, &quot;|&quot;, &quot;§&quot;, &quot;¦&quot; ]</span><br><span class="line">        &quot;&#96;&quot; : [ ｀, &quot;&#96;&quot; ]</span><br><span class="line">        &quot;~&quot; : [ 〜, &quot;~&quot;, ～, 〰 ]</span><br><span class="line">        &quot;!&quot; : &#123; commit: ！ &#125;</span><br><span class="line">        &quot;@&quot; : [ ＠, &quot;@&quot;, ☯ ]</span><br><span class="line">        &quot;#&quot; : [ ＃, &quot;#&quot;, ⌘ ]</span><br><span class="line">        &quot;%&quot; : [ ％, &quot;%&quot;, &quot;°&quot;, &quot;℃&quot; ]</span><br><span class="line">        &quot;$&quot; : [ ￥, &quot;$&quot;, &quot;€&quot;, &quot;£&quot;, &quot;¥&quot;, &quot;¢&quot;, &quot;¤&quot; ]</span><br><span class="line">        &quot;^&quot; : &#123; commit: …… &#125;</span><br><span class="line">        &quot;&amp;&quot; : [ ＆, &quot;&amp;&quot; ]</span><br><span class="line">        &quot;*&quot; : [ ＊, &quot;*&quot;, ・, ×, ※, ❂, · ]</span><br><span class="line">        &quot;(&quot; : （</span><br><span class="line">        &quot;)&quot; : ）</span><br><span class="line">        &quot;-&quot; : [ －, &quot;-&quot; ]</span><br><span class="line">        &quot;_&quot; : ——</span><br><span class="line">        &quot;+&quot; : [ ＋, &quot;+&quot; ]</span><br><span class="line">        &quot;&#x3D;&quot; : [ ＝, &quot;&#x3D;&quot; ]</span><br><span class="line">        &quot;[&quot; : [ 「, 【, 〔, ［ ]</span><br><span class="line">        &quot;]&quot; : [ 」, 】, 〕, ］ ]</span><br><span class="line">        &quot;&#123;&quot; : [ 『, 〖, ｛ ]</span><br><span class="line">        &quot;&#125;&quot; : [ 』, 〗, ｝ ]</span><br><span class="line">    half_shape:</span><br><span class="line">        &quot;,&quot; : &#123; commit: &quot;,&quot; &#125;</span><br><span class="line">        &quot;.&quot; : &#123; commit: &quot;.&quot; &#125;</span><br><span class="line">        &quot;&lt;&quot; : [ &quot;&lt;&quot;, &quot;，&quot; ]</span><br><span class="line">        &quot;&gt;&quot; : [ &quot;&gt;&quot;, &quot;。&quot; ]</span><br><span class="line">        &quot;&#x2F;&quot; : &#123; commit: &quot;&#x2F;&quot; &#125;</span><br><span class="line">        &quot;?&quot; : &#123; commit: &quot;?&quot; &#125;</span><br><span class="line">        &quot;;&quot; : &#123; commit: &quot;;&quot; &#125;</span><br><span class="line">        &quot;:&quot; : &#123; commit: &quot;:&quot; &#125;</span><br><span class="line">        &quot;&#39;&quot; : &quot;&#39;&quot;</span><br><span class="line">        &quot;\&quot;&quot; : &quot;\&quot;&quot;</span><br><span class="line">        &quot;\\&quot; : [&quot;\\&quot;,&quot;、&quot;]</span><br><span class="line">        &quot;|&quot; : &quot;|&quot;</span><br><span class="line">        &quot;&#96;&quot; : &quot;&#96;&quot;</span><br><span class="line">        &quot;~&quot; : &quot;~&quot;</span><br><span class="line">        &quot;!&quot; : &#123; commit: &quot;!&quot; &#125;</span><br><span class="line">        &quot;@&quot; : &quot;@&quot;</span><br><span class="line">        &quot;#&quot; : &quot;#&quot;</span><br><span class="line">        &quot;%&quot; : &quot;%&quot;</span><br><span class="line">        &quot;$&quot; : &quot;$&quot;</span><br><span class="line">        &quot;^&quot; : [ &quot;^&quot;, &quot;……&quot; ]</span><br><span class="line">        &quot;&amp;&quot; : &quot;&amp;&quot;</span><br><span class="line">        &quot;*&quot; : &quot;*&quot;</span><br><span class="line">        &quot;(&quot; : &quot;(&quot;</span><br><span class="line">        &quot;)&quot; : &quot;)&quot;</span><br><span class="line">        &quot;-&quot; : &quot;-&quot;</span><br><span class="line">        &quot;_&quot; : &quot;_&quot;</span><br><span class="line">        &quot;+&quot; : &quot;+&quot;</span><br><span class="line">        &quot;&#x3D;&quot; : &quot;&#x3D;&quot;</span><br><span class="line">        &quot;[&quot; : &quot;[&quot;</span><br><span class="line">        &quot;]&quot; : &quot;]&quot;</span><br><span class="line">        &quot;&#123;&quot; : &quot;&#123;&quot;</span><br><span class="line">        &quot;&#125;&quot; : &quot;&#125;&quot;</span><br><span class="line">    symbols:</span><br><span class="line">  #符號、電腦</span><br><span class="line">      &#39;&#x2F;fh&#39;: [ ©, ®, ℗, ℠, ™, ℡, ℻, ☇, ☈, ☉, ☊, ☋, ☌, ☍, ☎, ☏, ☐, ☑, ☒, ☓, ☕, ☖, ☗, ⛉, ⛊, ☘, ☙, ☚, ☛, ☜, ☝, ☞, ☟, ☠, ☡, ☢, ☣, ☤, ☥, ☦, ☧, ☨, ☩, ☪, ☫, ☬, ☭, ☮, ☯, ☸, ♨, ♰, ♱, ♲, ♳, ♴, ♵, ♶, ♷, ♸, ♹, ♺, ♻, ♼, ♽, ♾, ♿, ⚆, ⚇, ⚈, ⚉, ⚐, ⚑, ⚒, ⚓, ⚔, ⚕, ⚖, ⚗, ⚘, ⚙, ⚚, ⚛, ⚜, ⚝, ⚞, ⚟, ⚠, ⚡, ⚰, ⚱, ⚲, ⚳, ⚴, ⚵, ⚶, ⚷, ⚸, ⚹, ⚺, ⚻, ⚼, ⚽, ⚾, ⚿, ⛀, ⛁, ⛂, ⛃, ⛋, ⛌, ⛍, ⛎, ⛏, ⛐, ⛑, ⛒, ⛓, ⛔, ⛕, ⛖, ⛗, ⛘, ⛙, ⛚, ⛛, ⛜, ⛝, ⛞, ⛟, ⛠, ⛡, ⛢, ⛣, ⛨, ⛩, ⛪, ⛫, ⛬, ⛭, ⛮, ⛯, ⛰, ⛱, ⛲, ⛳, ⛴, ⛵, ⛶, ⛷, ⛸, ⛹, ⛺, ⛻, ⛼, ⛽, ⛾, ⛿ ]</span><br><span class="line">      &#39;&#x2F;dn&#39;: [ , ❖, ◁, ⌘, ⌥, ⎇, ⇧, ⇪, ↩, ⌅, ⌤, ⌫, ⌦, ⌧, ⌨, ⌀, ⌖, ⌗, ⏏, ↖, ↘, ⇞, ⇟, ⌚, ⏰, ⏱, ⏲, ⏳, ⌛, ⌜, ⌝⌞⌟, ⍑, ⏩, ⏪, ⏫, ⏬, ⏭, ⏮, ⏯ ]</span><br><span class="line">  #象棋、麻將、色子、撲克</span><br><span class="line">      &#39;&#x2F;xq&#39;: [ ♔, ♕, ♖, ♗, ♘, ♙, ♚, ♛, ♜, ♝, ♞, ♟ ]</span><br><span class="line">      &#39;&#x2F;mj&#39;: [ 🀀, 🀁, 🀂, 🀃, 🀄, 🀅, 🀆, 🀇, 🀈, 🀉, 🀊, 🀋, 🀌, 🀍, 🀎, 🀏, 🀐, 🀑, 🀒, 🀓, 🀔, 🀕, 🀖, 🀗, 🀘, 🀙, 🀚, 🀛, 🀜, 🀝, 🀞, 🀟, 🀠, 🀡, 🀢, 🀣, 🀤, 🀥, 🀦, 🀧, 🀨, 🀩, 🀪, 🀫 ]</span><br><span class="line">      &#39;&#x2F;sz&#39;: [ ⚀, ⚁, ⚂, ⚃, ⚄, ⚅ ]</span><br><span class="line">      &#39;&#x2F;pk&#39;: [ ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧ ]</span><br><span class="line">  #表情</span><br><span class="line">      &#39;&#x2F;bq&#39;: [ ☻, ☺, ☹ ]</span><br><span class="line">  #天氣</span><br><span class="line">      &#39;&#x2F;tq&#39;: [ ☀, ☁, ⛅, ⛈, ⛆, ☂, ☔, ☃, ⛄, ⛇ ]</span><br><span class="line">  #音樂</span><br><span class="line">      &#39;&#x2F;yy&#39;: [ 𝄞, ♩, ♪, ♫, ♬, ♭, ♮, ♯ ]</span><br><span class="line">  #兩性</span><br><span class="line">      &#39;&#x2F;lx&#39;: [ ♂, ♀, ⚢, ⚣, ⚤, ⚥, ⚦, ⚧, ⚨, ⚩, ⚪, ⚫, ⚬, ⚭, ⚮, ⚯ ]</span><br><span class="line">  #八卦、八卦名、六十四卦、六十四卦名、太玄經</span><br><span class="line">      &#39;&#x2F;bg&#39;: [ ☰, ☱, ☲, ☳, ☴, ☵, ☶, ☷ ]</span><br><span class="line">      &#39;&#x2F;bgm&#39;: [ 乾, 兌, 離, 震, 巽, 坎, 艮, 坤 ]</span><br><span class="line">      &#39;&#x2F;lssg&#39;: [ ䷀, ䷁, ䷂, ䷃, ䷄, ䷅, ䷆, ䷇, ䷈, ䷉, ䷊, ䷋, ䷌, ䷍, ䷎, ䷏, ䷐, ䷑, ䷒, ䷓, ䷔, ䷕, ䷖, ䷗, ䷘, ䷙, ䷚, ䷛, ䷜, ䷝, ䷞, ䷟, ䷠, ䷡, ䷢, ䷣, ䷤, ䷥, ䷦, ䷧, ䷨, ䷩, ䷪, ䷫, ䷬, ䷭, ䷮, ䷯, ䷰, ䷱, ䷲, ䷳, ䷴, ䷵, ䷶, ䷷, ䷸, ䷹, ䷺, ䷻, ䷼, ䷽, ䷾, ䷿ ]</span><br><span class="line">      &#39;&#x2F;lssgm&#39;: [ 乾, 坤, 屯, 蒙, 需, 訟, 師, 比, 小畜, 履, 泰, 否, 同人, 大有, 謙, 豫, 隨, 蠱, 臨, 觀, 噬嗑, 賁, 剝, 復, 无妄, 大畜, 頤, 大過, 坎, 離, 咸, 恆, 遯, 大壯, 晉, 明夷, 家人, 睽, 蹇, 解, 損, 益, 夬, 姤, 萃, 升, 困, 井, 革, 鼎, 震, 艮, 漸, 歸妹, 豐, 旅, 巽, 兌, 渙, 節, 中孚, 小過, 既濟, 未濟 ]</span><br><span class="line">      &#39;&#x2F;txj&#39;: [ ⚊, ⚋, ⚌, ⚍, ⚎, ⚏, 𝌀, 𝌁, 𝌂, 𝌃, 𝌄, 𝌅, 𝌆, 𝌇, 𝌈, 𝌉, 𝌊, 𝌋, 𝌌, 𝌍, 𝌎, 𝌏, 𝌐, 𝌑, 𝌒, 𝌓, 𝌔, 𝌕, 𝌖, 𝌗, 𝌘, 𝌙, 𝌚, 𝌛, 𝌜, 𝌝, 𝌞, 𝌟, 𝌠, 𝌡, 𝌢, 𝌣, 𝌤, 𝌥, 𝌦, 𝌧, 𝌨, 𝌩, 𝌪, 𝌫, 𝌬, 𝌭, 𝌮, 𝌯, 𝌰, 𝌱, 𝌲, 𝌳, 𝌴, 𝌵, 𝌶, 𝌷, 𝌸, 𝌹, 𝌺, 𝌻, 𝌼, 𝌽, 𝌾, 𝌿, 𝍀, 𝍁, 𝍂, 𝍃, 𝍄, 𝍅, 𝍆, 𝍇, 𝍈, 𝍉, 𝍊, 𝍋, 𝍌, 𝍍, 𝍎, 𝍏, 𝍐, 𝍑, 𝍒, 𝍓, 𝍔, 𝍕, 𝍖 ]</span><br><span class="line">  #天體、星座、星座名、十二宮</span><br><span class="line">      &#39;&#x2F;tt&#39;: [ ☄, ☼, ☽, ☾, ☿, ♀, ♁, ♂, ♃, ♄, ♅, ♆, ♇ ]</span><br><span class="line">      &#39;&#x2F;xz&#39;: [ ♈, ♉, ♊, ♋, ♌, ♍, ♎, ♏, ♐, ♑, ♒, ♓ ]</span><br><span class="line">      &#39;&#x2F;xzm&#39;: [ 白羊座, 金牛座, 雙子座, 巨蟹座, 獅子座, 室女座, 天秤座, 天蠍座, 人馬座, 摩羯座, 寶瓶座, 雙魚座 ]</span><br><span class="line">      &#39;&#x2F;seg&#39;: [ 白羊宮, 金牛宮, 雙子宮, 巨蟹宮, 獅子宮, 室女宮, 天秤宮, 天蠍宮, 人馬宮, 摩羯宮, 寶瓶宮, 雙魚宮 ]</span><br><span class="line">  #星號</span><br><span class="line">      &#39;&#x2F;xh&#39;: [ ★, ☆, ⛤, ⛥, ⛦, ⛧, ✡, ❋, ❊, ❉, ❈, ❇, ❆, ❅, ❄, ❃, ❂, ❁, ❀, ✿, ✾, ✽, ✼, ✻, ✺, ✹, ✸, ✷, ✶, ✵, ✴, ✳, ✲, ✱, ✰, ✯, ✮, ✭, ✬, ✫, ✪, ✩, ✧, ✦, ✥, ✤, ✣, ✢ ]</span><br><span class="line">  #方塊</span><br><span class="line">      &#39;&#x2F;fk&#39;: [ ▀, ▁, ▂, ▃, ▄, ▅, ▆, ▇, █, ▉, ▊, ▋, ▌, ▍, ▎, ▏, ▐, ░, ▒, ▓, ▔, ▕, ▖, ▗, ▘, ▙, ▚, ▛, ▜, ▝, ▞, ▟ ]</span><br><span class="line">  #幾何</span><br><span class="line">      &#39;&#x2F;jh&#39;: [ ■, □, ▢, ▣, ▤, ▥, ▦, ▧, ▨, ▩, ▪, ▫, ▬, ▭, ▮, ▯, ▰, ▱, ▲, △, ▴, ▵, ▶, ▷, ▸, ▹, ►, ▻, ▼, ▽, ▾, ▿, ◀, ◁, ◂, ◃, ◄, ◅, ◆, ◇, ◈, ◉, ◊, ○, ◌, ◍, ◎, ●, ◐, ◑, ◒, ◓, ◔, ◕, ◖, ◗, ◘, ◙, ◚, ◛, ◜, ◝, ◞, ◟, ◠, ◡, ◢, ◣, ◤, ◥, ◦, ◧, ◨, ◩, ◪, ◫, ◬, ◭, ◮, ◯, ◰, ◱, ◲, ◳, ◴, ◵, ◶, ◷, ◸, ◹, ◺, ◻, ◼, ◽, ◾, ◿ ]</span><br><span class="line">  #箭頭</span><br><span class="line">      &#39;&#x2F;jt&#39;: [ ←, ↚, →, ↛, ↑, ↓, ↔, ↮, ↕, ↖, ↗, ↘, ↙, ↜, ↝, ↞, ↟, ↠, ↡, ↢, ↣, ↤, ↥, ↦, ↧, ↨, ↩, ↪, ↫, ↬, ↭, ↯, ↰, ↱, ↲, ↳, ↴, ↵, ↶, ↷, ↸, ↹, ↺, ↻, ↼, ↽, ↾, ↿, ⇀, ⇁, ⇂, ⇃, ⇄, ⇅, ⇆, ⇇, ⇈, ⇉, ⇊, ⇋, ⇌, ⇐, ⇍, ⇑, ⇒, ⇏, ⇓, ⇔, ⇎, ⇕, ⇖, ⇗, ⇘, ⇙, ⇚, ⇛, ⇜, ⇝, ⇞, ⇟, ⇠, ⇡, ⇢, ⇣, ⇤, ⇥, ⇦, ⇧, ⇨, ⇩, ⇪, ⇫, ⇬, ⇭, ⇮, ⇯, ⇰, ⇱, ⇲, ⇳, ⇴, ⇵, ⇶, ⇷, ⇸, ⇹, ⇺, ⇻, ⇼, ⇽, ➔, ➘, ➙, ➚, ➛, ➜, ➝, ➞, ➟, ➠, ➡, ➢, ➣, ➤, ➥, ➦, ➧, ➨, ➩, ➪, ➫, ➬, ➭, ➮, ➱, ➲, ➳, ➴, ➵, ➶, ➷, ➸, ➹, ➺, ➻, ➼, ➽, ➾ ]</span><br><span class="line">  #數學</span><br><span class="line">      &#39;&#x2F;sx&#39;: [ ︴, －, ∈, ∏, ∑, ＋, ±, ÷, ×, ＜, ≮, ＝, ≠, ＞, ≯, ∕, √, ∝, ∞, ∟, ∠, ∥, ∧, ∨, ∩, ∪, ∫, ∮, ∴, ∵, ∷, ∽, ≈, ≌, ≒, ≡, ≤, ≥, ≦, ≧, ⊕, ⊙, ⊥, ⊿, ㏑, ㏒ ]</span><br><span class="line">  #數字+圈&#x2F;弧&#x2F;點</span><br><span class="line">      &#39;&#x2F;szq&#39;: [ ⓪, ①, ②, ③, ④, ⑤, ⑥, ⑦, ⑧, ⑨, ⑩, ⑪, ⑫, ⑬, ⑭, ⑮, ⑯, ⑰, ⑱, ⑲, ⑳, ㉑, ㉒, ㉓, ㉔, ㉕, ㉖, ㉗, ㉘, ㉙, ㉚, ㉛, ㉜, ㉝, ㉞, ㉟, ㊱, ㊲, ㊳, ㊴, ㊵, ㊶, ㊷, ㊸, ㊹, ㊺, ㊻, ㊼, ㊽, ㊾, ㊿, ⓿, ❶, ❷, ❸, ❹, ❺, ❻, ❼, ❽, ❾, ❿, ⓫, ⓬, ⓭, ⓮, ⓯, ⓰, ⓱, ⓲, ⓳, ⓴ ]</span><br><span class="line">      &#39;&#x2F;szh&#39;: [ ⑴, ⑵, ⑶, ⑷, ⑸, ⑹, ⑺, ⑻, ⑼, ⑽, ⑾, ⑿, ⒀, ⒁, ⒂, ⒃, ⒄, ⒅, ⒆, ⒇ ]</span><br><span class="line">      &#39;&#x2F;szd&#39;: [ ⒈, ⒉, ⒊, ⒋, ⒌, ⒍, ⒎, ⒏, ⒐, ⒑, ⒒, ⒓, ⒔, ⒕, ⒖, ⒗, ⒘, ⒙, ⒚, ⒛ ]</span><br><span class="line">  #字母+圈&#x2F;弧</span><br><span class="line">      &#39;&#x2F;zmq&#39;: [ ⓐ, Ⓐ, ⓑ, Ⓑ, ⓒ, Ⓒ, ⓓ, Ⓓ, ⓔ, Ⓔ, ⓕ, Ⓕ, ⓖ, Ⓖ, ⓗ, Ⓗ, ⓘ, Ⓘ, ⓙ, Ⓙ, ⓚ, Ⓚ, ⓛ, Ⓛ, ⓜ, Ⓜ, ⓝ, Ⓝ, ⓞ, Ⓞ, ⓟ, Ⓟ, ⓠ, Ⓠ, ⓡ, Ⓡ, ⓢ, Ⓢ, ⓣ, Ⓣ, ⓤ, Ⓤ, ⓥ, Ⓥ, ⓦ, Ⓦ, ⓧ, Ⓧ, ⓨ, Ⓨ, ⓩ, Ⓩ ]</span><br><span class="line">      &#39;&#x2F;zmh&#39;: [ ⒜, ⒝, ⒞, ⒟, ⒠, ⒡, ⒢, ⒣, ⒤, ⒥, ⒦, ⒧, ⒨, ⒩, ⒪, ⒫, ⒬, ⒭, ⒮, ⒯, ⒰, ⒱, ⒲, ⒳, ⒴, ⒵ ]</span><br><span class="line">  #數字、分數</span><br><span class="line">      &#39;&#x2F;0&#39;: [ 〇, 零, ₀, ⁰, ⓪, ⓿ , ０]</span><br><span class="line">      &#39;&#x2F;1&#39;: [ 一, 壹, ₁, ¹, Ⅰ, ⅰ, ①, ➀, ❶, ➊, ⓵, ⑴, ⒈, １, ㊀, ㈠, 弌, 壱, 幺, ㆒ ]</span><br><span class="line">      &#39;&#x2F;2&#39;: [ 二, 貳, ₂, ², Ⅱ, ⅱ, ②, ➁, ❷, ➋, ⓶, ⑵, ⒉, ２, ㊁, ㈡, 弍, 弐, 貮, 㒃, 㒳, 兩, 倆, ㆓]</span><br><span class="line">      &#39;&#x2F;3&#39;: [ 三, 叄, ₃, ³, Ⅲ, ⅲ, ③, ➂, ❸, ➌, ⓷, ⑶, ⒊, ３, ㊂, ㈢, 參, 参, 叁, 弎, 仨, ㆔]</span><br><span class="line">      &#39;&#x2F;4&#39;: [ 四, 肆, ₄, ⁴, Ⅳ, ⅳ, ④, ➃, ❹, ➍, ⓸, ⑷, ⒋, ４, ㊃, ㈣, 亖]</span><br><span class="line">      &#39;&#x2F;5&#39;: [ 五, 伍, ₅, ⁵, Ⅴ, ⅴ, ⑤, ➄, ❺, ➎, ⓹, ⑸, ⒌, ５, ㊄, ㈤, 㐅, 㠪, 𠄡 ]</span><br><span class="line">      &#39;&#x2F;6&#39;: [ 六, 陸, ₆, ⁶, Ⅵ, ⅵ, ⑥, ➅, ❻, ➏, ⓺, ⑹, ⒍, ６, ㊅, ㈥, ↅ]</span><br><span class="line">      &#39;&#x2F;7&#39;: [ 七, 柒, ₇, ⁷, Ⅶ, ⅶ, ⑦, ➆, ❼, ➐, ⓻, ⑺, ⒎, ７, ㊆, ㈦, 漆]</span><br><span class="line">      &#39;&#x2F;8&#39;: [ 八, 捌, ₈, ⁸, Ⅷ, ⅷ, ⑧, ➇, ❽, ➑, ⓼, ⑻, ⒏, ８, ㊇, ㈧ ]</span><br><span class="line">      &#39;&#x2F;9&#39;: [ 九, 玖, ₉, ⁹, Ⅸ, ⅸ, ⑨, ➈, ❾, ➒, ⓽, ⑼, ⒐, ９, ㊈, ㈨ ]</span><br><span class="line">      &#39;&#x2F;10&#39;: [ 十, 拾, ₁₀, ¹⁰, Ⅹ, ⅹ, ⑩, ➉, ❿, ➓, ⓾, ⑽, ⒑, １０, ㊉, ㈩, 什 ]</span><br><span class="line">      &#39;&#x2F;fs&#39;: [ ⅟, ½, ↉, ⅓, ⅔, ¼, ⅕, ⅖, ⅗, ⅘, ⅙, ⅚, ⅐, ⅛, ⅜, ⅝, ⅞, ⅑, ⅒ ]</span><br><span class="line">  #蘇州碼</span><br><span class="line">      &#39;&#x2F;szm&#39;: [ 〡, 〢, 〣, 〤, 〥, 〦, 〧, 〨, 〩, 〸, 〹, 〺 ]</span><br><span class="line">  #羅馬數字</span><br><span class="line">      &#39;&#x2F;lm&#39;: [ ⅰ, ⅱ, ⅲ, ⅳ, ⅴ, ⅵ, ⅶ, ⅷ, ⅸ, ⅹ, ⅺ, ⅻ, ⅼ, ⅽ, ⅾ, ⅿ ]</span><br><span class="line">      &#39;&#x2F;lmd&#39;: [ Ⅰ, Ⅱ, Ⅲ, Ⅳ, Ⅴ, Ⅵ, Ⅶ, Ⅷ, Ⅸ, Ⅹ, Ⅺ, Ⅻ, Ⅼ, Ⅽ, Ⅾ, Ⅿ ]</span><br><span class="line">  #拉丁</span><br><span class="line">      &#39;&#x2F;a&#39;: [ ₐ, ᵃ, ª, ᵄ, á, à, ȧ, â, ä, ǎ, ă, ā, ã, å, ą, ⱥ, ấ, ầ, ắ, ằ, ǡ, ǻ, ǟ, ẫ, ẵ, ả, ȁ, ȃ, ẩ, ẳ, ᶏ, ạ, ḁ, ậ, ẚ, ặ, ɐ, ɑ, ɒ, ᶛ, ᵅ ]</span><br><span class="line">      &#39;&#x2F;b&#39;: [ ᵇ, ḃ, ᵬ, ƀ, ɓ, ᶀ, ḅ, ḇ, ƃ, ᵦ, ᵝ, β ]</span><br><span class="line">      &#39;&#x2F;c&#39;: [ ᶜ, ć, ċ, ĉ, č, ç, ȼ, ḉ, ƈ, ᵓ, ɔ, ᶗ, ɕ, ᶝ ]</span><br><span class="line">      &#39;&#x2F;d&#39;: [ ᵈ, ḋ, ď, ď, ᵭ, ḑ, đ, ƌ, ɗ, ᶁ, ḍ, ᶑ, ḓ, ḏ, ð, ʤ, ƍ, ᶞ, ǳ, ǆ, ɖ, ʣ, ʥ, ȡ, ẟ ]</span><br><span class="line">      &#39;&#x2F;e&#39;: [ ₑ, ᵉ, é, è, ė, ê, ë, ě, ĕ, ē, ẽ, ę, ȩ, ɇ, ế, ề, ḗ, ḕ, ễ, ḝ, ẻ, ȅ, ȇ, ể, ẹ, ᶒ, ḙ, ḛ, ᶟ, ệ, ɛ, ǝ, ə, ₔ, ᵊ, ɚ, ɘ, ɜ, ɝ, ɞ, ʚ, ȝ, ᶾ, ᶕ, ᶚ, ᴈ, ᶓ, ᶔ, ᵋ, ᵌ, ⱸ ]</span><br><span class="line">      &#39;&#x2F;f&#39;: [ ᶠ, ḟ, ᵮ, ƒ, ᶂ, ﬀ, ﬃ, ﬄ, ﬁ, fʲ, ﬂ, ʩ, ɟ, ɸ, ᶲ, ᵩ, ᵠ ]</span><br><span class="line">      &#39;&#x2F;g&#39;: [ ᵍ, ᵷ, ǵ, ġ, ĝ, ǧ, ğ, ḡ, ģ, ǥ, ɠ, ᶃ, ɣ, ᶢ, ɡ, ˠ, ᵧ, ᵞ ]</span><br><span class="line">      &#39;&#x2F;h&#39;: [  ͪ, ḣ, ĥ, ḧ, ȟ, ḩ, ħ, ɦ, ḥ, ḫ, ẖ, ⱨ, ɥ, ᶣ, ʱ, ƕ, ʮ, ʯ, ꜧ, ɧ ]</span><br><span class="line">      &#39;&#x2F;i&#39;: [ ᵢ, ı, ᴉ, í, ì, î, ï, ǐ, ĭ, ī, ĩ, į, ɨ, ḯ, ᶤ, ỉ, ȉ, ȋ, ị, ᶖ, ḭ, ᵎ, ɩ, ᶥ, ᵼ, ĳ ]</span><br><span class="line">      &#39;&#x2F;j&#39;: [ ⱼ, ʲ, ȷ, ĵ, ǰ, ɉ, ɟ, ᶡ, ʄ, ᶨ, ʝ ]</span><br><span class="line">      &#39;&#x2F;k&#39;: [ ᵏ, ḱ, ǩ, ķ, ƙ, ᶄ, ḳ, ḵ, ⱪ, ʞ ]</span><br><span class="line">      &#39;&#x2F;l&#39;: [ ˡ, ĺ, ŀ, ľ, ɫ, ⱡ, ļ, ƚ, ł, ƛ, ᶅ, ᶪ, ᶩ, ḷ, ɭ, ḽ, ḻ, ḹ, ɬ, ɮ, ǉ, ỻ, ʪ, ʫ, ȴ ]</span><br><span class="line">      &#39;&#x2F;m&#39;: [ ᵐ, ḿ, ṁ, ᵯ, ᶬ, ɱ, ᶆ, ṃ, ɯ, ᵚ, ɰ, ᶭ, ᴟ ]</span><br><span class="line">      &#39;&#x2F;n&#39;: [ ⁿ, ń, ǹ, ṅ, ň, ñ, ᵰ, ņ, ᶮ, ɲ, ŉ, ƞ, ᶇ, ṇ, ɳ, ᶯ, ṋ, ṉ, ȵ ]</span><br><span class="line">      &#39;&#x2F;o&#39;: [ ₒ, ᵒ, º, ó, ò, ȯ, ô, ö, ǒ, ŏ, ō, õ, ǫ, ő, ố, ồ, ɵ, ø, ṓ, ṑ, ȱ, ṍ, ȫ, ổ, ọ, ớ, ờ, ỡ, ộ, ɷ, ở, ợ, ᵔ, ᵕ, œ, ȣ, ᴔ, ⱺ ]</span><br><span class="line">      &#39;&#x2F;p&#39;: [ ᵖ, ṕ, ṗ, ᵱ, ᵽ, ƥ, ᶈ ]</span><br><span class="line">      &#39;&#x2F;q&#39;: [ ʠ, ɋ, ȹ ]</span><br><span class="line">      &#39;&#x2F;r&#39;: [ ᵣ, ŕ, ṙ, ř, ᵲ, ŗ, ɍ, ᵳ, ɽ, ȑ, ȓ, ᶉ, ṛ, ṟ, ṝ, ɹ, ɺ, ɻ, ɼ, ɾ, ɿ, ʳ, ʴ, ʵ, ᵨ ]</span><br><span class="line">      &#39;&#x2F;s&#39;: [ ˢ, ś, ṡ, ŝ, š, ᵴ, ş, ṥ, ṧ, ᶳ, ʂ, ᶊ, ṣ, ș, ȿ, ṩ, ʃ, ᶴ, ƨ, ʆ, ʅ, ƪ, ß, ſ, ẛ ]</span><br><span class="line">      &#39;&#x2F;t&#39;: [ ᵗ, ṫ, ť, ᵵ, ţ, ƭ, ᶵ, ƫ, ṭ, ʈ, ț, ṱ, ṯ, ⱦ, ʇ, ʧ, ʨ, ᶿ, ȶ, ŧ ]</span><br><span class="line">      &#39;&#x2F;u&#39;: [ ᵤ, ᵘ, ú, ù, û, ü, ǔ, ŭ, ū, ũ, ů, ų, ű, ᶶ, ʉ, ǘ, ǜ, ǚ, ṹ, ǖ, ṻ, ủ, ȕ, ȗ, ư, ᶙ, ụ, ṳ, ứ, ừ, ṷ, ṵ, ữ, ʉ̞, ʊ, ᶷ, ᵙ, ử, ᵿ, ự, ᴝ, ᴞ, ᵫ ]</span><br><span class="line">      &#39;&#x2F;v&#39;: [ ᵥ, ᵛ, ṽ, ᶹ, ᶌ, ṿ, ⱴ, ʋ, ᶺ, ʌ ]</span><br><span class="line">      &#39;&#x2F;w&#39;: [ ʷ, ẃ, ẁ, ẇ, ŵ, ẅ, ẘ, ẉ, ƿ, ʍ, ⱳ ]</span><br><span class="line">      &#39;&#x2F;x&#39;: [ ₓ, ᶍ, ˣ, χ, ᵪ, ᵡ ]</span><br><span class="line">      &#39;&#x2F;y&#39;: [ ʸ, ý, ỳ, ẏ, ŷ, ÿ, ȳ, ỹ, ẙ, ɏ, ỷ, ƴ, ỵ, ʎ, ỿ ]</span><br><span class="line">      &#39;&#x2F;z&#39;: [ ᶻ, ź, ż, ẑ, ž, ᵶ, ƶ, ȥ, ᶎ, ᶼ, ẓ, ʐ, ɀ, ẕ, ⱬ, ʑ, ᶽ, ʒ ]</span><br><span class="line">  #上標、下標</span><br><span class="line">      &#39;&#x2F;sb&#39;: [ ⁰, ¹, ², ³, ⁴, ⁵, ⁶, ⁷, ⁸, ⁹, ˜, ⁺, ⁻, ⁼, ⁽, ⁾, ᴬ, ᵃ, ᵄ, ᵅ, ᶛ, ᴭ, ᵆ, ᴮ, ᴯ, ᵇ, ᵝ, ᶜ, ᵓ, ᶝ, ᴰ, ᵈ, ᶞ, ᵟ, ᴱ, ᵉ, ᴲ, ᵊ, ᵋ, ᶟ, ᵌ, ᶠ, ᶡ, ᶲ, ᵠ, ᴳ, ᵍ, ᶢ, ˠ, ᵞ, ᴴ, ʰ, ᶣ, ʱ, ᴵ, ⁱ, ᶤ, ᵎ, ᶥ, ᴶ, ʲ, ᶨ, ᴷ, ᵏ, ᴸ, ᶫ, ˡ, ᶩ, ᶪ, ᴹ, ᵐ, ᶬ, ᵚ, ᶭ, ᴺ, ᴻ, ⁿ, ᵑ, ᶮ, ᶯ, ᴼ, ᵒ, ᶱ, ᴽ, ᴾ, ᵖ, ᴿ, ʳ, ʶ, ʴ, ʵ, ˢ, ᶴ, ᶳ, ᵀ, ᵗ, ᶵ, ᶿ, ᵁ, ᵘ, ᶶ, ᶷ, ᵙ, ⱽ, ᵛ, ᶺ, ᶹ, ᵂ, ʷ, ˣ, ᵡ, ʸ, ᶻ, ᶾ, ᶽ, ᶼ ]</span><br><span class="line">      &#39;&#x2F;xb&#39;: [ ₀, ₁, ₂, ₃, ₄, ₅, ₆, ₇, ₈, ₉, ₊, ₋, ₌, ₍, ₎, ‸, ᴀ, ₐ, ᴁ, ʙ, ᴃ, ᵦ, ᴄ, ᴐ, ᴒ, ᴅ, ᴆ, ᴇ, ₑ, ₔ, ᵩ, ɢ, ʛ, ᴦ, ᵧ, ʜ, ₕ, ɪ, ᵻ, ᵢ, ᴊ, ⱼ, ᴋ, ₖ, ʟ, ₗ, ᴌ, ᴧ, ᴍ, ₘ, ꟺ, ɴ, ᴎ, ₙ, ᴏ, ₒ, ɶ, ʘ, ᴓ, ᴑ, ᴘ, ₚ, ᴨ, ᴪ, ʀ, ᵣ, ᴙ, ʁ, ᴚ, ᵨ, ₛ, ᴛ, ₜ, ᴜ, ᵤ, ᵾ, ᴠ, ᵥ, ᴡ, ₓ, ᵪ, ʏ, ᴢ, ᴣ ]</span><br><span class="line">  #希臘</span><br><span class="line">      &#39;&#x2F;xl&#39;: [ α, β, γ, δ, ε, ζ, η, θ, ι, κ, λ, μ, ν, ξ, ο, π, ρ, σ, ς, τ, υ, φ, χ, ψ, ω ]</span><br><span class="line">      &#39;&#x2F;xld&#39;: [ Α, Β, Γ, Δ, Ε, Ζ, Η, Θ, Ι, Κ, Λ, Μ, Ν, Ξ, Ο, Π, Ρ, Σ, Τ, Υ, Φ, Χ, Ψ, Ω ]</span><br><span class="line">  #俄語</span><br><span class="line">      &#39;&#x2F;ey&#39;: [ а, б, в, г, д, е, ё, ж, з, и, й, к, л, м, н, о, п, р, с, т, у, ф, х, ц, ч, ш, щ, ъ, ы, ь, э, ю, я ]</span><br><span class="line">      &#39;&#x2F;eyd&#39;: [ А, Б, В, Г, Д, Е, Ё, Ж, З, И, Й, К, Л, М, Н, О, П, Р, С, Т, У, Ф, Х, Ц, Ч, Ш, Щ, Ъ, Ы, Ь, Э, Ю, Я ]</span><br><span class="line">  #月份、日期、曜日等</span><br><span class="line">      &#39;&#x2F;yf&#39;: [ ㋀, ㋁, ㋂, ㋃, ㋄, ㋅, ㋆, ㋇, ㋈, ㋉, ㋊, ㋋ ]</span><br><span class="line">      &#39;&#x2F;rq&#39;: [ ㏠, ㏡, ㏢, ㏣, ㏤, ㏥, ㏦, ㏧, ㏨, ㏩, ㏪, ㏫, ㏬, ㏭, ㏮, ㏯, ㏰, ㏱, ㏲, ㏳, ㏴, ㏵, ㏶, ㏷, ㏸, ㏹, ㏺, ㏻, ㏼, ㏽, ㏾ ]</span><br><span class="line">      &#39;&#x2F;yr&#39;: [ 月, 火, 水, 木, 金, 土, 日, ㊊, ㊋, ㊌, ㊍, ㊎, ㊏, ㊐, ㊗, ㊡, ㈪, ㈫, ㈬, ㈭, ㈮, ㈯, ㈰, ㈷, ㉁, ㉀ ]</span><br><span class="line">  #時間</span><br><span class="line">      &#39;&#x2F;sj&#39;: [ ㍘, ㍙, ㍚, ㍛, ㍜, ㍝, ㍞, ㍟, ㍠, ㍡, ㍢, ㍣, ㍤, ㍥, ㍦, ㍧, ㍨, ㍩, ㍪, ㍫, ㍬, ㍭, ㍮, ㍯, ㍰ ]</span><br><span class="line">  #天干、地支、干支</span><br><span class="line">      &#39;&#x2F;tg&#39;: [ 甲, 乙, 丙, 丁, 戊, 己, 庚, 辛, 壬, 癸 ]</span><br><span class="line">      &#39;&#x2F;dz&#39;: [ 子, 丑, 寅, 卯, 辰, 巳, 午, 未, 申, 酉, 戌, 亥 ]</span><br><span class="line">      &#39;&#x2F;gz&#39;: [ 甲子, 乙丑, 丙寅, 丁卯, 戊辰, 己巳, 庚午, 辛未, 壬申, 癸酉, 甲戌, 乙亥, 丙子, 丁丑, 戊寅, 己卯, 庚辰, 辛巳, 壬午, 癸未, 甲申, 乙酉, 丙戌, 丁亥, 戊子, 己丑, 庚寅, 辛卯, 壬辰, 癸巳, 甲午, 乙未, 丙申, 丁酉, 戊戌, 己亥, 庚子, 辛丑, 壬寅, 癸卯, 甲辰, 乙巳, 丙午, 丁未, 戊申, 己酉, 庚戌, 辛亥, 壬子, 癸丑, 甲寅, 乙卯, 丙辰, 丁巳, 戊午, 己未, 庚申, 辛酉, 壬戌, 癸亥 ]</span><br><span class="line">  #節氣</span><br><span class="line">      &#39;&#x2F;jq&#39;: [ 立春, 雨水, 驚蟄, 春分, 清明, 穀雨, 立夏, 小滿, 芒種, 夏至, 小暑, 大暑, 立秋, 處暑, 白露, 秋分, 寒露, 霜降, 立冬, 小雪, 大雪, 冬至, 小寒, 大寒 ]</span><br><span class="line">  #單位</span><br><span class="line">      &#39;&#x2F;dw&#39;: [ Å, ℃, ％, ‰, ‱, °, ℉, ㏃, ㏆, ㎈, ㏄, ㏅, ㎝, ㎠, ㎤, ㏈, ㎗, ㎙, ㎓, ㎬, ㏉, ㏊, ㏋, ㎐, ㏌, ㎄, ㎅, ㎉, ㎏, ㎑, ㏍, ㎘, ㎞, ㏎, ㎢, ㎦, ㎪, ㏏, ㎸, ㎾, ㏀, ㏐, ㏓, ㎧, ㎨, ㎡, ㎥, ㎃, ㏔, ㎆, ㎎, ㎒, ㏕, ㎖, ㎜, ㎟, ㎣, ㏖, ㎫, ㎳, ㎷, ㎹, ㎽, ㎿, ㏁, ㎁, ㎋, ㎚, ㎱, ㎵, ㎻, ㏘, ㎩, ㎀, ㎊, ㏗, ㏙, ㏚, ㎰, ㎴, ㎺, ㎭, ㎮, ㎯, ㏛, ㏜, ㎔, ㏝, ㎂, ㎌, ㎍, ㎕, ㎛, ㎲, ㎶, ㎼ ]</span><br><span class="line">  #貨幣</span><br><span class="line">      &#39;&#x2F;hb&#39;: [ ￥, ¥, ¤, ￠, ＄, $, ￡, £, ৳, ฿, ₠, ₡, ₢, ₣, ₤, ₥, ₦, ₧, ₩, ₪, ₫, €, ₭, ₮, ₯, ₰, ₱, ₲, ₳, ₴, ₵, ₶, ₷, ₸, ₹, ₺, ₨, ﷼ ]</span><br><span class="line">  #結構、偏旁、康熙（部首）、筆畫、標點</span><br><span class="line">      &#39;&#x2F;jg&#39;: [ ⿰, ⿱, ⿲, ⿳, ⿴, ⿵, ⿶, ⿷, ⿸, ⿹, ⿺, ⿻, 〾 ]</span><br><span class="line">      &#39;&#x2F;pp&#39;: [ 乛, 冫, 丷, 龹, ⺌, 龸, 亻, 亼, 亽, 仒, 冖, 冂, 冃, 冄, 宀, 罒, 㓁, 罓, 冈, 凵, 厶, 刂, 勹, 匚, 匸, 卩, 阝, 厂, 丆, 广, 壬, 訁, 讠, 釒, 钅, 飠, 饣, 龺, 攵, 夂, 夊, 尢, 尣, 兂, 旡, 巜, 巛, 彐, 彑, 彡, 彳, 龰, 辶, 廴, 㞢, 忄, 㣺, 扌, 爫, 龵, 廾, 歺, 癶, 氵, 氺, 火, 灬, 爿, 丬, 疒, 牜, ⺶, 犭, 豕, 豸, 虍, 艹, 卝, 龷, 丗, 龶, 芈, 丵, 菐, 黹, 礻, 衤, 糸, 糹, 纟, 龻, 镸, 髟, 襾, 覀, 吅, 㗊, 㠭, 㸚, 叕]</span><br><span class="line">      &#39;&#x2F;kx&#39;: [ 一, 丨, 丶, 丿, 乙, 亅, 二, 亠, 人, 儿, 入, 八, 冂, 冖, 冫, 几, 凵, 刀, 力, 勹, 匕, 匚, 匸, 十, 卜, 卩, 厂, 厶, 又, 口, 囗, 土, 士, 夂, 夊, 夕, 大, 女, 子, 宀, 寸, 小, 尢, 尸, 屮, 山, 巛, 工, 己, 巾, 干, 幺, 广, 廴, 廾, 弋, 弓, 彐, 彡, 彳, 心, 戈, 戶, 手, 支, 攴, 文, 斗, 斤, 方, 无, 日, 曰, 月, 木, 欠, 止, 歹, 殳, 毋, 比, 毛, 氏, 气, 水, 火, 爪, 父, 爻, 爿, 片, 牙, 牛, 犬, 玄, 玉, 瓜, 瓦, 甘, 生, 用, 田, 疋, 疒, 癶, 白, 皮, 皿, 目, 矛, 矢, 石, 示, 禸, 禾, 穴, 立, 竹, 米, 糸, 缶, 网, 羊, 羽, 老, 而, 耒, 耳, 聿, 肉, 臣, 自, 至, 臼, 舌, 舛, 舟, 艮, 色, 艸, 虍, 虫, 血, 行, 衣, 襾, 見, 角, 言, 谷, 豆, 豕, 豸, 貝, 赤, 走, 足, 身, 車, 辛, 辰, 辵, 邑, 酉, 釆, 里, 金, 長, 門, 阜, 隶, 隹, 雨, 靑, 非, 面, 革, 韋, 韭, 音, 頁, 風, 飛, 食, 首, 香, 馬, 骨, 高, 髟, 鬥, 鬯, 鬲, 鬼, 魚, 鳥, 鹵, 鹿, 麥, 麻, 黃, 黍, 黑, 黹, 黽, 鼎, 鼓, 鼠, 鼻, 齊, 齒, 龍, 龜, 龠 ]</span><br><span class="line">      &#39;&#x2F;bh&#39;: [ ㇀, ㇁, ㇂, ㇃, ㇄, ㇅, ㇆, ㇇, ㇈, ㇉, ㇊, ㇋, ㇌, ㇍, ㇎, ㇏, ㇐, ㇑, ㇒, ㇓, ㇔, ㇕, ㇖, ㇗, ㇘, ㇙, ㇚, ㇛, ㇜, ㇝, ㇞, ㇟, ㇠, ㇡, ㇢, ㇣ ]</span><br><span class="line">      &#39;&#x2F;bd&#39;: [ ₋, ⁻, ―, ˗, ˉ, ＿, ﹍, ﹎, ．, ¡, ‼, ⁉, ¿, ؟, ⁈, ⁇, ､, ｡, 、, 。, 〃, 〄, 々, 〆, 〇, 〈, 〉, 《, 》, 「, 」, 『, 』, 【, 】, 〒, 〓, 〔, 〕, 〖, 〗, 〘, 〙, 〚, 〛, 〜, 〝, 〞, 〟, 〠, 〰, 〱, 〲, 〳, 〴, 〵, 〶, 〷, 〻, 〼, 〽 ]</span><br><span class="line">      &#39;&#x2F;bdz&#39;: [ ﹅, ﹆, ﹁, ﹂, ﹃, ﹄, ︙, ︱, ︻, ︼, ︗, ︘, ︵, ︶, ︷, ︸, ︹, ︺, ︿, ﹀, ︽, ︾, ︰, ︲, ︳, ︴, ﹉, ﹊, ﹋, ﹌, ﹍, ﹎, ﹏, ﹇, ﹈, ︐, ︑, ︒, ︔, ︕, ︖ ]</span><br><span class="line">  #拼音、註音、聲調</span><br><span class="line">      &#39;&#x2F;py&#39;: [ ā, á, ǎ, à, ō, ó, ǒ, ò, ê, ē, é, ě, è, ī, í, ǐ, ì, ū, ú, ǔ, ù, ü, ǖ, ǘ, ǚ, ǜ, , ń, ň,  ]</span><br><span class="line">      &#39;&#x2F;zy&#39;: [ ㄅ, ㄆ, ㄇ, ㄈ, ㄉ, ㄊ, ㄋ, ㄌ, ㄍ, ㄎ, ㄏ, ㄐ, ㄑ, ㄒ, ㄓ, ㄔ, ㄕ, ㄖ, ㄗ, ㄘ, ㄙ, ㄧ, ㄨ, ㄩ, ㄚ, ㄛ, ㄜ, ㄝ, ㄞ, ㄟ, ㄠ, ㄡ, ㄢ, ㄣ, ㄤ, ㄥ, ㄦ, ㄪ, ㄫ, ㄬ, ㄭ, ㆠ, ㆡ, ㆢ, ㆣ, ㆤ, ㆥ, ㆦ, ㆧ, ㆨ, ㆩ, ㆪ, ㆫ, ㆬ, ㆭ, ㆮ, ㆯ, ㆰ, ㆱ, ㆲ, ㆳ, ㆴ, ㆵ, ㆶ, ㆷ ]</span><br><span class="line">      &#39;&#x2F;sd&#39;: [ ˉ, ˊ, ˇ, ˋ, ˆ, ˙, ˜, ˥, ˦, ˧, ˨, ˩, ꜀, ꜁, ꜂, ꜃, ꜄, ꜅, ꜆, ꜇ ]</span><br><span class="line">  #漢字+圈&#x2F;弧</span><br><span class="line">      &#39;&#x2F;hzq&#39;: [ ㊀, ㊁, ㊂, ㊃, ㊄, ㊅, ㊆, ㊇, ㊈, ㊉, ㊊, ㊋, ㊌, ㊍, ㊎, ㊏, ㊐, ㊑, ㊒, ㊓, ㊔, ㊕, ㊖, ㊗, ㊘, ㊙, ㊚, ㊛, ㊜, ㊝, ㊞, ㊟, ㊠, ㊡, ㊢, ㊣, ㊤, ㊥, ㊦, ㊧, ㊨, ㊩, ㊪, ㊫, ㊬, ㊭, ㊮, ㊯, ㊰, ㉄, ㉅, ㉆, ㉇ ]</span><br><span class="line">      &#39;&#x2F;hzh&#39;: [ ㈠, ㈡, ㈢, ㈣, ㈤, ㈥, ㈦, ㈧, ㈨, ㈩, ㈪, ㈫, ㈬, ㈭, ㈮, ㈯, ㈰, ㈱, ㈲, ㈳, ㈴, ㈵, ㈶, ㈷, ㈸, ㈹, ㈺, ㈻, ㈼, ㈽, ㈾, ㈿, ㉀, ㉁, ㉂, ㉃ ]</span><br><span class="line">  #いろは順</span><br><span class="line">      &#39;&#x2F;iro&#39;: [ い, ろ, は, に, ほ, へ, と, ち, り, ぬ, る, を, わ, か, よ, た, れ, そ, つ, ね, な, ら, む, う, ゐ, の, お, く, や, ま, け, ふ, こ, え, て, あ, さ, き, ゆ, め, み, し, ゑ, ひ, も, せ, す ]</span><br><span class="line">  #假名</span><br><span class="line">      &#39;&#x2F;jm&#39;: [ あ, ぁ, い, ぃ, う, ぅ, え, ぇ, お, ぉ, か, ゕ, が, き, ぎ, く, ぐ, け, ゖ, げ, こ, ご, さ, ざ, し, じ, す, ず, せ, ぜ, そ, ぞ, た, だ, ち, ぢ, つ, っ, づ, て, で, と, ど, な, に, ぬ, ね, の, は, ば, ぱ, ひ, び, ぴ, ふ, ぶ, ぷ, へ, べ, ぺ, ほ, ぼ, ぽ, ま, み, む, め, も, や, ゃ, ゆ, ゅ, よ, ょ, ら, り, る, れ, ろ, わ, ゎ, ゐ, ゔ, ゑ, を, ん, ・, ー, ゝ, ゞ, ゟ ]</span><br><span class="line">      &#39;&#x2F;pjm&#39;: [ ア, ァ, イ, ィ, ウ, ゥ, エ, ェ, オ, ォ, カ, ヵ, ガ, キ, ギ, ク, グ, ケ, ヶ, ゲ, コ, ゴ, サ, ザ, シ, ジ, ス, ズ, セ, ゼ, ソ, ゾ, タ, ダ, チ, ヂ, ツ, ッ, ヅ, テ, デ, ト, ド, ナ, ニ, ヌ, ネ, ノ, ハ, バ, パ, ヒ, ビ, ピ, フ, ブ, プ, ヘ, ベ, ペ, ホ, ボ, ポ, マ, ミ, ム, メ, モ, ヤ, ャ, ユ, ュ, ヨ, ョ, ラ, リ, ル, レ, ロ, ワ, ヮ, ヰ, ヸ, ヴ, ヱ, ヹ, ヲ, ヺ, ン, ・, ー, ヽ, ヾ, ヿ, ㇰ, ㇱ, ㇲ, ㇳ, ㇴ, ㇵ, ㇶ, ㇷ, ㇸ, ㇹ, ㇺ, ㇻ, ㇼ, ㇽ, ㇾ, ㇿ ]</span><br><span class="line">      &#39;&#x2F;jmk&#39;: [ か, ゕ, き, く, け, ゖ, こ, カ, ヵ, キ, ク, ケ, ヶ, コ ]</span><br><span class="line">      &#39;&#x2F;jmg&#39;: [ が, ぎ, ぐ, げ, ご, ガ, ギ, グ, ゲ, ゴ ]</span><br><span class="line">      &#39;&#x2F;jms&#39;: [ さ, し, す, せ, そ, サ, シ, ス, セ, ソ ]</span><br><span class="line">      &#39;&#x2F;jmz&#39;: [ ざ, じ, ず, ぜ, ぞ, ザ, ジ, ズ, ゼ, ゾ ]</span><br><span class="line">      &#39;&#x2F;jmt&#39;: [ た, ち, つ, っ, て, と, タ, チ, ツ, ッ, テ, ト ]</span><br><span class="line">      &#39;&#x2F;jmd&#39;: [ だ, ぢ, づ, で, ど, ダ, ヂ, ヅ, デ, ド ]</span><br><span class="line">      &#39;&#x2F;jmn&#39;: [ な, に, ぬ, ね, の, ん, ナ, ニ, ヌ, ネ, ノ, ン ]</span><br><span class="line">      &#39;&#x2F;jmh&#39;: [ は, ひ, ふ, へ, ほ, ハ, ヒ, フ, ヘ, ホ ]</span><br><span class="line">      &#39;&#x2F;jmb&#39;: [ ば, び, ぶ, べ, ぼ, バ, ビ, ブ, ベ, ボ ]</span><br><span class="line">      &#39;&#x2F;jmp&#39;: [ ぱ, ぴ, ぷ, ぺ, ぽ, パ, ピ, プ, ペ, ポ ]</span><br><span class="line">      &#39;&#x2F;jmm&#39;: [ ま, み, む, め, も, マ, ミ, ム, メ, モ ]</span><br><span class="line">      &#39;&#x2F;jmy&#39;: [ や, ゃ, ゆ, ゅ, よ, ょ, ヤ, ャ, ユ, ュ, ヨ, ョ ]</span><br><span class="line">      &#39;&#x2F;jmr&#39;: [ ら, り, る, れ, ろ, ラ, リ, ル, レ, ロ ]</span><br><span class="line">      &#39;&#x2F;jmw&#39;: [ わ, ゐ, ゑ, を, ワ, ヰ, ヱ, ヲ ]</span><br><span class="line">      &#39;&#x2F;jma&#39;: [ あ, か, が, さ, ざ, た, だ, な, は, ば, ぱ, ま, や, ら, わ, ア, カ, ガ, サ, ザ, タ, ダ, ナ, ハ, バ, パ, マ, ヤ, ラ, ワ ]</span><br><span class="line">      &#39;&#x2F;jmi&#39;: [ い, き, ぎ, し, じ, ち, ぢ, に, ひ, び, ぴ, み, り, ゐ, イ, キ, ギ, シ, ジ, チ, ヂ, ニ, ヒ, ビ, ピ, ミ, リ, ヰ ]</span><br><span class="line">      &#39;&#x2F;jmu&#39;: [ う, く, ぐ, す, ず, つ, づ, ぬ, ふ, ぶ, ぷ, む, る, ウ, ク, グ, ス, ズ, ツ, ヅ, ヌ, フ, ブ, プ, ム, ル ]</span><br><span class="line">      &#39;&#x2F;jme&#39;: [ え, け, げ, せ, ぜ, て, で, ね, へ, べ, ぺ, め, れ, ゑ, エ, ケ, ゲ, セ, ゼ, テ, デ, ネ, ヘ, ベ, ペ, メ, レ, ヱ ]</span><br><span class="line">      &#39;&#x2F;jmo&#39;: [ お, こ, ご, そ, ぞ, と, ど, の, ほ, ぼ, ぽ, も, ろ, を, オ, コ, ゴ, ソ, ゾ, ト, ド, ノ, ホ, ボ, ポ, モ, ロ, ヲ ]</span><br><span class="line">  #假名+圈</span><br><span class="line">      &#39;&#x2F;jmq&#39;: [ ㋐, ㋑, ㋒, ㋓, ㋔, ㋕, ㋖, ㋗, ㋘, ㋙, ㋚, ㋛, ㋜, ㋝, ㋞, ㋟, ㋠, ㋡, ㋢, ㋣, ㋤, ㋥, ㋦, ㋧, ㋨, ㋩, ㋪, ㋫, ㋬, ㋭, ㋮, ㋯, ㋰, ㋱, ㋲, ㋳, ㋴, ㋵, ㋶, ㋷, ㋸, ㋹, ㋺, ㋻, ㋼, ㋽, ㋾ ]</span><br><span class="line">  #假名+半角</span><br><span class="line">      &#39;&#x2F;jmbj&#39;: [ ｱ, ｧ, ｲ, ｨ, ｳ, ｩ, ｴ, ｪ, ｵ, ｫ, ｶ, ｷ, ｸ, ｹ, ｺ, ｻ, ｼ, ｽ, ｾ, ｿ, ﾀ, ﾁ, ﾂ, ｯ, ﾃ, ﾄ, ﾅ, ﾆ, ﾇ, ﾈ, ﾉ, ﾊ, ﾋ, ﾌ, ﾍ, ﾎ, ﾏ, ﾐ, ﾑ, ﾒ, ﾓ, ﾔ, ｬ, ﾕ, ｭ, ﾖ, ｮ, ﾗ, ﾘ, ﾙ, ﾚ, ﾛ, ﾜ, ｦ, ﾝ, ･, ｰ, ﾞ, ﾟ ]</span><br><span class="line">  #韓文</span><br><span class="line">      &#39;&#x2F;hw&#39;: [ ㄱ, ㄴ, ㄷ, ㄹ, ㅁ, ㅂ, ㅅ, ㅇ, ㅈ, ㅊ, ㅋ, ㅌ, ㅍ, ㅎ ]</span><br><span class="line">  #韓文+圈&#x2F;弧</span><br><span class="line">      &#39;&#x2F;hwq&#39;: [ ㉠, ㉡, ㉢, ㉣, ㉤, ㉥, ㉦, ㉧, ㉨, ㉩, ㉪, ㉫, ㉬, ㉭, ㉮, ㉯, ㉰, ㉱, ㉲, ㉳, ㉴, ㉵, ㉶, ㉷, ㉸, ㉹, ㉺, ㉻, ㉼, ㉽, ㉾, ㉿ ]</span><br><span class="line">      &#39;&#x2F;hwh&#39;: [ ㈀, ㈁, ㈂, ㈃, ㈄, ㈅, ㈆, ㈇, ㈈, ㈉, ㈊, ㈋, ㈌, ㈍, ㈎, ㈏, ㈐, ㈑, ㈒, ㈓, ㈔, ㈕, ㈖, ㈗, ㈘, ㈙, ㈚, ㈛, ㈜, ㈝, ㈞ ]</span><br><span class="line">      &#39;&#x2F;wo&#39; : [woodpenker, woodpenker@163.com, woodpenker5@gmail.com]</span><br><span class="line">  recognizer:</span><br><span class="line">    patterns:</span><br><span class="line">      email: &quot;^[A-Za-z][-_.0-9A-Za-z]*@.*$&quot;</span><br><span class="line">      uppercase: &quot;[A-Z][-_+.&#39;0-9A-Za-z]*$&quot;</span><br><span class="line">      url: &quot;^(www[.]|https?:|ftp[.:]|mailto:|file:).*$|^[a-z]+[.].+$&quot;</span><br><span class="line">  schema_list:</span><br><span class="line">    - schema: luna_pinyin_simp</span><br><span class="line">    - schema: luna_pinyin</span><br><span class="line">  style:</span><br><span class="line">    color_scheme: light</span><br><span class="line">    font_point: 17</span><br><span class="line">    horizontal: false</span><br><span class="line">    label_font_point: 17</span><br><span class="line">  switcher:</span><br><span class="line">    abbreviate_options: true</span><br><span class="line">    caption: &quot;〔方案選單〕&quot;</span><br><span class="line">    fold_options: true</span><br><span class="line">    hotkeys:</span><br><span class="line">    #   - &quot;Control+grave&quot;</span><br><span class="line">    #   - &quot;Control+Shift+grave&quot;</span><br><span class="line">      - &quot;Control+Shift+F4&quot;</span><br><span class="line">    option_list_separator: &quot;／&quot;</span><br><span class="line">    save_options:</span><br><span class="line">      - full_shape</span><br><span class="line">      - ascii_punct</span><br><span class="line">      - simplification</span><br><span class="line">      - extended_charset</span><br></pre></td></tr></table></figure>

<p>而词库汇集了一堆, 有需要的我再分享出来吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">luna_pinyin.biaoqing.dict.yaml     luna_pinyin.history.dict.yaml  luna_pinyin.sgplus.dict.yaml    net.userdb.txt</span><br><span class="line">luna_pinyin.chat.dict.yaml         luna_pinyin.moba.dict.yaml     luna_pinyin.sgplus.userdb.txt   sg2.userdb.txt</span><br><span class="line">easy_en.dict.yaml            luna_pinyin.cn_en.dict.yaml        luna_pinyin.movie.dict.yaml    luna_pinyin.shopping.dict.yaml  squirrel.custom.yaml</span><br><span class="line">easy_en.schema.yaml          luna_pinyin.computer.dict.yaml     luna_pinyin.music.dict.yaml    luna_pinyin_simp.custom.yaml    stroke.schema.yaml</span><br><span class="line">easy_en.userdb               luna_pinyin.custom.yaml            luna_pinyin.net.dict.yaml      luna_pinyin_tw.schema.yaml      symbols.yaml</span><br><span class="line">easy_en.userdb.txt           luna_pinyin.english.dict.yaml      luna_pinyin.place.dict.yaml    luna_pinyin.userdb              user.yaml</span><br><span class="line">easy_en.userdb.userdb.txt    luna_pinyin.extended.dict.yaml     luna_pinyin.poetry.dict.yaml   luna_pinyin.userdb.txt</span><br><span class="line">extend.userdb.txt            luna_pinyin.extended.table.txt     luna_pinyin.prism.txt          luna_pinyin.userdb.userdb.txt</span><br><span class="line">luna_pinyin.extra_hanzi.dict.yaml  luna_pinyin.sgmain.dict.yaml   luna_pinyin.user.dict.yaml</span><br><span class="line">luna_pinyin.anime.dict.yaml  luna_pinyin.game.dict.yaml         luna_pinyin.sgplus2.dict.yaml  luna_pinyin.website.dict.yaml</span><br></pre></td></tr></table></figure>

<p>最近我换到了<code>Fcitx5</code>下, 真的感觉很爽啊! 而且安装起来要方便多了, 使用<code>dnf</code>就搞定, 具体的方法请自行谷歌吧. 也可以参考<a href="https://www.zhihu.com/question/333951476/answer/1280162871" target="_blank" rel="noopener">知乎</a><br>和<a href="https://yanqiyu.info/2020/08/30/fcitx5-fedora/" target="_blank" rel="noopener">Fedora 32 用上 Fcitx 5</a></p>
<p>这个环境变量一定要设置, 请参考<a href="https://yanqiyu.info/2020/08/30/fcitx5-fedora/" target="_blank" rel="noopener">Fedora 32 用上 Fcitx 5</a> 操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INPUT_METHOD&#x3D;fcitx5</span><br><span class="line">GTK_IM_MODULE&#x3D;fcitx5</span><br><span class="line">QT_IM_MODULE&#x3D;fcitx5</span><br><span class="line">XMODIFIERS&#x3D;@im&#x3D;fcitx5</span><br></pre></td></tr></table></figure>

<p>另外, 我在<code>$HOME/.xprofile</code>下也配置了<code>fcitx5</code>的设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export XIM&#x3D;fcitx5                                                                                                                                              </span><br><span class="line">export XIM_PROGRAM&#x3D;fcitx5                                                                                                                                      </span><br><span class="line">export XMODIFIERS&#x3D;@im&#x3D;fcitx                                                                                                                                    </span><br><span class="line">export GTK_IM_MODULE&#x3D;fcitx5                                                                                                                                    </span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx5                                                                                                                                     </span><br><span class="line">export QT4_IM_MODULE&#x3D;fcitx5</span><br></pre></td></tr></table></figure>

<p><em>ps: 偶尔可能会出现无法输入中文的情况, 我建议是关闭需要的输入的程序再重新启动一下就行.</em> </p>
<h2 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h2><p>我的锁屏使用的是I3-lock-color. 效果图类似:</p>
<p><img src="https://github.com/Raymo111/i3lock-color/raw/master/screenshot.png" alt="官方效果图"></p>
<p>我为了实现开启锁屏后自动重置大写状态为关闭(避免重新登录时输入密码是大写的尴尬), 锁屏一定时间后就自动关闭显示器显示, 锁屏时联动番茄计时器重置计时时间这三个效果.我对i3lock-color的启动脚本做了些修改, 首先锁屏前重置<code>Caps Lock</code>的状态为关闭:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"1"</span> -eq <span class="string">"<span class="variable">$(ls /sys/class/leds/*capslock/brightness|xargs -I &#123;&#125; cat &#123;&#125;| awk 'NR==1&#123;print $0&#125;')</span>"</span> ];<span class="keyword">then</span>                                                     </span><br><span class="line">    xdotool key Caps_Lock                                                                                                                                      </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>之后在锁屏时间超过300秒以后,自动执行关闭屏幕显示的操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c=0</span><br><span class="line"><span class="keyword">while</span> pgrep i3lock                                                                                                                                             </span><br><span class="line"><span class="keyword">do</span>                                                                                                                                                             </span><br><span class="line">    c=$((c+1))                                                                                                                                                 </span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$c</span>"</span> -gt <span class="string">"20"</span> ]];<span class="keyword">then</span>                                                                                                                                </span><br><span class="line">    ┆   xset dpms force off                                                                                                                                    </span><br><span class="line">    <span class="keyword">fi</span>                                                                                                                                                         </span><br><span class="line">    sleep 15                                                                                                                                                   </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这其中还加入我对我自己开发的定时提醒程序的状态重置操作:<code>/usr/bin/pomodoro client reset</code><br>完整的逻辑就是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">B=<span class="string">'#00000000'</span>  <span class="comment"># blank                                                                                                                                         </span></span><br><span class="line">C=<span class="string">'#ffffff22'</span>  <span class="comment"># clear ish                                                                                                                                     </span></span><br><span class="line">D=<span class="string">'#66ff33ee'</span>  <span class="comment"># default                                                                                                                                       </span></span><br><span class="line">T=<span class="string">'#ff6600ee'</span>  <span class="comment"># text                                                                                                                                          </span></span><br><span class="line">W=<span class="string">'#ff0000bb'</span>  <span class="comment"># wrong                                                                                                                                         </span></span><br><span class="line">V=<span class="string">'#bb00bbbb'</span>  <span class="comment"># verifying </span></span><br><span class="line"><span class="keyword">if</span> pgrep i3lock;<span class="keyword">then</span>                                                                                                                                           </span><br><span class="line">    <span class="built_in">exit</span>                                                                                                                                                       </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">/usr/bin/pomodoro client reset                                                                                                                                 </span><br><span class="line">/usr/bin/pomodoro client pause                                                                                                                                 </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"1"</span> -eq <span class="string">"<span class="variable">$(ls /sys/class/leds/*capslock/brightness|xargs -I &#123;&#125; cat &#123;&#125;| awk 'NR==1&#123;print $0&#125;')</span>"</span> ];<span class="keyword">then</span>                                                     </span><br><span class="line">    xdotool key Caps_Lock                                                                                                                                      </span><br><span class="line"><span class="keyword">fi</span>              </span><br><span class="line">i3lock-color \                                                                                                                                                 </span><br><span class="line">    --insidevercolor=<span class="variable">$C</span>   \                                                                                                                                    </span><br><span class="line">    --ringvercolor=<span class="variable">$V</span>     \                                                                                                                                    </span><br><span class="line">    \                                                                                                                                                          </span><br><span class="line">    --insidewrongcolor=<span class="variable">$C</span> \                                                                                                                                    </span><br><span class="line">    --ringwrongcolor=<span class="variable">$W</span>   \                                                                                                                                    </span><br><span class="line">    \                                                                                                                                                          </span><br><span class="line">    --insidecolor=<span class="variable">$B</span>      \                                                                                                                                    </span><br><span class="line">    --ringcolor=<span class="variable">$D</span>        \                                                                                                                                    </span><br><span class="line">    --linecolor=<span class="variable">$B</span>        \                                                                                                                                    </span><br><span class="line">    --separatorcolor=<span class="variable">$D</span>   \                                                                                                                                    </span><br><span class="line">    \                                                                                                                                                          </span><br><span class="line">    --verifcolor=<span class="variable">$T</span>        \                                                                                                                                   </span><br><span class="line">    --wrongcolor=<span class="variable">$T</span>        \                                                                                                                                   </span><br><span class="line">    --timecolor=<span class="variable">$T</span>        \                                                                                                                                    </span><br><span class="line">    --datecolor=<span class="variable">$T</span>        \                                                                                                                                    </span><br><span class="line">    --layoutcolor=<span class="variable">$T</span>      \                                                                                                                                    </span><br><span class="line">    --keyhlcolor=<span class="variable">$W</span>       \                                                                                                                                    </span><br><span class="line">    --bshlcolor=<span class="variable">$W</span>        \                                                                                                                                    </span><br><span class="line">    \                                                                                                                                                          </span><br><span class="line">    --screen 1            \                                                                                                                                    </span><br><span class="line">    --blur 5              \                                                                                                                                    </span><br><span class="line">    --clock               \                                                                                                                                    </span><br><span class="line">    --indicator           \                                                                                                                                    </span><br><span class="line">    --timestr=<span class="string">"%H:%M:%S"</span>  \                                                                                                                                    </span><br><span class="line">    --datestr=<span class="string">"%Y-%m-%d"</span> \                                                                                                                                     </span><br><span class="line">    --keylayout 2                                                                                                                                              </span><br><span class="line">c=0                                                                                                                                                            </span><br><span class="line"><span class="keyword">while</span> pgrep i3lock                                                                                                                                             </span><br><span class="line"><span class="keyword">do</span>                                                                                                                                                             </span><br><span class="line">    c=$((c+1))                                                                                                                                                 </span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$c</span>"</span> -gt <span class="string">"20"</span> ]];<span class="keyword">then</span>                                                                                                                                </span><br><span class="line">    ┆   xset dpms force off                                                                                                                                    </span><br><span class="line">    <span class="keyword">fi</span>                                                                                                                                                         </span><br><span class="line">    sleep 15                                                                                                                                                   </span><br><span class="line"><span class="keyword">done</span>                                                                                                                                                           </span><br><span class="line">/usr/bin/pomodoro client reset                                                                                                                                 </span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>这个脚本保存为<code>lockscreen.sh</code></p>
<p>在I3的配置中添加快捷按键, 之后就可以用<code>$mod+Ctrl+l</code>来开启锁屏了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+Ctrl+l exec --no-startup-id $HOME&#x2F;.config&#x2F;i3&#x2F;lockscreen.sh</span><br></pre></td></tr></table></figure>

<h2 id="快捷程序启动"><a href="#快捷程序启动" class="headerlink" title="快捷程序启动"></a>快捷程序启动</h2><p>为了快捷启动程序, 我使用了<code>rofi</code>这个工具, 效果图可参考官方: </p>
<p><img src="https://camo.githubusercontent.com/90c5ab1d22784c7f8f59369cecd1c282ceda39ee9e7a8a8fa370990ddd4a7082/68747470733a2f2f64617661746f7269756d2e6769746875622e696f2f726f66692f696d616765732f726f66692f77696e646f772d6c6973742e706e67" alt="效果图1"></p>
<p><img src="https://camo.githubusercontent.com/739e64493bf796b2c0f1f8f1a38e70764e9f1d048ac66b2d77eeb553d02f9f84/68747470733a2f2f64617661746f7269756d2e6769746875622e696f2f726f66692f696d616765732f726f66692f72756e2d6469616c6f672e706e67" alt="效果图2"></p>
<p>I3的配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bindsym $mod+d exec rofi -show drun                                                                                                                            </span><br><span class="line">bindsym $mod+Shift+d exec rofi -show run                                                                                                                       </span><br><span class="line">bindsym $mod+Shift+s exec rofi -show ssh</span><br></pre></td></tr></table></figure>
<p>这样每次需要启动一个程序的时候, 使用<code>$mod+d</code>唤起<code>rofi</code>来进行搜索即可启动.</p>
<h2 id="Polybar配置"><a href="#Polybar配置" class="headerlink" title="Polybar配置"></a>Polybar配置</h2><p>我使用<code>Polybar</code>替代默认了的<code>i3bar</code>, <code>Polybar</code>提供了很多很有趣的功能和模块, 折腾也是一次又一次..我这里就说说我自己常用的几个模块的魔改, 有空我再分享一下我的<code>Polybar</code>配置</p>
<h4 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h4><p>这个是折腾很久的, 因为找各种icon图标字体很麻烦, 以下是我使用到的主要字体:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-0 &#x3D; &quot;Font Awesome,Font Awesome Regular:style&#x3D;Regular:size&#x3D;10:scale&#x3D;10;0&quot;                                                                                  </span><br><span class="line">font-1 &#x3D; &quot;Font Awesome 5 Brands,Font Awesome 5 Brands Regular:style&#x3D;Regular:size&#x3D;10:scale&#x3D;10;1&quot;                                                                </span><br><span class="line">font-2 &#x3D; &quot;Font Awesome 5 Free,Font Awesome 5 Free Regular:style&#x3D;Regular:size&#x3D;10:scale&#x3D;10;2&quot;                                                                    </span><br><span class="line">font-3 &#x3D; &quot;WenQuanYi Bitmap Song:style&#x3D;Regular:size&#x3D;10:scale&#x3D;10;3&quot;                                                                                              </span><br><span class="line">font-4 &#x3D; &quot;Microsoft YaHei,微软雅黑:style&#x3D;Regular:size&#x3D;12:scale&#x3D;12;4&quot;                                                                                           </span><br><span class="line">font-5 &#x3D; &quot;Siji:style&#x3D;Regular:size&#x3D;12:scale&#x3D;18;5&quot;                                                                                                               </span><br><span class="line">font-6 &#x3D; &quot;Hack:style&#x3D;Regular:size&#x3D;12:scale&#x3D;10;6&quot;                                                                                                               </span><br><span class="line">font-7 &#x3D; &quot;Weather Icons:size&#x3D;12;7&quot;                                                                                                                             </span><br><span class="line">font-8 &#x3D; &quot;Font Awesome,Font Awesome Regular:style&#x3D;Regular:size&#x3D;8:scale&#x3D;8;8&quot;                                                                                    </span><br><span class="line">font-9 &#x3D; &quot;Microsoft YaHei,微软雅黑:style&#x3D;Regular:size&#x3D;9:scale&#x3D;9;9&quot;</span><br></pre></td></tr></table></figure>

<h4 id="电源管理-重启-关机-登出以及虚拟机的自动保存"><a href="#电源管理-重启-关机-登出以及虚拟机的自动保存" class="headerlink" title="电源管理-重启/关机/登出以及虚拟机的自动保存"></a>电源管理-重启/关机/登出以及虚拟机的自动保存</h4><p>我在I3中设置了键盘控制关机的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">########################                                                                                                                                       </span><br><span class="line"># Power menu                                                                                                                                                   </span><br><span class="line">set $exec exec --no-startup-id                                                                                                                                 </span><br><span class="line">set $s_exit         &quot;(l)ogout&#x2F;(s)hut down&#x2F;(r)eboot&quot;                                                                                                            </span><br><span class="line">set $s_rconf        &quot;Reboot?&quot;                                                                                                                                  </span><br><span class="line">set $s_sconf        &quot;Shut Down?&quot;                                                                                                                               </span><br><span class="line">set $s_lconf        &quot;Logout?&quot;                                                                                                                                  </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">bindsym $mod+Shift+e mode $s_exit                                                                                                                              </span><br><span class="line">mode $s_exit&#123;                                                                                                                                                  </span><br><span class="line">    bindsym l mode $s_lconf                                                                                                                                    </span><br><span class="line">    bindsym r mode $s_rconf                                                                                                                                    </span><br><span class="line">    bindsym s mode $s_sconf                                                                                                                                    </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">    bindsym Escape mode &quot;default&quot;                                                                                                                              </span><br><span class="line">    bindsym Return mode &quot;default&quot;                                                                                                                              </span><br><span class="line">    bindsym $mod+Shift+e mode &quot;default&quot;                                                                                                                        </span><br><span class="line">&#125;                                                                                                                                                              </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">mode $s_lconf&#123;                                                                                                                                                 </span><br><span class="line">    bindsym Return $exec ~&#x2F;.config&#x2F;i3&#x2F;powermanager.sh exit                                                                                                     </span><br><span class="line">    bindsym Escape mode $s_exit                                                                                                                                </span><br><span class="line">&#125;                                                                                                                                                              </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">mode $s_rconf&#123;                                                                                                                                                 </span><br><span class="line">    bindsym Return $exec ~&#x2F;.config&#x2F;i3&#x2F;powermanager.sh reboot                                                                                                   </span><br><span class="line">    bindsym Escape mode $s_exit                                                                                                                                </span><br><span class="line">&#125;                                                                                                                                                              </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">mode $s_sconf&#123;                                                                                                                                                 </span><br><span class="line">    bindsym Return $exec ~&#x2F;.config&#x2F;i3&#x2F;powermanager.sh poweroff                                                                                                 </span><br><span class="line">    bindsym Escape mode $s_exit                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我就可以通过<code>$mod+Shift+e</code>来选择关机/重启/登出. </p>
<p>同时在<code>Polybar</code>中也设置了一个模块:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module&#x2F;powermenu]                                                                                                                                             </span><br><span class="line">type &#x3D; custom&#x2F;menu                                                                                                                                             </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">expand-right &#x3D; true                                                                                                                                            </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">format-spacing &#x3D; 1                                                                                                                                             </span><br><span class="line">format-underline &#x3D; #BF616A                                                                                                                                     </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">label-open &#x3D; &quot;&quot;                                                                                                                                              </span><br><span class="line">label-open-foreground &#x3D; #ECEFF4                                                                                                                                </span><br><span class="line">label-close &#x3D; &quot; X &quot;                                                                                                                                            </span><br><span class="line">label-close-foreground &#x3D; #EBCB8B                                                                                                                               </span><br><span class="line">label-separator &#x3D; |                                                                                                                                            </span><br><span class="line">label-separator-foreground &#x3D; #A3BE8C                                                                                                                           </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">menu-0-0 &#x3D; &quot;Reboot&quot;                                                                                                                                           </span><br><span class="line">menu-0-0-exec &#x3D; menu-open-1                                                                                                                                    </span><br><span class="line">menu-0-1 &#x3D; &quot;Power off&quot;                                                                                                                                        </span><br><span class="line">menu-0-1-exec &#x3D; menu-open-2                                                                                                                                    </span><br><span class="line">menu-0-2 &#x3D; &quot;Log out&quot;                                                                                                                                          </span><br><span class="line">menu-0-2-exec &#x3D; menu-open-3                                                                                                                                    </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">menu-1-0 &#x3D; &quot;Reboot&quot;                                                                                                                                            </span><br><span class="line">menu-1-0-exec &#x3D; ~&#x2F;.config&#x2F;i3&#x2F;powermanager.sh reboot                                                                                                            </span><br><span class="line">menu-1-1 &#x3D; &quot;Cancel &quot;                                                                                                                                           </span><br><span class="line">menu-1-1-exec &#x3D; menu-open-0                                                                                                                                    </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">menu-2-0 &#x3D; &quot;Power off&quot;                                                                                                                                         </span><br><span class="line">menu-2-0-exec &#x3D; ~&#x2F;.config&#x2F;i3&#x2F;powermanager.sh poweroff                                                                                                          </span><br><span class="line">menu-2-1 &#x3D; &quot;Cancel &quot;                                                                                                                                           </span><br><span class="line">menu-2-1-exec &#x3D; menu-open-0                                                                                                                                    </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">menu-3-0 &#x3D; &quot;Log out&quot;                                                                                                                                           </span><br><span class="line">menu-3-0-exec &#x3D; ~&#x2F;.config&#x2F;i3&#x2F;powermanager.sh exit                                                                                                              </span><br><span class="line">menu-3-1 &#x3D; &quot;Cancel &quot;                                                                                                                                           </span><br><span class="line">menu-3-1-exec &#x3D; menu-open-0</span><br></pre></td></tr></table></figure>

<p>我为了在关机/重启/登出的时候自动执行一些操作(目前就是保存虚拟机状态), 定义了这个<code>powermanager.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash                                                                                                                                                    </span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">save</span></span>()&#123;                                                                                                                                               </span><br><span class="line">    notify-send <span class="string">"虚拟机正在保存, 请稍等..."</span>                                                                                                                    </span><br><span class="line">    vboxmanage controlvm win7 savestate                                                                                                                        </span><br><span class="line">    vboxmanage controlvm win7-home savestate                                                                                                                   </span><br><span class="line">    notify-send <span class="string">"虚拟机保存完毕."</span>                                                                                                                              </span><br><span class="line">&#125;                                                                                                                                                              </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"exit"</span> == <span class="string">"<span class="variable">$1</span>"</span> ];<span class="keyword">then</span>                                                                                                                                     </span><br><span class="line">    save                                                                                                                                                       </span><br><span class="line">    i3-msg <span class="built_in">exit</span>                                                                                                                                                </span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"reboot"</span> == <span class="string">"<span class="variable">$1</span>"</span> ];<span class="keyword">then</span>                                                                                                                                 </span><br><span class="line">    save                                                                                                                                                       </span><br><span class="line">    sudo reboot                                                                                                                                                </span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"poweroff"</span> == <span class="string">"<span class="variable">$1</span>"</span> ];<span class="keyword">then</span>                                                                                                                               </span><br><span class="line">    save                                                                                                                                                       </span><br><span class="line">    sudo poweroff                                                                                                                                              </span><br><span class="line"><span class="keyword">else</span>                                                                                                                                                           </span><br><span class="line">    <span class="built_in">exit</span> 1                                                                                                                                                     </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h4><p><code>Polybar</code>的默认时钟不支持显示中文的星期X, 并且我想在点击的时候打开日历, 我就自己定义了一个:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash                                                                                                                                                    </span></span><br><span class="line"><span class="comment"># ~/.config/polybar/script/time.sh脚本内容                                                                                                       </span></span><br><span class="line">weeknum=$(date +<span class="string">'%u'</span>)                                                                                                                                          </span><br><span class="line">weekday=<span class="string">"-"</span>                                                                                                                                                    </span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$weeknum</span>"</span> <span class="keyword">in</span>                                                                                                                                             </span><br><span class="line">    <span class="string">"1"</span>)                                                                                                                                                       </span><br><span class="line">    ┆  weekday=<span class="string">"一"</span>                                                                                                                                            </span><br><span class="line">    ┆  ;;                                                                                                                                                      </span><br><span class="line">    <span class="string">"2"</span>)                                                                                                                                                       </span><br><span class="line">    ┆   weekday=<span class="string">"二"</span>                                                                                                                                           </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line">    <span class="string">"3"</span>)                                                                                                                                                       </span><br><span class="line">    ┆   weekday=<span class="string">"三"</span>                                                                                                                                           </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line">    <span class="string">"4"</span>)                                                                                                                                                       </span><br><span class="line">    ┆   weekday=<span class="string">"四"</span>                                                                                                                                           </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line">    <span class="string">"5"</span>)                                                                                                                                                       </span><br><span class="line">    ┆   weekday=<span class="string">"五"</span>                                                                                                                                           </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line">    <span class="string">"6"</span>)                                                                                                                                                       </span><br><span class="line">    ┆   weekday=<span class="string">"六"</span>                                                                                                                                           </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line">    <span class="string">"7"</span>)                                                                                                                                                       </span><br><span class="line">    ┆   weekday=<span class="string">"日"</span>                                                                                                                                           </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line">    *)                                                                                                                                                         </span><br><span class="line">    ┆   ;;                                                                                                                                                     </span><br><span class="line"><span class="keyword">esac</span>                                                                                                                                                           </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(date +'%m-%d %H:%M')</span> 周<span class="variable">$weekday</span>"</span></span><br></pre></td></tr></table></figure>
<p>在<code>Polybar</code>的配置中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module&#x2F;time]                                                                                                                                                  </span><br><span class="line">type &#x3D; custom&#x2F;script                                                                                                                                           </span><br><span class="line">exec &#x3D; ~&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;time.sh                                                                                                                        </span><br><span class="line">label &#x3D;  %output%                                                                                                                                             </span><br><span class="line">label-font &#x3D; 5                                                                                                                                                 </span><br><span class="line">label-foreground &#x3D; #ccffcc                                                                                                                                     </span><br><span class="line">interval &#x3D; 10                                                                                                                                                  </span><br><span class="line">click-left &#x3D; zenity --calendar                                                                                                                                 </span><br><span class="line">click-right &#x3D; tzclock                                                                                                                                          </span><br><span class="line">format-underline &#x3D; #ccffcc</span><br></pre></td></tr></table></figure>

<h4 id="天气"><a href="#天气" class="headerlink" title="天气"></a>天气</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module&#x2F;weather]                                                                                                                                               </span><br><span class="line">type &#x3D; custom&#x2F;script                                                                                                                                           </span><br><span class="line">exec &#x3D; ~&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;weather.sh                                                                                                                     </span><br><span class="line">exec-if &#x3D; [ $(($(date +%s) - $(cat &#x2F;tmp&#x2F;polybar.tmp))) -gt 30 ]                                                                                                </span><br><span class="line">interval &#x3D; 10                                                                                                                                                  </span><br><span class="line">click-left &#x3D; google-chrome https:&#x2F;&#x2F;openweathermap.org&#x2F;city&#x2F;1808926 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1                                                                             </span><br><span class="line">label-font &#x3D; 8                                                                                                                                                 </span><br><span class="line">format-foreground &#x3D; #09edd3                                                                                                                                    </span><br><span class="line">format-underline &#x3D; #09edd3</span><br></pre></td></tr></table></figure>
<p>通过启动<code>Polybar</code>时记录一下时间戳的方式来延迟执行天气情况查询和显示模块. 这样避免在一开机就启动.<br>天气查询脚本是参考的抄来的.我使用的是<a href="https://github.com/polybar/polybar-scripts/blob/master/polybar-scripts/openweathermap-fullfeatured" target="_blank" rel="noopener">openweathermap-fullfeatured</a> 中的相关脚本.</p>
<h4 id="Github提示"><a href="#Github提示" class="headerlink" title="Github提示"></a>Github提示</h4><p>使用的是<a href="https://github.com/polybar/polybar-scripts.git" target="_blank" rel="noopener">https://github.com/polybar/polybar-scripts.git</a> 中<code>polybar-scripts/polybar-scripts/notification-github/notification-github.sh</code>脚本. </p>
<h4 id="系统更新提示"><a href="#系统更新提示" class="headerlink" title="系统更新提示"></a>系统更新提示</h4><p>使用的是<a href="https://github.com/polybar/polybar-scripts.git" target="_blank" rel="noopener">https://github.com/polybar/polybar-scripts.git</a> 中<code>polybar-scripts/polybar-scripts/updates-fedora/updates-fedora.sh</code>脚本</p>
<h4 id="音视频播放控制"><a href="#音视频播放控制" class="headerlink" title="音视频播放控制"></a>音视频播放控制</h4><p>我的<code>Polybar</code>配置如下, 我这里主要是基于<a href="https://github.com/polybar/polybar-scripts/tree/master/polybar-scripts/player-mpris-tail" target="_blank" rel="noopener">player-mpris-tail</a> 改动了下显示效果, 把输出字符控制在15以内以解决<code>title</code>太长的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module&#x2F;player-mpris-tail]                                                                                                                                     </span><br><span class="line">type &#x3D; custom&#x2F;script                                                                                                                                           </span><br><span class="line">exec &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py -f &#39;&#123;icon&#125; &#123;title&#125;&#39;                                                                                   </span><br><span class="line">tail &#x3D; true                                                                                                                                                    </span><br><span class="line">label &#x3D; %output:0:15:..%                                                                                                                                       </span><br><span class="line">label-foreground &#x3D; #00ff99                                                                                                                                     </span><br><span class="line">label-font &#x3D; 5                                                                                                                                                 </span><br><span class="line">double-click-left &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py previous                                                                                 </span><br><span class="line">click-left &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py play-pause                                                                                      </span><br><span class="line">click-right &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py next                                                                                           click-middle &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py play-pause                                                                                    </span><br><span class="line">scroll-up &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py previous                                                                                         </span><br><span class="line">scroll-down &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;player-mpris-tail.py next                                                                                           </span><br><span class="line">interval &#x3D; 2</span><br></pre></td></tr></table></figure>

<h4 id="屏幕亮度控制"><a href="#屏幕亮度控制" class="headerlink" title="屏幕亮度控制"></a>屏幕亮度控制</h4><p>在<code>Polybar</code>的配置中定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module&#x2F;bright]                                                                                                                                                </span><br><span class="line">type &#x3D; custom&#x2F;script                                                                                                                                           </span><br><span class="line">exec &#x3D; $HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;bright.sh                                                                                                                  </span><br><span class="line">scroll-up &#x3D; &quot;$HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;bright.sh +&quot;                                                                                                         </span><br><span class="line">scroll-down &#x3D; &quot;$HOME&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;bright.sh -&quot;                                                                                                       </span><br><span class="line">interval &#x3D; 2                                                                                                                                                   </span><br><span class="line">format-prefix &#x3D;                                                                                                                                               </span><br><span class="line">format-prefix-foreground &#x3D; #00cc00                                                                                                                             </span><br><span class="line">format-underline &#x3D; #00cc00                                                                                                                                     </span><br><span class="line">format-foreground &#x3D; #00cc00</span><br></pre></td></tr></table></figure>
<p>而这个<code>bright.sh</code>脚本为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash                                                                                                                                                    </span><br><span class="line">current&#x3D;$(cat &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;brightness)                                                                                                 </span><br><span class="line">max&#x3D;$(cat &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;max_brightness)                                                                                                 </span><br><span class="line">per&#x3D;$((current*100&#x2F;max))                                                                                                                                       </span><br><span class="line">if [ &quot;$1&quot; &#x3D; &quot;+&quot; ];then                                                                                                                                         </span><br><span class="line">    new&#x3D;$((per+5))                                                                                                                                             </span><br><span class="line">    if [ $new -gt 100 ];then                                                                                                                                   </span><br><span class="line">    ┆   new&#x3D;$max                                                                                                                                               </span><br><span class="line">    fi                                                                                                                                                         </span><br><span class="line">    echo $((new*max&#x2F;100)) |sudo tee &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;brightness                                                                            </span><br><span class="line">elif [ &quot;$1&quot; &#x3D; &quot;-&quot; ];then                                                                                                                                       </span><br><span class="line">    new&#x3D;$((per-5))                                                                                                                                             </span><br><span class="line">    if [ $new -lt 0 ];then                                                                                                                                     </span><br><span class="line">    ┆   new&#x3D;0                                                                                                                                                  </span><br><span class="line">    fi                                                                                                                                                         </span><br><span class="line">    echo $((new*max&#x2F;100)) |sudo tee &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;brightness                                                                            </span><br><span class="line">else                                                                                                                                                           </span><br><span class="line">    if [ $per -eq 100 ];then                                                                                                                                   </span><br><span class="line">    ┆   echo &quot;$per%&quot;                                                                                                                                           </span><br><span class="line">    elif [ $per -gt 75 ];then                                                                                                                                  </span><br><span class="line">    ┆   echo &quot;$per%&quot;                                                                                                                                           </span><br><span class="line">    elif [ $per -gt 50 ];then                                                                                                                                  </span><br><span class="line">    ┆   echo &quot;$per%&quot;                                                                                                                                           </span><br><span class="line">    elif [ $per -gt 25 ];then                                                                                                                                  </span><br><span class="line">    ┆   echo &quot;$per%&quot;                                                                                                                                           </span><br><span class="line">    else                                                                                                                                                       </span><br><span class="line">    ┆   echo &quot;$per%&quot;                                                                                                                                           </span><br><span class="line">    fi                                                                                                                                                         </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>这样我就能直接在<code>Polybar</code>的显示亮度模块上通过滚动鼠标中键来控制亮度.</p>
<h2 id="单双屏幕切换与显示亮度"><a href="#单双屏幕切换与显示亮度" class="headerlink" title="单双屏幕切换与显示亮度"></a>单双屏幕切换与显示亮度</h2><p>使用<code>autorandr</code>和<code>arandr</code> , <code>autorandr</code>可以自动识别当前多屏幕模式, 而<code>arandr</code>相比与<code>xrandr</code>属于图形化修改的程序, 使用体验更好. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╰─$ autorandr </span><br><span class="line">office (detected) (current)</span><br><span class="line">home</span><br><span class="line">onescreen</span><br></pre></td></tr></table></figure>
<p>使用<code>arandr</code>设置好屏幕后, 使用<code>autorandr --save office --force</code> 即可保存成<code>office</code>的方案.</p>
<p>在做屏幕插拔切换时执行<code>bindsym $mod+Shift+m exec /usr/local/bin/autorandr --change &amp;&amp; $HOME/.config/polybar/launch.sh &amp;&amp; ~/.config/i3/reload_screen.sh</code><br>其中<code>polybar</code>通过<code>launch.sh</code>重新适配以解决系统bar的显示问题, 而<code>reload_screen.sh</code>的作用是为了将<code>workspace</code>在双屏时归位到对应的屏幕上去. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash                                                                                                                                                    </span><br><span class="line">if xrandr |grep -e &#39;^DP-1 connected&#39; &gt; &#x2F;dev&#x2F;null;then                                                                                                          </span><br><span class="line">    ┆   i3-msg &#39;workspace 2:code&#39; &amp;&amp; i3-msg &#39;move workspace to output DP-1&#39;                                                                                    </span><br><span class="line">    ┆   i3-msg &#39;workspace 4:file&#39; &amp;&amp; i3-msg &#39;move workspace to output DP-1&#39;                                                                                    </span><br><span class="line">    ┆   i3-msg &#39;workspace 6:app&#39; &amp;&amp; i3-msg &#39;move workspace to output DP-1&#39;                                                                                     </span><br><span class="line">    ┆   i3-msg &#39;workspace 7:app&#39; &amp;&amp; i3-msg &#39;move workspace to output DP-1&#39;                                                                                     </span><br><span class="line">    ┆   i3-msg &#39;workspace 8:app&#39; &amp;&amp; i3-msg &#39;move workspace to output DP-1&#39;                                                                                     </span><br><span class="line">        i3-msg &#39;workspace 1:web&#39; &amp;&amp; i3-msg &#39;move workspace to output DP-1&#39;                                                                                     </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="不同程序显示的效果和显示的默认位置"><a href="#不同程序显示的效果和显示的默认位置" class="headerlink" title="不同程序显示的效果和显示的默认位置"></a>不同程序显示的效果和显示的默认位置</h2><p>我在I3的配置中定义了很多关于不同程序显示的控制, 如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for_window [class&#x3D;&quot;(?i)guake&quot;] floating enable,resize set width 100 ppt height 100 ppt,move position center                                                    </span><br><span class="line">for_window [class&#x3D;&quot;(?i)tilix&quot;] floating enable,focus                                                                                                           </span><br><span class="line">for_window  [class&#x3D;&quot;(?i)copyq&quot;] floating enable,move position mouse                                                                                            </span><br><span class="line">for_window  [class&#x3D;&quot;(?i)blueman&quot;] floating enable                                                                                                              </span><br><span class="line">for_window [class&#x3D;&quot;(?i)calendar&quot;] move --no-auto-back-and-forth container to workspace $ws10,workspace --no-auto-back-and-forth $ws10,focus                    </span><br><span class="line">for_window [class&#x3D;&quot;(?i)shutter&quot;] floating enable                                                                                                               </span><br><span class="line">for_window [class&#x3D;&quot;(?i)flameshot&quot;] floation enable                                                                                                             </span><br><span class="line">for_window [class&#x3D;&quot;(?i)golden&quot;] floating enable                                                                                                                </span><br><span class="line">for_window [class&#x3D;&quot;(?i)kodi&quot;] move container to workspace $ws8,workspace $ws8,focus                                                                            </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">assign [class&#x3D;&quot;(?i)chrome&quot;] $ws1                                                                                                                               </span><br><span class="line">for_window [class&#x3D;&quot;(?i)chrome&quot;] focus                                                                                                                          </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">assign [class&#x3D;&quot;(?i)firefox&quot;] $ws1                                                                                                                              </span><br><span class="line">for_window [class&#x3D;&quot;(?i)firefox&quot;] focus                                                                                                                         </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">assign [class&#x3D;&quot;(?i)code&quot;] $ws2                                                                                                                                 </span><br><span class="line">for_window [class&#x3D;&quot;(?i)code&quot;] focus                                                                                                                            </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">assign [class&#x3D;&quot;(?i)virtual&quot;] $ws10                                                                                                                             </span><br><span class="line">for_window [class&#x3D;&quot;(?i)virtual&quot;] focus                                                                                                                         </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">assign [class&#x3D;&quot;(?i)termina&quot;] $ws5                                                                                                                              </span><br><span class="line">for_window [class&#x3D;&quot;(?i)termina&quot;] focus                                                                                                                         </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">assign [class&#x3D;&quot;(?i)rhythmbox&quot;] $ws9                                                                                                                            </span><br><span class="line">for_window [class&#x3D;&quot;(?i)rhythmbox&quot;] move scratchpad                               </span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>太多了我就不一一列举了, 其中<code>(?i)</code>是不区分大小写匹配的意思.</p>
<p>我的I3的一些默认的显示效果配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">force_display_urgency_hint 500 ms                                                                                                                              </span><br><span class="line">focus_wrapping no                                                                                                                                              </span><br><span class="line">popup_during_fullscreen smart                                                                                                                                  </span><br><span class="line">focus_on_window_activation  none # smart|urgent|focus|none                                                                                                     </span><br><span class="line">mouse_warping none # none|output                                                                                                                               </span><br><span class="line">focus_follows_mouse yes #yes|no                                                                                                                                </span><br><span class="line">hide_edge_borders  smart #none|vertical|horizontal|both|smart                                                                                                  </span><br><span class="line">default_border none                                                                                                                                            </span><br><span class="line">default_floating_border normal  </span><br><span class="line"># split in horizontal orientation                                                                                                                              </span><br><span class="line">bindsym $mod+- split h                                                                                                                                         </span><br><span class="line">                                                                                                                                                               </span><br><span class="line"># split in vertical orientation                                                                                                                                </span><br><span class="line">bindsym $mod+&#x3D; split v                                                                                                                                         </span><br><span class="line">                                                                                                                                                               </span><br><span class="line"># enter fullscreen mode for the focused container                                                                                                              </span><br><span class="line">bindsym $mod+f fullscreen toggle                                                                                                                               </span><br><span class="line">                                                                                                                                                               </span><br><span class="line"># change container layout (stacked, tabbed, toggle split)                                                                                                      </span><br><span class="line">bindsym $mod+s layout stacking                                                                                                                                 </span><br><span class="line">bindsym $mod+w layout tabbed                                                                                                                                   </span><br><span class="line">bindsym $mod+e layout toggle split                                                                                                                             </span><br><span class="line">bindsym $mod+shift+minus move scratchpad                                                                                                                       </span><br><span class="line">bindsym $mod+minus scratchpad show                                                                                                                             </span><br><span class="line"># toggle tiling &#x2F; floating                                                                                                                                     </span><br><span class="line">bindsym $mod+space floating toggle                                                                                                                             </span><br><span class="line">                                                                                                                                                               </span><br><span class="line"># change focus between tiling &#x2F; floating windows                                                                                                               </span><br><span class="line">bindsym $mod+Shift+space focus mode_toggle                                                                                                                     </span><br><span class="line">                                                                                                                                                               </span><br><span class="line"># focus the parent container                                                                                                                                   </span><br><span class="line">bindsym $mod+a focus parent</span><br></pre></td></tr></table></figure>
<p>也从网上借鉴来一个调整窗体大小的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mode &quot;resize&quot; &#123;                                                                                                                                                </span><br><span class="line">    ┆   # These bindings trigger as soon as you enter the resize mode                                                                                          </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">    ┆   # Pressing left will shrink the window’s width.                                                                                                        </span><br><span class="line">    ┆   # Pressing right will grow the window’s width.                                                                                                         </span><br><span class="line">    ┆   # Pressing up will shrink the window’s height.                                                                                                         </span><br><span class="line">    ┆   # Pressing down will grow the window’s height.                                                                                                         </span><br><span class="line">        bindsym j resize shrink width 10 px or 10 ppt                                                                                                          </span><br><span class="line">    ┆   bindsym k resize grow height 10 px or 10 ppt                                                                                                           </span><br><span class="line">    ┆   bindsym l resize shrink height 10 px or 10 ppt                                                                                                         </span><br><span class="line">    ┆   bindsym semicolon resize grow width 10 px or 10 ppt                                                                                                    </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">    ┆   # same bindings, but for the arrow keys                                                                                                                </span><br><span class="line">    ┆   bindsym Left resize shrink width 10 px or 10 ppt                                                                                                       </span><br><span class="line">    ┆   bindsym Down resize grow height 10 px or 10 ppt                                                                                                        </span><br><span class="line">    ┆   bindsym Up resize shrink height 10 px or 10 ppt                                                                                                        </span><br><span class="line">    ┆   bindsym Right resize grow width 10 px or 10 ppt                                                                                                        </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">    ┆   # back to normal: Enter or Escape or $mod+r                                                                                                            </span><br><span class="line">    ┆   bindsym Return mode &quot;default&quot;                                                                                                                          </span><br><span class="line">    ┆   bindsym Escape mode &quot;default&quot;                                                                                                                          </span><br><span class="line">    ┆   bindsym $mod+r mode &quot;default&quot;                                                                                                                          </span><br><span class="line">&#125;                                                                                                                                                              </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">bindsym $mod+r mode &quot;resize&quot;</span><br></pre></td></tr></table></figure>


<h2 id="音量控制-播放控制-显示亮度控制"><a href="#音量控制-播放控制-显示亮度控制" class="headerlink" title="音量控制/播放控制/显示亮度控制"></a>音量控制/播放控制/显示亮度控制</h2><p>在I3中配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#######################                                                                                                                                        </span><br><span class="line"># Pulse Audio controls                                                                                                                                         </span><br><span class="line">bindsym XF86AudioRaiseVolume exec --no-startup-id pactl set-sink-volume alsa_output.pci-0000_00_1f.3.analog-stereo +5% #increase sound volume                  </span><br><span class="line">bindsym XF86AudioLowerVolume exec --no-startup-id pactl set-sink-volume alsa_output.pci-0000_00_1f.3.analog-stereo -5% #decrease sound volume                  </span><br><span class="line">bindsym XF86AudioMute exec --no-startup-id pactl set-sink-mute alsa_output.pci-0000_00_1f.3.analog-stereo toggle # mute sound                                                                                                                                                                                                 </span><br><span class="line">#######################                                                                                                                                        </span><br><span class="line"># Media player controls bindsym XF86AudioPlay exec --no-startup-id playerctl play-pause bindsym XF86AudioPause exec --no-startup-id playerctl play-pause       </span><br><span class="line">bindsym XF86AudioNext exec --no-startup-id playerctl next                                                                                                      </span><br><span class="line">bindsym XF86AudioPrev exec --no-startup-id playerctl previous                                                                                                  </span><br><span class="line">#######################                                                                                                                                        </span><br><span class="line"># back light                                                                                                                                                   </span><br><span class="line">bindsym XF86MonBrightnessUp exec --no-startup-id ~&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;bright.sh +                                                                          </span><br><span class="line">bindsym XF86MonBrightnessDown exec --no-startup-id ~&#x2F;.config&#x2F;polybar&#x2F;script&#x2F;bright.sh -</span><br></pre></td></tr></table></figure>

<h2 id="workspace切换"><a href="#workspace切换" class="headerlink" title="workspace切换"></a>workspace切换</h2><p>在I3中配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 两次重复按键回调workspace                                                                                                                                    </span><br><span class="line">workspace_auto_back_and_forth yes  </span><br><span class="line"></span><br><span class="line">bindsym $mod+x mode &quot;mvoutput&quot;                                                                                                                                 </span><br><span class="line">mode &quot;mvoutput&quot; &#123;                                                                                                                                              </span><br><span class="line">   bindsym j move workspace to output left                                                                                                                     </span><br><span class="line">   bindsym k move workspace to output right                                                                                                                    </span><br><span class="line">   bindsym h move workspace to output up                                                                                                                       </span><br><span class="line">   bindsym l move workspace to output down                                                                                                                     </span><br><span class="line">   bindsym p move workspace to output primary                                                                                                                  </span><br><span class="line">   bindsym Left move workspace to output left                                                                                                                  </span><br><span class="line">   bindsym Down move workspace to output down                                                                                                                  </span><br><span class="line">   bindsym Up move workspace to output up                                                                                                                      </span><br><span class="line">   bindsym Right move workspace to output right                                                                                                                </span><br><span class="line">   bindsym Shift+Left move container to output left                                                                                                            </span><br><span class="line">   bindsym Shift+Down move container to output down                                                                                                            </span><br><span class="line">   bindsym Shift+Up move container to output up                                                                                                                </span><br><span class="line">   bindsym Shift+Right move container to output right                                                                                                          </span><br><span class="line">   bindsym Return mode &quot;default&quot;                                                                                                                               </span><br><span class="line">   bindsym Escape mode &quot;default&quot;                                                                                                                               </span><br><span class="line">   bindsym $mod+x mode &quot;default&quot;                                                                                                                               </span><br><span class="line">                                                                                                                                                               </span><br><span class="line">&#125;           </span><br><span class="line">                                                                                                                                                               </span><br><span class="line"># set workspace output                                                                                                                                         </span><br><span class="line">workspace $ws1 output DP-1 eDP-1                                                                                                                               </span><br><span class="line">workspace $ws2 output DP-1 eDP-1                                                                                                                               </span><br><span class="line">workspace $ws3 output eDP-1 DP-1                                                                                                                               </span><br><span class="line">workspace $ws4 output DP-1 eDP-1                                                                                                                               </span><br><span class="line">workspace $ws5 output eDP-1 DP-1                                                                                                                               </span><br><span class="line">workspace $ws6 output DP-1 eDP-1                                                                                                                               </span><br><span class="line">workspace $ws7 output DP-1 eDP-1                                                                                                                               </span><br><span class="line">workspace $ws8 output DP-1 eDP-1                                                                                                                               </span><br><span class="line">workspace $ws9 output eDP-1 DP-1                                                                                                                               </span><br><span class="line">workspace $ws10 output eDP-1 DP-1      </span><br><span class="line"></span><br><span class="line">bindsym $mod+grave exec --no-startup-id bash $shdir&#x2F;changeworkspace.sh                                                                                         </span><br><span class="line">bindsym $mod+q workspace back_and_forth                                                                                                                        </span><br><span class="line">bindsym $mod+Tab workspace next</span><br></pre></td></tr></table></figure>
<p>我的这个<code>changeworkspace.sh</code>就是利用<code>rofi</code>来达到图形化选择切换目标的功能. 其实使用<code>rofi -show window</code>也就能实现同样的效果, 只是后者会显示I3下隐藏的<code>scratchpad</code>, 而我这个则不显示. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash                                                                                                                                                    </span></span><br><span class="line">show_ws=$(i3-msg -t get_workspaces | tr , <span class="string">'\n'</span> | grep <span class="string">'"name":'</span> | sed -e <span class="string">'s/"name"://g'</span> -e <span class="string">'s/"//g'</span>)                                                           </span><br><span class="line">choose=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$show_ws</span>"</span>|rofi -dmenu -p <span class="string">"choose active workspaces"</span>)                                                                                            </span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$choose</span>"</span> =~ ^[0-9]:.*$ ]];<span class="keyword">then</span>                                                                                                                          </span><br><span class="line">   i3-msg workspace <span class="string">"<span class="variable">$choose</span>"</span>                                                                                                                                  </span><br><span class="line"><span class="keyword">elif</span> [[ <span class="string">"<span class="variable">$choose</span>"</span> =~ ^10:.*$ ]];<span class="keyword">then</span>                                                                                                                           </span><br><span class="line">   i3-msg workspace <span class="string">"<span class="variable">$&#123;choose&#125;</span>"</span>                                                                                                                                </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<h2 id="鼠标theme-桌面theme"><a href="#鼠标theme-桌面theme" class="headerlink" title="鼠标theme/桌面theme"></a>鼠标theme/桌面theme</h2><h4 id="修改鼠标"><a href="#修改鼠标" class="headerlink" title="修改鼠标"></a>修改鼠标</h4><p>修改文件<code>~/.Xresources</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Xcursor.theme: material_light_cursors</span><br><span class="line">Xcursor.size: 16</span><br></pre></td></tr></table></figure>
<p><code>material_light_cursors</code>是放在<code>~/.icons</code>下的cursor主题目录名称.</p>
<p>然后执行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xrdb ~/.Xresources</span><br><span class="line">i3 restart</span><br></pre></td></tr></table></figure>

<h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><p>gnome使用<code>gnome-tweaks</code> 修改鼠标和主题</p>
<p>也可以使用<code>LXAppearance</code> 修改和安装主题</p>
<h4 id="lightdm登录界面修改"><a href="#lightdm登录界面修改" class="headerlink" title="lightdm登录界面修改"></a>lightdm登录界面修改</h4><p>使用<code>lightdm-gtk-greeter-settings</code> 修改配置</p>
<h2 id="桌面背景"><a href="#桌面背景" class="headerlink" title="桌面背景"></a>桌面背景</h2><p>使用<code>feh</code>, 在I3中配置: <code>exec --no-startup-id feh --bg-scale ~/Pictures/moon.jpg</code></p>
<h2 id="触摸板开关-多手指手势支持-鼠标速度控制"><a href="#触摸板开关-多手指手势支持-鼠标速度控制" class="headerlink" title="触摸板开关/多手指手势支持/鼠标速度控制"></a>触摸板开关/多手指手势支持/鼠标速度控制</h2><p>我的鼠标在I3下有点飘~ 我就让I3帮我开机自动解决这个问题, 并且设置了触摸板手势的支持:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec --no-startup-id libinput-gestures                                                                                                                         </span><br><span class="line"># 启动时启动touchpad单击手势和滚动手势                                                                                                                         </span><br><span class="line">exec --no-startup-id xinput set-prop &#39;DLL082A:01 06CB:76AF Touchpad&#39; &#39;libinput Tapping Enabled&#39; 1                                                              </span><br><span class="line">exec --no-startup-id xinput set-prop &#39;DLL082A:01 06CB:76AF Touchpad&#39; &#39;libinput Natural Scrolling Enabled&#39; 1                                                    </span><br><span class="line">exec --no-startup-id xinput set-prop &#39;DLL082A:01 06CB:76AF Touchpad&#39; &#39;libinput Accel Speed&#39; 0.4</span><br></pre></td></tr></table></figure>
<p><code>&#39;DLL082A:01 06CB:76AF Touchpad&#39;</code>这个设备id可以通过<code>xinput list</code>查到,<br>这些prop的名称可以通过<code>xinput list-props</code>查到. </p>
<h4 id="开启-关闭触摸板"><a href="#开启-关闭触摸板" class="headerlink" title="开启/关闭触摸板"></a>开启/关闭触摸板</h4><p>在I3中配置: <code>bindsym $mod+Ctrl+t exec --no-startup-id $HOME/.config/i3/touchpad.sh</code></p>
<p>这个<code>touchpad.sh</code>如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash                                                                                                                                                    </span></span><br><span class="line">tID=$(xinput list|grep Touchpad|sed <span class="string">'s/^.*id=//g'</span>|awk <span class="string">'&#123;print $1&#125;'</span>)                                                                                            </span><br><span class="line">res=$(xinput list-props <span class="string">"<span class="variable">$&#123;tID&#125;</span>"</span>|grep <span class="string">"Device Enabled"</span>|sed <span class="string">'s/.*:[ \t\n]*//g'</span>)                                                                                 </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$res</span>"</span> = <span class="string">"1"</span> ];<span class="keyword">then</span>                                                                                                                                       </span><br><span class="line">    xinput <span class="built_in">set</span>-prop <span class="string">"<span class="variable">$&#123;tID&#125;</span>"</span> <span class="string">"Device Enabled"</span> 0                                                                                                                </span><br><span class="line">    notify-send <span class="string">"触摸板关闭"</span>                                                                                                                                   </span><br><span class="line"><span class="keyword">else</span>                                                                                                                                                           </span><br><span class="line">    xinput <span class="built_in">set</span>-prop <span class="string">"<span class="variable">$&#123;tID&#125;</span>"</span> <span class="string">"Device Enabled"</span> 1                                                                                                                </span><br><span class="line">    notify-send <span class="string">"触摸板开启"</span>                                                                                                                                   </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="关闭系统自动屏幕保护和电源管理"><a href="#关闭系统自动屏幕保护和电源管理" class="headerlink" title="关闭系统自动屏幕保护和电源管理"></a>关闭系统自动屏幕保护和电源管理</h2><p>在I3的配置中设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec --no-startup-id xset dpms 0 0 0                                                                                                                           </span><br><span class="line">exec --no-startup-id xset s noblank &amp;&amp; xset s noexpose &amp;&amp; xset s off</span><br></pre></td></tr></table></figure>

<h2 id="开启自动启动模式选择与autoload-sh脚本"><a href="#开启自动启动模式选择与autoload-sh脚本" class="headerlink" title="开启自动启动模式选择与autoload.sh脚本"></a>开启自动启动模式选择与autoload.sh脚本</h2><p>为了能够在开机登录I3的时候根据选择决定自动加载哪些程序, 我写了这个<code>autoload.sh</code>脚本, 结合I3配置来实现开机时根据时间和选择来选择性加载程序.</p>
<p>如果是下班以后的时间登录的就默认选择最小方案, 如果不是则默认选择全部的方案, 如果超时自动执行当前选择的方案, 如果取消则只是启动polybar和一些默认都会加载的程序(如截图、dunst等)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash                                                                                                                                                    </span></span><br><span class="line"><span class="comment"># shellcheck disable=SC1091                                                                                                                                    </span></span><br><span class="line"><span class="built_in">source</span> /home/wudy/.xprofile                                                                                                                                    </span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$HOME</span>"</span>|| <span class="built_in">echo</span> <span class="string">"no home dir"</span>                                                                                                                                </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$(date +%H)</span>"</span> -lt <span class="string">"16"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$(date +%u)</span>"</span> -lt <span class="string">"6"</span> ] ;<span class="keyword">then</span>                                                                                               </span><br><span class="line">    choose=$(zenity --list --radiolist --column <span class="string">"启动"</span> --column <span class="string">"启动方案"</span> TRUE  全部 FALSE <span class="string">"Home"</span> FALSE <span class="string">"最小(Chrome+File)"</span> FALSE <span class="string">"代码(Chrome+Code+Note+File+Music)"</span> --timeout 6 --text <span class="string">"启动方案:"</span>)                                                                                                                        <span class="keyword">else</span>                                                                                                                                                           </span><br><span class="line">    choose=$(zenity --list --radiolist --column <span class="string">"启动"</span> --column <span class="string">"启动方案"</span> FALSE  全部 FALSE <span class="string">"Home"</span> TRUE <span class="string">"最小(Chrome+File)"</span> FALSE <span class="string">"代码(Chrome+Code+Note+File+Music)"</span> --timeout 6 --text <span class="string">"启动方案:"</span>)                                                                                                                        <span class="keyword">fi</span>                                                                                                                                                             </span><br><span class="line"><span class="comment"># 默认开启后台自动加载的程序或服务: 剪切板管理(copyq), 蓝牙管理(blueman-applet和blueman-tray), 截图(flameshot), 通知管理(dunst), 梯子(v2ray), 虚拟机通知管理(notify-vm), 翻译软件(goldendict)</span></span><br><span class="line">DISPLAY=:0 nohup copyq &amp;                                                                                                                                       </span><br><span class="line">DISPLAY=:0 nohup blueman-applet &amp;                                                                                                                              </span><br><span class="line">nohup blueman-tray &amp;                                                                                                                                           </span><br><span class="line">sleep 1                                                                                                                                                        </span><br><span class="line">flameshot &amp;                                                                                                                                                    </span><br><span class="line">sleep 1                                                                                                                                                        </span><br><span class="line">systemctl --user start v2ray.service                                                                                                                           </span><br><span class="line">systemctl --user start dunst.service                                                                                                                           </span><br><span class="line">systemctl --user start notify-vm.service                                                                                                                       </span><br><span class="line">sleep 1                                                                                                                                                        </span><br><span class="line">nohup /usr/bin/goldendict &amp;                                                                                                                                    </span><br><span class="line">sleep 1                            </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"X<span class="variable">$choose</span>"</span> != <span class="string">"X"</span> ];<span class="keyword">then</span>                                                                                                                                  </span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$choose</span>"</span> != <span class="string">"最小(Chrome+File)"</span> ];<span class="keyword">then</span>                                                                                                                 </span><br><span class="line">    ┆ QOwnNotes &amp;                                                                                                                                              </span><br><span class="line">    ┆ sleep 1                                                                                                                                                  </span><br><span class="line">  <span class="keyword">fi</span>                                                                                                                                                           </span><br><span class="line">  nautilus &amp;                                                                                                                                                   </span><br><span class="line">  google-chrome &amp;                                                                                                                                              </span><br><span class="line">  sleep 3                                                                                                                                                      </span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$choose</span>"</span> != <span class="string">"最小(Chrome+File)"</span> ];<span class="keyword">then</span>                                                                                                                 </span><br><span class="line">    ┆ code &amp;                                                                                                                                                   </span><br><span class="line">    ┆ sleep 4                                                                                                                                                  </span><br><span class="line">  <span class="keyword">fi</span>                                                                                                                                                           </span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$choose</span>"</span> = <span class="string">"全部"</span> ];<span class="keyword">then</span>                                                                                                                               </span><br><span class="line">    ┆VBoxManage startvm win7 &amp;                                                                                                                                 </span><br><span class="line">  <span class="keyword">fi</span>                                                                                                                                                           </span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$choose</span>"</span> = <span class="string">"Home"</span> ];<span class="keyword">then</span>                                                                                                                               </span><br><span class="line">    ┆ VBoxManage startvm win7-home &amp;                                                                                                                           </span><br><span class="line">  <span class="keyword">fi</span>                                                                                                                                                           </span><br><span class="line">  sleep 1                                                                                                                                                      </span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$choose</span>"</span> != <span class="string">"最小(Chrome+File)"</span> ];<span class="keyword">then</span>                                                                                                                 </span><br><span class="line">    ┆ rhythmbox &amp;                                                                                                                                              </span><br><span class="line">    ┆ netease-cloud-music &amp;                                                                                                                                    </span><br><span class="line">  <span class="keyword">fi</span>                                                                                                                                                           </span><br><span class="line"><span class="keyword">fi</span>                                                                                                                                                             </span><br><span class="line"><span class="string">"<span class="variable">$HOME</span>"</span>/.config/polybar/launch.sh                                                                                                                              </span><br><span class="line"><span class="comment"># 自动设置音量到10%, 避免上次使用的时候设置很大, 自己没注意, 导致开音视频时发出很大的声音</span></span><br><span class="line">pactl <span class="built_in">set</span>-sink-volume alsa_output.pci-0000_00_1f.3.analog-stereo 10%</span><br></pre></td></tr></table></figure>

<h2 id="Tmux与Guake"><a href="#Tmux与Guake" class="headerlink" title="Tmux与Guake"></a>Tmux与Guake</h2><p>我习惯在本地启动一个<code>Tmux</code>使用, 而我又喜欢<code>Guake</code>的一键显示关闭的形式, 为了结合使用两者, 并且开机时就自动给我初始化好, 我就添加了如下修改:</p>
<p>在I3的配置中添加:<br><code>exec --no-startup-id $HOME/.config/i3/tmux.sh</code></p>
<p>这个<code>tmux.sh</code>脚本如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> tmux server-info &gt; /dev/null ;<span class="keyword">then</span> </span><br><span class="line">    guake -r <span class="string">"localhost"</span> -e <span class="string">"tmux attach"</span> &amp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    guake -r <span class="string">"localhost"</span> -e <span class="string">"tmux"</span> &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>这样在登录I3的时候, 自动帮我在<code>guake</code>中打开<code>tmux</code>或者自动链接到已经存在的<code>tmux</code></p>
<h2 id="定时提醒-番茄工作法"><a href="#定时提醒-番茄工作法" class="headerlink" title="定时提醒-番茄工作法"></a>定时提醒-番茄工作法</h2><p>使用C-S模式写的一个脚本, 启动一个后台服务, 定时刷新计时, 并提供socket接口, 使得可以通过端口号通信来控制计时重置/暂停/时间设置等操作.  时间到了以后通过<code>notify-send</code>发送消息提醒. 具体的实现比较简单,而我实现的比较丑陋, 我就不献丑了…</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是目前为止我在<code>I3</code>上折腾的历程记录, 后续我可能还会在哪天什么东西用着不爽的时候再折腾折腾..<br>比如, 我就计划折腾个<code>wifi</code>扫描和显示的东西, <code>linux</code>下切换<code>wifi</code>目前用的<code>nmcli</code>, 只能说勉强够用吧.</p>
<p>To Be Continue…</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>fedora</tag>
        <tag>linux</tag>
        <tag>i3wm</tag>
      </tags>
  </entry>
  <entry>
    <title>学习uber-go开发规范笔记</title>
    <url>/2021/01/16/%E6%96%87%E6%A1%A3%20httpsgithub.comuber-goguide/</url>
    <content><![CDATA[<p>文档: <a href="https://github.com/uber-go/guide" target="_blank" rel="noopener">https://github.com/uber-go/guide</a></p>
<p>中文: <a href="https://github.com/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener">https://github.com/xxjwxc/uber_go_guide_cn</a></p>
<p>在阅读中发现自己当前认知上的不足之处: </p>
<ol>
<li><p>把接口Interface只当作值传递即可, 接口底层实际上就是两个指针type和data</p>
</li>
<li><p>尽可能在编译期让实现接口的错误被检查出来, 例如让通过<code>var _ http.Handler = (*Handler) nil</code> 来检查<code>*Handler</code>是否真的实现了<code>http.Handler</code></p>
</li>
<li><p>slice或map是指针, 在使用临界处需要进行拷贝传递以避免多方使用时修改到同一个底层数据</p>
</li>
<li><p>函数参数在定义时间的参数使用<code>time.Duration</code>或<code>time.Time</code>, 避免使用<code>int</code>来表示. 另外在<code>json</code>解析时最好加上<code>int</code>类型的单位标记,如<code>IntervalSeconds int &#39;json:&quot;intervalSeconds&quot;&#39;</code> 而不是直接使用<code>Interval</code> </p>
</li>
<li><p>尽量返回error而不是panic, 只在调用方或main处理error. </p>
</li>
<li><p>对于需要进行原子操作的类型直接声明位<code>atomic.XX</code>类型, 避免使用<code>int、int32</code>等类型, 以减少忘记使用<code>atomic</code>包中方法来操作这个数据导致的非原子化问题.</p>
</li>
<li><p>避免使用可变全局变量, 而使用选择依赖注入的方式, 通过struct和new的方式生成唯一全局变量来操作</p>
</li>
<li><p>在结构体中避免使用嵌入式的类型, 内嵌的类型放在结构体顶部并空一行以隔开非嵌入类型, 而是使用委托方法来代理访问底层结构体的方法, 可以方便后续变更.</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="comment">// AbstractList 是各种实体列表的通用实现。</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。 自己代理封装了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>尽可能初始化指定map/slice容量, <code>strconv</code>性能比<code>fmt</code>好, 尽可能一次性完成<code>string-&gt;[]byte</code>的操作, 这个转换操作是有开销代价的.</p>
</li>
<li><p>变量声明分组, 相似的分一组. 导入也分组, 标准库/第三方库/私有库分组, 一个文件中, 结构体-new-方法形式分成一组, 其他工具函数放在结尾</p>
</li>
<li><p>全局的未导出的变量使用<code>_</code>前缀以表明身份, 方便区分以及减少被局部同名变量覆盖的可能.</p>
</li>
<li><p><code>nil</code>可以是一个有效的<code>slice</code>, 可以通过<code>return</code>来返回, 避免返回空<code>slice</code>如:<code>[]int{}</code>, 对<code>slice</code>的判空使用<code>len()</code>, 声明用<code>var</code>优于<code>[]int{}</code></p>
</li>
<li><p>反引号可用于避免字符串转义, 不用手动加转义符</p>
</li>
<li><p>map初始化有初始值用<code>map[T1]T2{xx, xx..}</code>形式, 否则用<code>make</code>方式, 结构体用<code>=&amp;</code>或<code>=</code>初始化</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>近期阅读的一些好文片段总结</title>
    <url>/2021/02/21/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E6%88%90%E9%95%BF(%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB)/</url>
    <content><![CDATA[<h1 id="如何高效地成长-工作学习生活"><a href="#如何高效地成长-工作学习生活" class="headerlink" title="如何高效地成长(工作学习生活)"></a>如何高效地成长(工作学习生活)</h1><ol>
<li>多看片多实践–各种纪录片/ted/公开课/教学视频</li>
<li>集中时间,拒绝打扰,番茄工作法</li>
<li>定期整理收藏夹/重温写下感悟</li>
<li>每天3件事,日毕,读书/写作/运动,慢慢成长</li>
<li>经常复盘总结,遇到盲区马上查并记录</li>
<li>主要精力放在赚钱上.</li>
<li>拒绝拖延,5秒法则-默念后行动</li>
<li>大胆承认自己的无知</li>
<li>先行动不要等准备好再动,抓住时机</li>
<li>专注自己的长处,降低对他人的期望</li>
<li>向优秀的人学习,培养一技之长</li>
<li>节省自己的注意力, 28定律,不要把注意力放在垃圾上</li>
<li>在经济能力内花钱买时间</li>
<li>规范化执行,自律一点</li>
</ol>
<h1 id="关于各民族文化的宏观总结"><a href="#关于各民族文化的宏观总结" class="headerlink" title="关于各民族文化的宏观总结"></a>关于各民族文化的宏观总结</h1><p>印度文化是苦感文化，认为人越受苦，离神越近，下辈子越幸福，所以甘地主义(印度的开国元勋甘地的思想)是苦感文化在现代的集大成者。</p>
<p>中国文化是反的，是乐感文化，为什么呢?中国人不相信有来世，活一百岁也只有36500多天，活一天少一天，活一天就要快乐一天，活一天就要”天生我材必有用””莫使金樽空对月”。</p>
<p>西方是罪感文化，认为人生来有罪，周末就要到教堂去赎罪。</p>
<p>伊斯兰国家是圣感文化，为什么?它是一神教，阿拉唯一、阿拉神圣，不相信别的神，所以是圣感文化。</p>
<p>日本是耻感文化，认为落后可耻、愚昧可耻、肮脏可耻、道歉可耻。</p>
<p>非洲是悠感文化，优哉游哉，没有着急的事情，哪怕开追悼会，照样是笑声一片。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>go进行类似函数式/链式的数据map/reduce处理思考</title>
    <url>/2021/02/28/%E4%B8%80%E7%9B%B4%E5%9C%A8%E6%80%9D%E8%80%83%E5%9C%A8go%E4%B8%AD%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E9%82%A3%E6%A0%B7%E7%9A%84%E7%BC%96%E7%A8%8B,%20%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCFlink%E4%B8%AD%E7%9A%84%E9%82%A3%E7%A7%8D%E6%B5%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.%20%E5%90%8E%E6%9D%A5%E6%83%B3%E4%BA%86%E6%83%B3,%20%E8%BF%99%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mapreduce.%20%E4%BA%8E%E6%98%AF%E6%88%91%E6%9C%89%E4%BA%86%E5%A6%82%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>一直在思考在go中怎么进行函数式那样的编程, 以实现类似Flink中的那种流数据处理. 后来想了想, 这其实也是如何实现map/reduce. 于是我有了如下的一些代码实验:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fn <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(f fn) F</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Result)</span> <span class="title">Do</span><span class="params">(f fn)</span> *<span class="title">Result</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line">	r.Data, r.Err = f(r.Data)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	filter1 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"little than 1: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	filter2 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>) &gt; <span class="number">4</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"little than 4: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	filter3 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>)&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"even number: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			r := Result&#123;</span><br><span class="line">				Data: d,</span><br><span class="line">				Err:  <span class="literal">nil</span>,</span><br><span class="line">			&#125;</span><br><span class="line">			c &lt;- r.Do(filter1).Do(filter2).Do(filter3)</span><br><span class="line">		&#125;(d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		d := &lt;-c</span><br><span class="line">		<span class="keyword">if</span> d.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(d.Err.Error())</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(d.Data.(<span class="keyword">int</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go run test.go</span></span><br><span class="line"><span class="comment">// little than 4: 2</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// even number: 7</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// little than 4: 3</span></span><br><span class="line"><span class="comment">// little than 1: 0</span></span><br><span class="line"><span class="comment">// even number: 9</span></span><br><span class="line"><span class="comment">// little than 4: 4</span></span><br><span class="line"><span class="comment">// little than 1: 1</span></span><br><span class="line"><span class="comment">// even number: 5</span></span><br></pre></td></tr></table></figure>

<p>似乎可以做到, 但是数据类似的断言确实有点痛, 看来想彻底优雅的实现还需要泛型的, 估计等1.8或go2中泛型出来了, 会有很多这样的实现或代码库出现. </p>
<p>不过<code>r.Do(filter1).Do(filter2).Do(filter3)</code>这里的实现并没有做到在遇到错误时及时短路, 想想<code>&amp;&amp;</code>与<code>||</code>可以做到及时短路, 于是就有了如下实现:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fn <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(f fn) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Result)</span> <span class="title">Do</span><span class="params">(f fn)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.Data, r.Err = f(r.Data)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	filter1 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"little than 1: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	filter2 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>) &gt; <span class="number">4</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"little than 4: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	filter3 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>)&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"even number: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			r := Result&#123;</span><br><span class="line">				Data: d,</span><br><span class="line">				Err:  <span class="literal">nil</span>,</span><br><span class="line">			&#125;</span><br><span class="line">			_ = r.Do(filter1) &amp;&amp; r.Do(filter2) &amp;&amp; r.Do(filter3)</span><br><span class="line">			c &lt;- &amp;r</span><br><span class="line">		&#125;(d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		d := &lt;-c</span><br><span class="line">		<span class="keyword">if</span> d.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(d.Err.Error())</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(d.Data.(<span class="keyword">int</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go run test.go</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// even number: 7</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// little than 1: 0</span></span><br><span class="line"><span class="comment">// little than 4: 3</span></span><br><span class="line"><span class="comment">// little than 4: 2</span></span><br><span class="line"><span class="comment">// little than 4: 4</span></span><br><span class="line"><span class="comment">// even number: 9</span></span><br><span class="line"><span class="comment">// little than 1: 1</span></span><br><span class="line"><span class="comment">// even number: 5</span></span><br></pre></td></tr></table></figure>

<p>从这个demo中可以看出, 错误的处理确实是一个痛点, 如果能像Rust那样处理就很爽了, 所以我又搞了如下版本, 只返回一个数据, 不返回error, 而在reduce中判断switch判断是否遇到了error:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fn <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(f fn) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	D <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Result)</span> <span class="title">Do</span><span class="params">(f fn)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e, ok := r.D.(error); ok &amp;&amp; e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	r.D = f(r.D)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	filter1 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>) &gt; <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"little than 1: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	filter2 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>) &gt; <span class="number">4</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"little than 4: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	filter3 := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> i.(<span class="keyword">int</span>)&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"even number: %v"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">			r := Result&#123;</span><br><span class="line">				D: d,</span><br><span class="line">			&#125;</span><br><span class="line">			_ = r.Do(filter1) &amp;&amp; r.Do(filter2) &amp;&amp; r.Do(filter3)</span><br><span class="line">			c &lt;- &amp;r</span><br><span class="line">		&#125;(d)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		d := &lt;-c</span><br><span class="line">		<span class="keyword">switch</span> d.D.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> error:</span><br><span class="line">			fmt.Println(<span class="string">"err:"</span>,d.D)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"num:"</span>,d.D)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $ go run test.go</span></span><br><span class="line"><span class="comment">// err: even number: 9</span></span><br><span class="line"><span class="comment">// err: even number: 5</span></span><br><span class="line"><span class="comment">// num: 6</span></span><br><span class="line"><span class="comment">// err: even number: 7</span></span><br><span class="line"><span class="comment">// num: 8</span></span><br><span class="line"><span class="comment">// err: little than 4: 2</span></span><br><span class="line"><span class="comment">// err: little than 4: 3</span></span><br><span class="line"><span class="comment">// err: little than 1: 0</span></span><br><span class="line"><span class="comment">// err: little than 4: 4</span></span><br><span class="line"><span class="comment">// err: little than 1: 1</span></span><br></pre></td></tr></table></figure>
<p>似乎有那么点Rust的味道了, 也发现如果泛型出来, filter的函数的map/reduce写起来或许会爽一点</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>关于原子性与数据竞争的学习和思考</title>
    <url>/2021/03/02/%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>关于原子性与数据竞争的学习和思考</p>
<h3 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性?"></a>什么是原子性?</h3><ol>
<li>不存在任何资源竞争的操作都是原子操作, 也就是说只要一个操作完全独立的进行, 那么它就是原子的. </li>
<li>对数据的读取操作中,  每一个load、stroe到硬件层面都是有序的，因此如果单一store/load指令就能完成的操作肯定是原子性的</li>
<li>如果一个操作消耗很长时间, 但是同一时间只允许一个这样的操作存在, 多个同样的操作在时空上是串行的, 那么每个操作都时原子的.</li>
</ol>
<h3 id="汇编代码就是原子性的吗"><a href="#汇编代码就是原子性的吗" class="headerlink" title="汇编代码就是原子性的吗?"></a>汇编代码就是原子性的吗?</h3><p>不是! 汇编代码也不能保证原子性的, 也会违反上面的原则. 比如多个汇编指令同时对一个数据进行操作, 比如初始化一个很大的内存空间, 该操作可以随时被中断, 也不是原子的.</p>
<h3 id="怎么保证我的操作时原子的"><a href="#怎么保证我的操作时原子的" class="headerlink" title="怎么保证我的操作时原子的?"></a>怎么保证我的操作时原子的?</h3><p>在汇编中, 有<code>lock</code>用于保证进行操作时只有一个人进入临界区.</p>
<p>在go中, 可以有<code>atomic</code>和<code>sync.Mutex</code>来保证操作的原子性.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 5.11.4内核COW机制源码分析</title>
    <url>/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="COW写时复制的实现分析"><a href="#COW写时复制的实现分析" class="headerlink" title="COW写时复制的实现分析"></a>COW写时复制的实现分析</h2><h2 id="宏观理解COW"><a href="#宏观理解COW" class="headerlink" title="宏观理解COW"></a>宏观理解COW</h2><p>原因: </p>
<ol>
<li>大部分进程在执行fork后,都会执行与父进程不同的逻辑,通过exec覆盖整个子进程的逻辑地址空间,那样在fork时做一次复制父进程的数据的操作就是一种浪费, 而如果父子进程fork后不执行exec,则父子进程逻辑相同, 只要没有人写数据, 内存也是共享的, 完全没有必要复制. </li>
<li>另外如果一个在一个进程逻辑空间中分配堆空间并进行全0初始化,则没必要每次都进行内存初始化.还有在使用共享的lib时也可以这样节省内存</li>
</ol>
<p>实现方法:<br>1.系统在fork调用时不进行逻辑地址空间中的数据复制, 直接通过mmu把父进程的逻辑地址所对应的物理地址设置为只读,并记录一个引用数. 当父或子进程有一个想写入数据时,如果页面的引用数大于1,会通过MMU读取只读内存区域,从而引发内存页异常中断,在中断处理程序中检测引发异常的原因,发现是cow引起的,则内核开辟一块物理空间,把异常页数据复制进去,然后改变触发异常的逻辑页的实际物理指向,此时父子进程对应的这个逻辑页就不相关了.<br>2.先通过MMU让这些逻辑地址都指向一个只读地址,然后在写访问这个地址时同样产生页异常中断,此时才实际分配物理内存空间.</p>
<p>可能带来的负面问题:<br>如果fork后不执行exec且父子进程都是对进程空间进行大量地写, 那么就会不断地产生大量页面异常中断, 反而可能会出现性能下降.</p>
<h2 id="涉及到的一些基本概念和数据结构"><a href="#涉及到的一些基本概念和数据结构" class="headerlink" title="涉及到的一些基本概念和数据结构"></a>涉及到的一些基本概念和数据结构</h2><p>进程结构体: <code>task_struct</code> ,其中包含有该进程的内存结构体 <code>mm_struct</code>(定义在<code>include/linux/mm_types.h :386</code>).<br>在<code>mm_struct</code>中有以下字段和COW相关:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pgd_t</span> * pgd; <span class="comment">// pgd的指针</span></span><br><span class="line"><span class="keyword">atomic_t</span> mm_users;  <span class="comment">// 使用的用户数量</span></span><br><span class="line"><span class="keyword">atomic_t</span> mm_count;  <span class="comment">//被引用的次数, 包括匿名用户引用</span></span><br><span class="line"><span class="keyword">int</span> map_count; <span class="comment">// vma的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">// vma的双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>  <span class="comment">// vma的红黑树root节点, 便于加快查找vma</span></span><br></pre></td></tr></table></figure>

<hr>
<p>而<code>vma_struct</code>的结构(定义在<code>include/linux/mm_types.h :303</code>)中包含了<code>vma(virtual memory area)</code>的起止地址,前/后一个vma的指针和所属mm_struct指针等信息:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start; <span class="comment">//起始地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;  <span class="comment">//终止地址的下一个位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>  <span class="comment">// 前后vma指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>  <span class="comment">// 所属的mm指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags; <span class="comment">// 访问权限</span></span><br></pre></td></tr></table></figure>

<p>vma对应着程序的heap, stack, bss, data, text等区域, 没有映射文件的vma是匿名的(stack, heap等).</p>
<hr>
<p>pte(page table entry)是虚拟地址页表项, 对应一个物理页, 其定义是一个32/64位的UL数.<br>其中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  物理地址的起始位置    | avail | G | PAT |D |A| PCD | PWT | U&#x2F;S | R&#x2F;W| P |</span><br></pre></td></tr></table></figure>

<p>其中P(0)表示是否有物理页, 0表示缺页(被换出或未分配)<br>R/W(1)表示页是否可读写, 0 表示只读<br>U/S(2)表示页的访问权限, 0 表示只内核可以访问<br>D(6)表示页是否脏页, 1为脏页<br>A(5)表示是否被访问过, 1为被访问</p>
<p>x86的PAGE_SHIFT为 12, 定义在<code>arch/x86/include/asm/page_types.h</code></p>
<hr>
<p>linux目前采用统一的4级页表管理法, 把虚拟地址划分成如下一些部分做页面查找:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 未使用(16bit) | PGD(9bit) | PUD(9bit) | PMD(9bit) | PTE(9bit) | OFFSET (PAGE_SHIFT&#x3D;12bit) |</span><br></pre></td></tr></table></figure>

<p>其中高位128T给内核, 地位128T给用户空间, 中间空间的目前是保留.</p>
<p>每个物理页和虚拟页都默认4KB对齐的数据空间.</p>
<p>在x86系统下, 寄存器 CR2 存放缺页异常是的vma, CR3放当前进程的页目录的物理地址基址, 用于做页面查找</p>
<p>进程的获取虚拟页面对应的物理页的方式是通过MMU硬件自动完成的, MMU内部有一个TLB的页表缓存区域, 用于加快页表索引时速度, 减少多次读取内存的开销. MMU通过CPU给出的虚拟地址, 取第48-39位,得到PGD的偏移量, 加上PGD对应的物理位置获得PUD的物理位置,取出数据加上38-30位得到PMD的物理位置,取出再加上29-21位得到PTE的物理位置, 取出后加上OFFSET偏移得到实际的物理内存地址.</p>
<p>内核页表放在<code>swapper_pg_dir</code>中, 进程内的内核页表是其内核页表的拷贝, 这样可以减少在进程陷入系统调用时, TLB. CR3的数据切换刷新.</p>
<hr>
<p>内存交换所换出的内存页分为两种, 文件映射页（file-backed page）和匿名页（anonymous page), 文件映射页直接通过文件进行读写, 而匿名页则需要通过硬盘中单独的交换分区进行读写. 匿名页包括各种堆,栈,bss,pipe,数据段,tmpfs等的页, 用户态一般通过malloc,mmap,brk/sbrk申请.</p>
<p>linux中通过LRU算法执行对页面的swap回收操作, x86页表中的accessed位标记了页面是否最近被访问, 当页面被MMU访问到时会自动设置, 之后需要通过函数调用来清除标记位.</p>
<hr>
<p>物理内存页用<code>struct page</code>(定义在<code>include/linux/mm_types.h :69</code>)表示. 其中<code>atomic_t _mapcount;</code>表示物理页的被使用计数,  如果为0, 则该物理页不再被任何人使用.</p>
<hr>
<p>hugetlb是内存大页的tlb页表, 指向大页, 而huge page的大小和pmd所管理的物理页总大小是一致的. 默认是2^9 * 4k = 2M.在TLB中通过hugetlb指向huge page, 而被分配的大页作为hugetlbfs被提供给进程使用,类似tmpfs.</p>
<hr>
<p>rmap是用于通过匿名页方向查找到使用该物理页的pte的数据结构,该反向映射用于在回收物理内存时断开使用该物理页的所有进程等场景.</p>
<h2 id="分析对象"><a href="#分析对象" class="headerlink" title="分析对象"></a>分析对象</h2><p>linux内核: linux-5.11.4</p>
<p>体系结构: x86_64</p>
<h2 id="fork系统调用中的COW"><a href="#fork系统调用中的COW" class="headerlink" title="fork系统调用中的COW"></a>fork系统调用中的COW</h2><p>主要的作用链路是: <code>kernel_clone -&gt; copy_process -&gt; copy_mm -&gt; dup_mm -&gt; dup_mmap -&gt;copy_page_range -&gt; copy_p4d_range -&gt; copy_pud_range -&gt; copy_pmd_range -&gt; copy_pte_range -&gt; copy_present_pte/copy_nopresent_pte</code></p>
<p>fork通过系统中断触发, x86_64的系统中断入口定义在<code>arch/x86/entry/entry_64.S :95</code>处. 其中会执行<code>call do_syscall_64</code>进入中断响应程序选择逻辑,<code>do_syscall_64</code>定义在<code>arch/x86/entry/common.c :39</code>处, 其中会查询中断描述符表, 这个表在<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中定义了64位系统下fork系统调用的中断号: <code>57    common    fork            sys_fork</code>. 之后会执行到<code>kernel_clone</code>(定义在<code>kernel/fork.c :2412</code>)进行fork的主要处理逻辑. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="function">__visible noinstr <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">	instrumentation_begin();</span><br><span class="line">	<span class="keyword">if</span> (likely(nr &lt; NR_syscalls)) &#123;</span><br><span class="line">		nr = array_index_nospec(nr, NR_syscalls);</span><br><span class="line">		regs-&gt;ax = sys_call_table[nr](regs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_X32_ABI</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (likely((nr &amp; __X32_SYSCALL_BIT) &amp;&amp;</span><br><span class="line">			  (nr &amp; ~__X32_SYSCALL_BIT) &lt; X32_NR_syscalls)) &#123;</span><br><span class="line">		nr = array_index_nospec(nr &amp; ~__X32_SYSCALL_BIT,</span><br><span class="line">					X32_NR_syscalls);</span><br><span class="line">		regs-&gt;ax = x32_sys_call_table[nr](regs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	instrumentation_end();</span><br><span class="line">	syscall_exit_to_user_mode(regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> instrumentation_begin() (&#123;					\</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"%c0: nop\n\t"</span>						\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".pushsection .discard.instr_begin\n\t"</span>		\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".long %c0b - .\n\t"</span>				\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".popsection\n\t"</span> : : <span class="string">"i"</span> (__COUNTER__))</span></span>;		\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> instrumentation_end() (&#123;					\</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"%c0: nop\n\t"</span>					\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".pushsection .discard.instr_end\n\t"</span>		\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".long %c0b - .\n\t"</span>				\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".popsection\n\t"</span> : : <span class="string">"i"</span> (__COUNTER__))</span></span>;		\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em>ps: 这里书上说通过cs和eip寄存器给出了 IDT表中第i项门描述符的段选择符和偏移量字段, 通过其可以跳转到被选中的中断处理程序的第一条指令这个执行过程是由硬件自动完成的</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">kernel_clone</span><span class="params">(struct kernel_clone_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 数据初始化和flags判断</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在copy_process中进行进程拷贝逻辑</span></span><br><span class="line">	p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取pid</span></span><br><span class="line">	...</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// 唤醒新的进程</span></span><br><span class="line">	wake_up_new_task(p);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ptrace相关</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// namespace中加入新的pid</span></span><br><span class="line">	put_pid(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_process</code>(定义在<code>kernel/fork.c :1844</code>)中执行进程拷贝的逻辑:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __latent_entropy struct task_struct *<span class="title">copy_process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">					struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> trace,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> node,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct kernel_clone_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先进行flags检查,namespace检查, signal的暂存</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 复制进程结构体, audit,perf,cgroup信息等复制和设置</span></span><br><span class="line">	dup_task_struct </span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 执行进程的各种资源拷贝</span></span><br><span class="line">	shm_init_task(p);</span><br><span class="line">	retval = security_task_alloc(p, clone_flags);</span><br><span class="line">	retval = copy_semundo(clone_flags, p);</span><br><span class="line">	retval = copy_files(clone_flags, p);</span><br><span class="line">	retval = copy_fs(clone_flags, p);</span><br><span class="line">	retval = copy_sighand(clone_flags, p);</span><br><span class="line">	retval = copy_signal(clone_flags, p);</span><br><span class="line">	<span class="comment">// 拷贝内存资源</span></span><br><span class="line">	retval = copy_mm(clone_flags, p);</span><br><span class="line">	retval = copy_namespaces(clone_flags, p);</span><br><span class="line">	retval = copy_io(clone_flags, p);</span><br><span class="line">	retval = copy_thread(clone_flags, args-&gt;<span class="built_in">stack</span>, args-&gt;stack_size, p, args-&gt;tls);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 分配pid等其他收尾工作</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存的拷贝"><a href="#内存的拷贝" class="headerlink" title="内存的拷贝"></a>内存的拷贝</h3><p>在<code>copy_mm</code>(定义在<code>kernel/fork.c :1382</code>) 中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;  <span class="comment">// 如果是内核进程, 这个字段会一直为NULL</span></span><br><span class="line">	tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果是CLONE_VM, 则直接跳到good_mm, 将mm和active_mm都设置为当前进程的mm</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123; </span><br><span class="line">		mmget(oldmm); <span class="comment">//原子增加oldmm中mm_users计数,即oldmm的使用者数量</span></span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 不是CLONE_VM的都执行拷贝mm的操作, COW主要看这里的实现</span></span><br><span class="line">	mm = dup_mm(tsk, current-&gt;mm);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">	tsk-&gt;mm = mm;</span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里用到的<code>mmget</code>是一个专门用于增加mm的使用计数的方法, 其定义(在<code>include/linux/sched/mm.h :68</code>)如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mmget</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atomic_inc(&amp;mm-&gt;mm_users); <span class="comment">//原子增加计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而与<code>mmget</code>对应的减少计数并在计数为0时释放资源的方法<code>mmput</code>定义(在<code>kernel/fork.c :1074-1104</code>)如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __mmput(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">	VM_BUG_ON(atomic_read(&amp;mm-&gt;mm_users));</span><br><span class="line"></span><br><span class="line">	uprobe_clear_state(mm);</span><br><span class="line">	exit_aio(mm);</span><br><span class="line">	ksm_exit(mm);</span><br><span class="line">	khugepaged_exit(mm); <span class="comment">/* must run before exit_mmap */</span></span><br><span class="line">	exit_mmap(mm);</span><br><span class="line">	mm_put_huge_zero_page(mm);</span><br><span class="line">	set_mm_exe_file(mm, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;mm-&gt;mmlist)) &#123;</span><br><span class="line">		spin_lock(&amp;mmlist_lock);</span><br><span class="line">		list_del(&amp;mm-&gt;mmlist);</span><br><span class="line">		spin_unlock(&amp;mmlist_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mm-&gt;binfmt)</span><br><span class="line">		module_put(mm-&gt;binfmt-&gt;<span class="keyword">module</span>);</span><br><span class="line">	mmdrop(mm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decrement the use count and release all resources for an mm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmput</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	might_sleep();  </span><br><span class="line">	<span class="comment">// 原子减计数并看是否为0</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;mm-&gt;mm_users))</span><br><span class="line">		__mmput(mm); <span class="comment">//具体的释放mm的动作</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(mmput);</span><br></pre></td></tr></table></figure>
<p><em>ps: 这里might_sleep(); 是什么原因还没搞明白</em></p>
<p>非CLONE_VM的继续执行<code>dup_mm</code>(在<code>kernel/fork.c :1345</code>)拷贝<code>mm_struct</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mm_struct *<span class="title">dup_mm</span><span class="params">(struct task_struct *tsk,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct mm_struct *oldmm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 创建一个mm</span></span><br><span class="line">	mm = allocate_mm();</span><br><span class="line">	<span class="comment">// 拷贝就的mm的数据</span></span><br><span class="line">	<span class="built_in">memcpy</span>(mm, oldmm, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line">	<span class="comment">// 初始化新的mm</span></span><br><span class="line">	<span class="keyword">if</span> (!mm_init(mm, tsk, mm-&gt;user_ns))</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">	<span class="comment">// 拷贝vma双向链表数据, 内部针对COW做了处理</span></span><br><span class="line">	err = dup_mmap(mm, oldmm);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 返回mm</span></span><br><span class="line">	<span class="keyword">return</span> mm;</span><br><span class="line">	<span class="comment">// 其他执行错误情况处理</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>mm_init</code>(在<code>kernel/fork.c  :1004</code>处)中做了与COW相关的一些设置: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mm-&gt;mmap = <span class="literal">NULL</span>; <span class="comment">//设置mmp为空</span></span><br><span class="line"><span class="comment">//设置红黑树为根为空的哨兵节点: </span></span><br><span class="line"><span class="comment">// 其定义为: </span></span><br><span class="line"><span class="comment">// #define RB_ROOT	(struct rb_root) &#123; NULL, &#125; </span></span><br><span class="line"><span class="comment">// 在include/linux/rbtree.h :37处</span></span><br><span class="line">mm-&gt;mm_rb = RB_ROOT; </span><br><span class="line"><span class="comment">// 初始化mm_users和mm_count为1</span></span><br><span class="line">atomic_set(&amp;mm-&gt;mm_users, <span class="number">1</span>);  </span><br><span class="line">atomic_set(&amp;mm-&gt;mm_count, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置map_count计数为0</span></span><br><span class="line">mm-&gt;map_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>主要的拷贝mmap的逻辑由<code>dup_mmap</code>(在<code>kernel/fork.c  :470-644</code>处)完成, 这里分两种情况处理: </p>
<ol>
<li>配置了MMU: <code>#ifdef CONFIG_MMU</code></li>
<li>没有配置CONFIG_MMU, 这里只执行: <code>RCU_INIT_POINTER(mm-&gt;exe_file, get_mm_exe_file(oldmm));</code>的逻辑, 对exe_file部分做RCU初始化,使exe_file指向父进程的exe_file,使得两者一致,即任意读都可以,并在写的时候复制副本完成修改写入,之后再一次性替换原来的数据. </li>
</ol>
<p>针对配置了MMU的场景: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __latent_entropy <span class="keyword">int</span> <span class="title">dup_mmap</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct mm_struct *oldmm)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uprobe_start_dup_mmap(); <span class="comment">// 执行: percpu_down_read(&amp;dup_mmap_sem) , 锁定读锁</span></span><br><span class="line">	...</span><br><span class="line">	flush_cache_dup_mm(oldmm); <span class="comment">// 刷cache到内存, 确保脏页落到内存中.</span></span><br><span class="line">	...</span><br><span class="line">	RCU_INIT_POINTER(mm-&gt;exe_file, get_mm_exe_file(oldmm));</span><br><span class="line">	<span class="comment">// 拷贝vm配置</span></span><br><span class="line">	mm-&gt;total_vm = oldmm-&gt;total_vm;</span><br><span class="line">	mm-&gt;data_vm = oldmm-&gt;data_vm;</span><br><span class="line">	mm-&gt;exec_vm = oldmm-&gt;exec_vm;</span><br><span class="line">	mm-&gt;stack_vm = oldmm-&gt;stack_vm;</span><br><span class="line">	...</span><br><span class="line">	pprev = &amp;mm-&gt;mmap;</span><br><span class="line">	retval = ksm_fork(mm, oldmm); <span class="comment">// ksm合并内核的相同页面</span></span><br><span class="line">	...</span><br><span class="line">	prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 循环遍历拷贝mmap中的每个vma执行拷贝逻辑</span></span><br><span class="line">	<span class="keyword">for</span> (mpnt = oldmm-&gt;mmap; mpnt; mpnt = mpnt-&gt;vm_next) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果flag是VM_DONTCOPY则跳过</span></span><br><span class="line">		<span class="keyword">if</span> (mpnt-&gt;vm_flags &amp; VM_DONTCOPY) &#123;</span><br><span class="line">			vm_stat_account(mm, mpnt-&gt;vm_flags, -vma_pages(mpnt));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果有收到kill信号就退出执行</span></span><br><span class="line">		<span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">			retval = -EINTR;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 拷贝vma的结构</span></span><br><span class="line">		tmp = vm_area_dup(mpnt);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果flag是VM_WIPEONFORK,则把匿名vma设置为空</span></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;vm_flags &amp; VM_WIPEONFORK) &#123;</span><br><span class="line">			tmp-&gt;anon_vma = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">// 拷贝匿名区</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (anon_vma_fork(tmp, mpnt))</span><br><span class="line">			<span class="keyword">goto</span> fail_nomem_anon_vma_fork;</span><br><span class="line">		<span class="comment">// vm_file部分拷贝等处理</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果是hugetlb的页,且私有的,则直接设置计数为0</span></span><br><span class="line">		<span class="keyword">if</span> (is_vm_hugetlb_page(tmp))</span><br><span class="line">			reset_vma_resv_huge_pages(tmp);</span><br><span class="line">		*pprev = tmp;</span><br><span class="line">		pprev = &amp;tmp-&gt;vm_next;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 拷贝vma中的所有页</span></span><br><span class="line">		mm-&gt;map_count++;</span><br><span class="line">		<span class="comment">// 不是VM_WIPEONFORK的, 则执行拷贝逻辑</span></span><br><span class="line">		<span class="keyword">if</span> (!(tmp-&gt;vm_flags &amp; VM_WIPEONFORK))</span><br><span class="line">			retval = copy_page_range(tmp, mpnt);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	retval = arch_dup_mmap(oldmm, mm); <span class="comment">//体系结构相关的拷贝处理</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>ps: 这里pprev 看代码似乎没有被用到, 不知道其有什么用意, 还是这里就是冗余代码</em></p>
<p>在<code>copy_page_range</code>(定义在<code>mm/memory.c  :1126</code>处)中执行4级页表的拷贝, 这里会有两种情况的拷贝, hugetlb情况和正常情况两种处理.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_page_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = src_vma-&gt;vm_start; <span class="comment">// vma的起始地址,会被内部函数一直传递下去</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 判断不需要进行拷贝的情况</span></span><br><span class="line">	<span class="keyword">if</span> (!(src_vma-&gt;vm_flags &amp; (VM_HUGETLB | VM_PFNMAP | VM_MIXEDMAP)) &amp;&amp;</span><br><span class="line">	    !src_vma-&gt;anon_vma)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果是vma是hugetlb_page,则单独进行copy_hugetlb_page_range处理并直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (is_vm_hugetlb_page(src_vma))</span><br><span class="line">		<span class="keyword">return</span> copy_hugetlb_page_range(dst_mm, src_mm, src_vma);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(src_vma-&gt;vm_flags &amp; VM_PFNMAP)) &#123;</span><br><span class="line">		<span class="comment">// 不常见的场景处理: 当vma包含VM_PFNMAP的flag时进行copy处理,</span></span><br><span class="line">		<span class="comment">// track_pfn_copy只有在x86下有定义在arch/x86/mm/pat/memtype.c中的处理逻辑, 其他都是arch都是直接返回0. </span></span><br><span class="line">		<span class="comment">// x86下, 在track_pfn_copy中如果检测到vma包含VM_PAT的flag,则执行reserve_pfn_range操作. </span></span><br><span class="line">		<span class="comment">// reserve_pfn_range定义在arch/x86/mm/pat/memtype.c :906行处</span></span><br><span class="line">		ret = track_pfn_copy(src_vma);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断是否cow类型的vma</span></span><br><span class="line">	is_cow = is_cow_mapping(src_vma-&gt;vm_flags); <span class="comment">// is_cow_mapping定义在mm/internal.h :299行中, </span></span><br><span class="line">	<span class="comment">// 当是cow时, 先进行mmu的相关设置</span></span><br><span class="line">	<span class="keyword">if</span> (is_cow) &#123;</span><br><span class="line">	      <span class="comment">// 获取父进程vma对应的内存range</span></span><br><span class="line">		mmu_notifier_range_init(&amp;range, MMU_NOTIFY_PROTECTION_PAGE,</span><br><span class="line">					<span class="number">0</span>, src_vma, src_mm, addr, <span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 设置该range 起始位置之后的mmu映射无效, 即通知其他MMU做清理</span></span><br><span class="line">		mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">		<span class="comment">// 确保父进程vma被锁定</span></span><br><span class="line">		mmap_assert_write_locked(src_mm);</span><br><span class="line">		raw_write_seqcount_begin(&amp;src_mm-&gt;write_protect_seq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历执行pgd级别的相关页表项拷贝</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	dst_pgd = pgd_offset(dst_mm, addr);</span><br><span class="line">	src_pgd = pgd_offset(src_mm, addr);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		next = pgd_addr_end(addr, <span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 如果pgd不正常则继续下一个循环</span></span><br><span class="line">		<span class="keyword">if</span> (pgd_none_or_clear_bad(src_pgd))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 此处调用copy_p4d_range执行下一级的页表项拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(copy_p4d_range(dst_vma, src_vma, dst_pgd, src_pgd,</span><br><span class="line">					    addr, next))) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pgd++, src_pgd++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="comment">// 拷贝结束后针对cow的页执行收尾</span></span><br><span class="line">	<span class="keyword">if</span> (is_cow) &#123;</span><br><span class="line">		raw_write_seqcount_end(&amp;src_mm-&gt;write_protect_seq);</span><br><span class="line">		<span class="comment">// 通知其他MMU清理映射关系的结束位置</span></span><br><span class="line">		mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索相关文献后得知:<code>mmu_notifier_invalidate_range_start</code> 和<code>mmu_notifier_invalidate_range_end</code>都是在2008年2.6.27的合并窗口里面加入的, 用于通知其他MMU移除这些范围内的内存页的映射,避免MMU的缓存错误</p>
<p>其中关于<code>is_cow_mapping</code>(定义在<code>mm/internal.h :299</code>处)的内容如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_cow_mapping</span><span class="params">(<span class="keyword">vm_flags_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// flags中一定有VM_MAYWRITE且不含VM_SHARED的是cow页</span></span><br><span class="line">	<span class="keyword">return</span> (flags &amp; (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中VM_SHARED为0x00000008, VM_MAYWRITE为0<br>x0000020, 则这个表达式检测了vma是否私有且可写, 是则判定这个vma是cow的.</p>
<h5 id="针对内存大页tlb的拷贝处理"><a href="#针对内存大页tlb的拷贝处理" class="headerlink" title="针对内存大页tlb的拷贝处理"></a>针对内存大页tlb的拷贝处理</h5><p>对于hugetlb_page执行的<code>copy_hugetlb_page_range</code>(定义在<code>mm/hugetlb.c :3779</code>处), 其逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_hugetlb_page_range</span><span class="params">(struct mm_struct *dst, struct mm_struct *src,</span></span></span><br><span class="line"><span class="function"><span class="params">			    struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// ps: 这里和上面的is_cow_mapping功能一致, 但是却自己又写了一遍.  不知是为啥.</span></span><br><span class="line">	cow = (vma-&gt;vm_flags &amp; (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;</span><br><span class="line">	<span class="keyword">if</span> (cow) &#123;</span><br><span class="line">		mmu_notifier_range_init(&amp;range, MMU_NOTIFY_CLEAR, <span class="number">0</span>, vma, src,</span><br><span class="line">					vma-&gt;vm_start,</span><br><span class="line">					vma-&gt;vm_end);</span><br><span class="line">		mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i_mmap_lock_read(mapping);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历vma执行页拷贝</span></span><br><span class="line">	<span class="keyword">for</span> (addr = vma-&gt;vm_start; addr &lt; vma-&gt;vm_end; addr += sz) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (huge_pte_none(entry) || !huge_pte_none(dst_entry)) &#123;</span><br><span class="line">			;</span><br><span class="line">		<span class="comment">// 如果大页是被换出的页</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(is_hugetlb_entry_migration(entry) ||</span><br><span class="line">				    is_hugetlb_entry_hwpoisoned(entry))) &#123;</span><br><span class="line">			<span class="comment">// 如果父进程的pte页可写且vma是私有可写的则设置父进程的pte只读, 并设置子进程的页为父进程的处于swap中的页</span></span><br><span class="line">			<span class="keyword">if</span> (is_write_migration_entry(swp_entry) &amp;&amp; cow) &#123;</span><br><span class="line">				make_migration_entry_read(&amp;swp_entry);</span><br><span class="line">				entry = swp_entry_to_pte(swp_entry);</span><br><span class="line">				set_huge_swap_pte_at(src, addr, src_pte,</span><br><span class="line">						     entry, sz);</span><br><span class="line">			&#125;</span><br><span class="line">			set_huge_swap_pte_at(dst, addr, dst_pte, entry, sz);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		      <span class="comment">// 如果是私有可写的页, 则设置父进程的页的W/R为0即只读</span></span><br><span class="line">			<span class="keyword">if</span> (cow) &#123;</span><br><span class="line">				huge_ptep_set_wrprotect(src, addr, src_pte);</span><br><span class="line">			&#125;</span><br><span class="line">			entry = huge_ptep_get(src_pte);</span><br><span class="line">			ptepage = pte_page(entry);</span><br><span class="line">			<span class="comment">// 增加物理页引用计数</span></span><br><span class="line">			get_page(ptepage);</span><br><span class="line">			<span class="comment">// 增加page被映射的计数</span></span><br><span class="line">			page_dup_rmap(ptepage, <span class="literal">true</span>);</span><br><span class="line">			<span class="comment">// 设置子进程的pte对应的物理页为父进程的page</span></span><br><span class="line">			set_huge_pte_at(dst, addr, dst_pte, entry);</span><br><span class="line">			<span class="comment">// 增加hugetlb中的使用计数, 此方法即执行了: atomic_long_add(l, &amp;mm-&gt;hugetlb_usage);. 位于include/linux/hugetlb.h :736处</span></span><br><span class="line">			hugetlb_count_add(pages_per_huge_page(h), dst);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝结束后的相关处理</span></span><br><span class="line">	<span class="keyword">if</span> (cow)</span><br><span class="line">		mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i_mmap_unlock_read(mapping);</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="针对默认普通页的拷贝处理"><a href="#针对默认普通页的拷贝处理" class="headerlink" title="针对默认普通页的拷贝处理"></a>针对默认普通页的拷贝处理</h5><p>从<code>copy_page_range</code>跳到<code>copy_p4d_range</code>(在<code>mm/memory.c  :1103</code>处)后, 主要进行遍历循环pgd下的pud进行拷贝</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_p4d_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">pgd_t</span> *dst_pgd, <span class="keyword">pgd_t</span> *src_pgd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (copy_pud_range(dst_vma, src_vma, dst_p4d, src_p4d,</span><br><span class="line">				   addr, next))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_p4d++, src_p4d++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_pud_range</code>(在<code>mm/memory.c  :1066</code>处)中循环遍历进行pud下的所有pmd拷贝:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_pud_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">p4d_t</span> *dst_p4d, <span class="keyword">p4d_t</span> *src_p4d, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 特殊情况处理</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 执行pmd拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (copy_pmd_range(dst_vma, src_vma, dst_pud, src_pud,</span><br><span class="line">				   addr, next))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pud++, src_pud++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_pmd_range</code>(在<code>mm/memory.c  :1029</code>处) 中循环遍历进行pte的拷贝, 这里会有个分叉, 如果是huge_pmd或者处于swap中或是设备映射的页表则跳到<code>copy_huge_pmd</code>执行, 普通的页则执行<code>copy_pte_range</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_pmd_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">pud_t</span> *dst_pud, <span class="keyword">pud_t</span> *src_pud, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 处理huge_pmd或者处于swap中或是设备映射的页表的拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)</span><br><span class="line">			|| pmd_devmap(*src_pmd)) &#123;</span><br><span class="line">				...</span><br><span class="line">				err = copy_huge_pmd(dst_mm, src_mm,</span><br><span class="line">					    dst_pmd, src_pmd, addr, src_vma);</span><br><span class="line">				<span class="keyword">if</span> (err == -ENOMEM)</span><br><span class="line">					<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">				<span class="keyword">if</span> (!err)</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">// 如果完成拷贝则继续下一个pmd的处理</span></span><br><span class="line">				<span class="comment">// copy_huge_pmd返回的err都是小于或等于0的, 此处fall through 感觉一般不可能被触发</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 处理普通pte的拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (copy_pte_range(dst_vma, src_vma, dst_pmd, src_pmd,</span><br><span class="line">				   addr, next))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;	</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pmd++, src_pmd++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理大pmd的拷贝-copy-huge-pmd"><a href="#处理大pmd的拷贝-copy-huge-pmd" class="headerlink" title="处理大pmd的拷贝: copy_huge_pmd"></a>处理大pmd的拷贝: <code>copy_huge_pmd</code></h5><p><code>copy_huge_pmd</code>代码在<code>mm/huge_memory.c :1011</code>处:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_huge_pmd</span><span class="params">(struct mm_struct *dst_mm, struct mm_struct *src_mm,</span></span></span><br><span class="line"><span class="function"><span class="params">		  <span class="keyword">pmd_t</span> *dst_pmd, <span class="keyword">pmd_t</span> *src_pmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">		  struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 特殊情况处理,条件检查和加锁等操作</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 大零页的处理, </span></span><br><span class="line">	<span class="keyword">if</span> (is_huge_zero_pmd(pmd)) &#123;</span><br><span class="line">		zero_page = mm_get_huge_zero_page(dst_mm);</span><br><span class="line">		<span class="comment">// 直接设置子进程页为大零页</span></span><br><span class="line">		set_huge_zero_page(pgtable, dst_mm, vma, addr, dst_pmd,</span><br><span class="line">				zero_page);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对私有可写且pinned的页进程处理</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_cow_mapping(vma-&gt;vm_flags) &amp;&amp;</span><br><span class="line">		     atomic_read(&amp;src_mm-&gt;has_pinned) &amp;&amp;</span><br><span class="line">		     page_maybe_dma_pinned(src_page))) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 增加父进程页的计数</span></span><br><span class="line">	get_page(src_page);</span><br><span class="line">	<span class="comment">// 增加父进程页的映射计数</span></span><br><span class="line">	page_dup_rmap(src_page, <span class="literal">true</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 设置父进程pmd只读</span></span><br><span class="line">	pmdp_set_wrprotect(src_mm, addr, src_pmd);</span><br><span class="line">	<span class="comment">// 设置子进程pmd只读且未被最近访问</span></span><br><span class="line">	pmd = pmd_mkold(pmd_wrprotect(pmd));</span><br><span class="line">	<span class="comment">// 设置子进程的pmd为新建的pmd,使拷贝生效</span></span><br><span class="line">	set_pmd_at(dst_mm, addr, dst_pmd, pmd);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理对普通pmd下的所有pte的拷贝-copy-pte-range"><a href="#处理对普通pmd下的所有pte的拷贝-copy-pte-range" class="headerlink" title="处理对普通pmd下的所有pte的拷贝: copy_pte_range"></a>处理对普通pmd下的所有pte的拷贝: <code>copy_pte_range</code></h5><p>对普通pte的拷贝的处理代码位于<code>mm/memory.c :923</code>处, 逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_pte_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">pmd_t</span> *dst_pmd, <span class="keyword">pmd_t</span> *src_pmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 一些变量初始化和条件判断,加锁等</span></span><br><span class="line">	...</span><br><span class="line">again:</span><br><span class="line">	progress = <span class="number">0</span>;</span><br><span class="line">	...	</span><br><span class="line">	<span class="comment">// 循环执行处理:</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">// 如果progress&gt;=32 则检查是否需要进行重新schedule.是则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (progress &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">			progress = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (need_resched() ||</span><br><span class="line">			    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// pte是空的情况直接progress++</span></span><br><span class="line">		<span class="keyword">if</span> (pte_none(*src_pte)) &#123;</span><br><span class="line">			progress++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断pte是不是present的即在内存中的, 大概率可能是的, 如果不是, 则执行copy_nonpresent_pte的逻辑, 否则就执行copy_present_pte的逻辑, 不论哪种执行后都将progress加8.</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pte_present(*src_pte))) &#123;</span><br><span class="line">			entry.val = copy_nonpresent_pte(dst_mm, src_mm,</span><br><span class="line">							dst_pte, src_pte,</span><br><span class="line">							src_vma, addr, rss);</span><br><span class="line">			<span class="keyword">if</span> (entry.val)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			progress += <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = copy_present_pte(dst_vma, src_vma, dst_pte, src_pte,</span><br><span class="line">				       addr, rss, &amp;prealloc);</span><br><span class="line">		...		  </span><br><span class="line">		progress += <span class="number">8</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="comment">// 拷贝结束后的收尾处理</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断pte是不是在内存中的逻辑不同体系结构定义不同, 在x86_64中定义为判断pte中第0位(P位)的值是不是1. </p>
<h5 id="不在物理内存中的pte的拷贝"><a href="#不在物理内存中的pte的拷贝" class="headerlink" title="不在物理内存中的pte的拷贝"></a>不在物理内存中的pte的拷贝</h5><p><code>copy_nonpresent_pte</code>位于<code>mm/memory.c :698</code>处:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">copy_nonpresent_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,</span><br><span class="line">		<span class="keyword">pte_t</span> *dst_pte, <span class="keyword">pte_t</span> *src_pte, struct vm_area_struct *vma,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">int</span> *rss)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> pte = *src_pte;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">swp_entry_t</span> entry = pte_to_swp_entry(pte);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 大概率是在swap中的pte, 则执行swap_duplicate增加其引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!non_swap_entry(entry))) &#123;</span><br><span class="line">		...</span><br><span class="line">	<span class="comment">// 如果是换入的页</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_migration_entry(entry)) &#123;</span><br><span class="line">		page = migration_entry_to_page(entry);</span><br><span class="line">		<span class="comment">// 物理页引用增加</span></span><br><span class="line">		rss[mm_counter(page)]++;</span><br><span class="line">		<span class="comment">// 如果pte页是可写的且vma是私有可写的</span></span><br><span class="line">		<span class="keyword">if</span> (is_write_migration_entry(entry) &amp;&amp;</span><br><span class="line">				is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">			<span class="comment">// 设置父进程pte只读</span></span><br><span class="line">			make_migration_entry_read(&amp;entry);</span><br><span class="line">			pte = swp_entry_to_pte(entry);</span><br><span class="line">			<span class="comment">// 如果父进程页脏则设置子进程页脏</span></span><br><span class="line">			<span class="keyword">if</span> (pte_swp_soft_dirty(*src_pte))</span><br><span class="line">				pte = pte_swp_mksoft_dirty(pte);</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 重新设置父进程pte</span></span><br><span class="line">			set_pte_at(src_mm, addr, src_pte, pte);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 如果是设备私有的pte</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_device_private_entry(entry)) &#123;</span><br><span class="line">		page = device_private_entry_to_page(entry);</span><br><span class="line">		<span class="comment">// 增加page引用计数,映射计数,rss计数</span></span><br><span class="line">		get_page(page);</span><br><span class="line">		rss[mm_counter(page)]++;</span><br><span class="line">		page_dup_rmap(page, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 如果私有可写的设备pte, 且vma私有可写</span></span><br><span class="line">		<span class="keyword">if</span> (is_write_device_private_entry(entry) &amp;&amp;</span><br><span class="line">		    is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">		    <span class="comment">// 设置pte只读</span></span><br><span class="line">			make_device_private_entry_read(&amp;entry);</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 重新设置父进程pte</span></span><br><span class="line">			set_pte_at(src_mm, addr, src_pte, pte);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置子进程的pte</span></span><br><span class="line">	set_pte_at(dst_mm, addr, dst_pte, pte);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处于物理内存中的pte的拷贝"><a href="#处于物理内存中的pte的拷贝" class="headerlink" title="处于物理内存中的pte的拷贝"></a>处于物理内存中的pte的拷贝</h5><p>代码位于<code>mm/memory.c :851</code>中, 逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_present_pte(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">		 <span class="keyword">pte_t</span> *dst_pte, <span class="keyword">pte_t</span> *src_pte, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">int</span> *rss,</span><br><span class="line">		 struct page **prealloc)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取父进程pte对应的page结构描述符</span></span><br><span class="line">	page = vm_normal_page(src_vma, addr, pte);</span><br><span class="line">	<span class="comment">// 如果page存在, 则执行拷贝物理页逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 执行拷贝物理页的逻辑</span></span><br><span class="line">		retval = copy_present_page(dst_vma, src_vma, dst_pte, src_pte,</span><br><span class="line">					   addr, rss, prealloc, pte, page);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 增加page引用计数</span></span><br><span class="line">		get_page(page);</span><br><span class="line">		<span class="comment">// 增加page的映射计数</span></span><br><span class="line">		page_dup_rmap(page, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 增加rss计数</span></span><br><span class="line">		rss[mm_counter(page)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果vma是私有可写的,且pte可写, 则设置父子进程pte只读, </span></span><br><span class="line">	<span class="keyword">if</span> (is_cow_mapping(vm_flags) &amp;&amp; pte_write(pte)) &#123;</span><br><span class="line">		ptep_set_wrprotect(src_mm, addr, src_pte); <span class="comment">//设置父pte只读</span></span><br><span class="line">		pte = pte_wrprotect(pte); <span class="comment">//设置子pte只读</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果vma是共享的, 则设置pte为非脏的</span></span><br><span class="line">	<span class="keyword">if</span> (vm_flags &amp; VM_SHARED)</span><br><span class="line">		pte = pte_mkclean(pte); <span class="comment">// 内部逻辑是设置pte的D位置为0</span></span><br><span class="line">	<span class="comment">// 设置pte的A位为0, 即最近未被访问</span></span><br><span class="line">	pte = pte_mkold(pte); </span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 设置子进程的pte</span></span><br><span class="line">	set_pte_at(dst_vma-&gt;vm_mm, addr, dst_pte, pte);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>vm_normal_page</code>执行获取虚拟页pte对应关联的物理页page的逻辑:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">vm_normal_page</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">pte_t</span> pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn = pte_pfn(pte); <span class="comment">//获取物理页的page frame页框号码	...</span></span><br><span class="line">	<span class="keyword">return</span> pfn_to_page(pfn); <span class="comment">// 返回物理页, 其逻辑为 (vmem_map + (pfn))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86下<code>pte_pfn</code>的定义在<code>arch/x86/include/asm/pgtable.h :212</code>处:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">pte_pfn</span><span class="params">(<span class="keyword">pte_t</span> pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> pfn = pte_val(pte); <span class="comment">// pte_val 就是native_pte_val, 返回pte.pte</span></span><br><span class="line">	pfn ^= protnone_mask(pfn); </span><br><span class="line">	<span class="keyword">return</span> (pfn &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中变量的定义如下, 而PAGE_SIZE默认是4K的页, 那么在默认4k页情况下PTE_PFN_MASK即为<code>000ffffffffff000</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PFN_MASK		((pteval_t)PHYSICAL_PAGE_MASK)`, </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSICAL_PAGE_MASK	(((signed long)PAGE_MASK) &amp; __PHYSICAL_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MASK		(~(PAGE_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT		12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYSICAL_MASK_SHIFT	52</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DYNAMIC_PHYSICAL_MASK</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">phys_addr_t</span> physical_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYSICAL_MASK		physical_mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYSICAL_MASK		((phys_addr_t)((1ULL &lt;&lt; __PHYSICAL_MASK_SHIFT) - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中的<code>copy_present_page</code>内部会进行判断页是不是pinned和非私有可写的, 如果是非pinned和私有可写的则返回1, 其他情况则执行数据拷贝, 如果遇到错误则返回负数. 代码在<code>mm/memory.c :796</code>处:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_present_page(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">		  <span class="keyword">pte_t</span> *dst_pte, <span class="keyword">pte_t</span> *src_pte, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">int</span> *rss,</span><br><span class="line">		  struct page **prealloc, <span class="keyword">pte_t</span> pte, struct page *page)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果vma是非私有可写的, 返回1, 跳过实际的数据拷贝</span></span><br><span class="line">	<span class="keyword">if</span> (!is_cow_mapping(src_vma-&gt;vm_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 如果是非pinned的页, 则返回1</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!atomic_read(&amp;src_mm-&gt;has_pinned)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (likely(!page_maybe_dma_pinned(page)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 以下则针对pinned的页执行数据拷贝:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 拷贝旧page数据到新页</span></span><br><span class="line">	copy_user_highpage(new_page, page, addr, src_vma);</span><br><span class="line">	<span class="comment">// 强制刷新新物理页</span></span><br><span class="line">	__SetPageUptodate(new_page);</span><br><span class="line">	<span class="comment">// 把子进程的pte指向新建的物理页,建立反向映射关系</span></span><br><span class="line">	page_add_new_anon_rmap(new_page, dst_vma, addr, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">// 设置子进程该页cache失效</span></span><br><span class="line">	lru_cache_add_inactive_or_unevictable(new_page, dst_vma);</span><br><span class="line">	rss[mm_counter(new_page)]++;</span><br><span class="line">	<span class="comment">// 向子进程vma中写入新的页并设置pte脏和可写</span></span><br><span class="line">	pte = mk_pte(new_page, dst_vma-&gt;vm_page_prot);</span><br><span class="line">	pte = maybe_mkwrite(pte_mkdirty(pte), dst_vma);</span><br><span class="line">	set_pte_at(dst_vma-&gt;vm_mm, addr, dst_pte, pte);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>page_add_new_anon_rmap</code>(定义在<code>mm/rmap.c : 1175</code>处)中, 会调用<code>__page_set_anon_rmap</code>(定义在<code>mm/rmap.c : 1039</code>处)设置匿名物理页对应的线性地址索引:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">anon_vma = (<span class="keyword">void</span> *) anon_vma + PAGE_MAPPING_ANON;</span><br><span class="line">WRITE_ONCE(page-&gt;mapping, (struct address_space *) anon_vma);</span><br><span class="line">page-&gt;index = linear_page_index(vma, address);</span><br></pre></td></tr></table></figure>
<p>而<code>linear_page_index</code>(位于<code>include/linux/pagemap.h :551</code>)的代码逻辑则如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pgoff_t</span> <span class="title">linear_page_index</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pgoff_t</span> pgoff;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">		<span class="keyword">return</span> linear_hugepage_index(vma, address);</span><br><span class="line">	pgoff = (address - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	pgoff += vma-&gt;vm_pgoff; <span class="comment">// pgoff是vma开始的线性地址对应的虚拟页框号.</span></span><br><span class="line">	<span class="keyword">return</span> pgoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内存COW缺页异常的触发和处理"><a href="#内存COW缺页异常的触发和处理" class="headerlink" title="内存COW缺页异常的触发和处理"></a>内存COW缺页异常的触发和处理</h3><p>在读取内存页遇到权限错误后COW的处理链路(普通页)主要如下:<br><code>DEFINE_IDTENTRY_RAW_ERRORCODE -&gt; handle_page_fault -&gt; do_user_addr_fault -&gt; handle_mm_fault -&gt; __handle_mm_fault -&gt; handle_pte_fault -&gt; do_wp_page -&gt; wp_page_copy/wp_page_reuse</code></p>
<p>在x86体系下, 当发生访问COW页面时, MMU通过解析线性地址(虚拟地址)获得页表项详细,即会访问W/R为0的页, 查阅Intel的手册第4.7节和6.2节中内容可知: 对W/R为0的页面进行写入操作是, MMU会返回Page Fault的Fault错误, page fault error code是14, 错误Mne-monic为#PF. 其中返回的32位数据中第1位会被置为1,代表导致错误的原因是写入权限问题.</p>
<p>处理这个错误的代码入口定义在<code>arch/x86/entry/entry_64.S</code>中.</p>
<p><em>ps: 此处如何通过entry_64.S找到下一个处理函数的入口尚未看明白</em></p>
<p>之后代码跳转到: <code>arch/x86/mm/fault.c :1469</code>处的<code>DEFINE_IDTENTRY_RAW_ERRORCODE</code>执行:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">instrumentation_begin();</span><br><span class="line">handle_page_fault(regs, error_code, address);</span><br><span class="line">instrumentation_end();</span><br></pre></td></tr></table></figure>
<p>其中的<code>handle_page_fault</code>(定义在<code>arch/x86/mm/fault.c :1445</code>处)负责处理page fault, 内部分为两种处理逻辑, 一种是对内核地址上的页错误进行处理, 一种是对用户空间地址上的页错误进行处理.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">	do_kern_addr_fault(regs, error_code, address);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	do_user_addr_fault(regs, error_code, address);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>do_user_addr_fault</code>(定义在<code>arch/x86/mm/fault.c :1240</code>处)中执行对COW处理逻辑:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_user_addr_fault</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> hw_error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 一些条件检查等</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果MMU的fage fault错误是X86_PF_WRITE, 则设置flags为FAULT_FLAG_WRITE</span></span><br><span class="line">	<span class="comment">// 而X86_PF_WRITE = 1 &lt;&lt; 1, 刚好就是MMU返回的错误信息第1位为1的.</span></span><br><span class="line">	<span class="keyword">if</span> (hw_error_code &amp; X86_PF_WRITE)</span><br><span class="line">		flags |= FAULT_FLAG_WRITE;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 尝试mmap加读锁,失败则进行might_sleep();</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!mmap_read_trylock(mm))) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 执行mm的page fault错误处理逻辑</span></span><br><span class="line">	fault = handle_mm_fault(vma, address, flags, regs);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// mmap解锁</span></span><br><span class="line">	mmap_read_unlock(mm);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>handle_mm_fault</code>定义在<code>mm/memory.c :4592</code>处,其中根据页面是否是大页进行分别处理:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">handle_mm_fault</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 设置当前进程状态为running</span></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line">	<span class="comment">// pagefault计数增加</span></span><br><span class="line">	count_vm_event(PGFAULT);</span><br><span class="line">	count_memcg_event_mm(vma-&gt;vm_mm, PGFAULT);</span><br><span class="line">	<span class="comment">// 一些条件检查</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 处理页错误, 区分hugetlb和普通页分别处理</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = __handle_mm_fault(vma, address, flags);	<span class="comment">// 其他oom检查等逻辑</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理hugetlb的page-fault错误"><a href="#处理hugetlb的page-fault错误" class="headerlink" title="处理hugetlb的page fault错误"></a>处理hugetlb的page fault错误</h4><p><code>hugetlb_fault</code>的逻辑代码定义在<code>mm/hugetlb.c :4507</code>处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">hugetlb_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 确保reservaion被解除</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !huge_pte_write(entry)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vma_needs_reservation(h, vma, haddr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = VM_FAULT_OOM;</span><br><span class="line">			<span class="keyword">goto</span> out_mutex;</span><br><span class="line">		&#125;</span><br><span class="line">		vma_end_reservation(h, vma, haddr);</span><br><span class="line">		<span class="comment">// 如果是私有的页则获得一个pagechage</span></span><br><span class="line">		<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_MAYSHARE))</span><br><span class="line">			pagecache_page = hugetlbfs_pagecache_page(h,</span><br><span class="line">								vma, haddr);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取pte对应的物理页</span></span><br><span class="line">	page = pte_page(entry);</span><br><span class="line">	<span class="keyword">if</span> (page != pagecache_page)</span><br><span class="line">		<span class="keyword">if</span> (!trylock_page(page)) &#123;</span><br><span class="line">			need_wait_lock = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_ptl;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 增加物理页引用计数</span></span><br><span class="line">	get_page(page);</span><br><span class="line">	<span class="comment">// 如果vma可写且pte只读则执行拷贝物理页操作hugetlb_cow</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!huge_pte_write(entry)) &#123;</span><br><span class="line">		<span class="comment">// 拷贝大页数据</span></span><br><span class="line">			ret = hugetlb_cow(mm, vma, address, ptep,</span><br><span class="line">					  pagecache_page, ptl);</span><br><span class="line">			<span class="keyword">goto</span> out_put_page;</span><br><span class="line">		&#125;</span><br><span class="line">		entry = huge_pte_mkdirty(entry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 标记旧物理页最近被访问</span></span><br><span class="line">	entry = pte_mkyoung(entry);</span><br><span class="line">	<span class="comment">// 设置pte的access标记并更新mmt的tlb缓存</span></span><br><span class="line">	<span class="keyword">if</span> (huge_ptep_set_access_flags(vma, haddr, ptep, entry,</span><br><span class="line">						flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">		update_mmu_cache(vma, haddr, ptep);</span><br><span class="line">out_put_page:</span><br><span class="line">	<span class="comment">// 解锁旧页</span></span><br><span class="line">	<span class="keyword">if</span> (page != pagecache_page)</span><br><span class="line">		unlock_page(page);</span><br><span class="line">	<span class="comment">// 减少旧物理页引用计数</span></span><br><span class="line">	put_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>hugetlb_cow</code>代码定义在<code>mm/hugetlb.c :4098</code>处, 其中和cow相关的逻辑为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果该page只有一个人使用了则直接设置该页的pte为可写状态即可</span></span><br><span class="line">	<span class="keyword">if</span> (page_mapcount(old_page) == <span class="number">1</span> &amp;&amp; PageAnon(old_page)) &#123;</span><br><span class="line">		page_move_anon_rmap(old_page, vma);</span><br><span class="line">		set_huge_ptep_writable(vma, haddr, ptep);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 新建一个大页</span></span><br><span class="line">	new_page = alloc_huge_page(vma, haddr, outside_reserve);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 拷贝页的内容</span></span><br><span class="line">	copy_user_huge_page(new_page, old_page, address, vma,</span><br><span class="line">				    pages_per_huge_page(h));</span><br><span class="line">	<span class="comment">// mmu设置通知区域不可用,刷新其他mmu</span></span><br><span class="line">	mmu_notifier_range_init(&amp;range, MMU_NOTIFY_CLEAR, <span class="number">0</span>, vma, mm, haddr,</span><br><span class="line">					haddr + huge_page_size(h));</span><br><span class="line">	mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">spin_lock(ptl);</span><br><span class="line">	ptep = huge_pte_offset(mm, haddr, huge_page_size(h));</span><br><span class="line">	<span class="comment">// 完成cow映射分离</span></span><br><span class="line">	<span class="keyword">if</span> (likely(ptep &amp;&amp; pte_same(huge_ptep_get(ptep), pte))) &#123;</span><br><span class="line">		ClearPagePrivate(new_page);</span><br><span class="line">		huge_ptep_clear_flush(vma, haddr, ptep);</span><br><span class="line">		mmu_notifier_invalidate_range(mm, range.start, range.<span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 更新pte指向的page</span></span><br><span class="line">		set_huge_pte_at(mm, haddr, ptep,</span><br><span class="line">				make_huge_pte(vma, new_page, <span class="number">1</span>));</span><br><span class="line">		<span class="comment">// 移除旧页的反向映射</span></span><br><span class="line">		page_remove_rmap(old_page, <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">// 添加新页的反向映射</span></span><br><span class="line">		hugepage_add_new_anon_rmap(new_page, vma, haddr);</span><br><span class="line">		<span class="comment">// 设置新页可见</span></span><br><span class="line">		set_page_huge_active(new_page);</span><br><span class="line">		<span class="comment">/* Make the old page be freed below */</span></span><br><span class="line">		new_page = old_page;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(ptl);</span><br><span class="line">	<span class="comment">// mmu通知range截止</span></span><br><span class="line">	mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">out_release_all:</span><br><span class="line">	restore_reserve_on_error(h, vma, haddr, new_page);</span><br><span class="line">	<span class="comment">// 减少物理页的引用计数</span></span><br><span class="line">	put_page(new_page);</span><br><span class="line">out_release_old:</span><br><span class="line">	put_page(old_page);</span><br></pre></td></tr></table></figure>


<h4 id="处理普通页的page-fault错误"><a href="#处理普通页的page-fault错误" class="headerlink" title="处理普通页的page fault错误"></a>处理普通页的page fault错误</h4><p><code>__handle_mm_fault</code>的代码定义在<code>mm/memory.c :4436</code>处: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> __handle_mm_fault(struct vm_area_struct *vma,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">// 声明vmf的结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> = &#123;</span></span><br><span class="line">		.vma = vma,</span><br><span class="line">		.address = address &amp; PAGE_MASK,</span><br><span class="line">		.flags = flags,</span><br><span class="line">		.pgoff = linear_page_index(vma, address),</span><br><span class="line">		.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 寻找和分配页表项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	...</span><br><span class="line">	pgd = pgd_offset(mm, address); <span class="comment">//全局页表</span></span><br><span class="line">	p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">	...</span><br><span class="line">	vmf.pud = pud_alloc(mm, p4d, address); <span class="comment">//上层页表</span></span><br><span class="line">	...</span><br><span class="line">	vmf.pmd = pmd_alloc(mm, vmf.pud, address); <span class="comment">//中间层页表</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 进行pte页表的的错误处理,即完成物理页分配和pte页表项填充</span></span><br><span class="line">	<span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>handle_pte_fault</code>方法定义在<code>mm/memory.c :4343</code>处, </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">handle_pte_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	... <span class="comment">// 检查pmd是否none</span></span><br><span class="line">    <span class="comment">// 如果pte是NULL且vma是匿名的,do_anonymous_page(vmf),其中会处理零页的情况, 如果pte不存在且vma不是匿名的, 则说明是第一次访问文件的mmap区域,此时进行处理文件映射相关的处理</span></span><br><span class="line">	<span class="keyword">if</span> (!vmf-&gt;pte) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))</span><br><span class="line">			<span class="keyword">return</span> do_anonymous_page(vmf); <span class="comment">// 处理匿名页</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> do_fault(vmf); <span class="comment">//处理文件映射</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))  <span class="comment">// 处理在swap中的内存</span></span><br><span class="line">		<span class="keyword">return</span> do_swap_page(vmf);</span><br><span class="line">	<span class="keyword">if</span> (pte_protnone(vmf-&gt;orig_pte) &amp;&amp; vma_is_accessible(vmf-&gt;vma))</span><br><span class="line">		<span class="keyword">return</span> do_numa_page(vmf);</span><br><span class="line">	vmf-&gt;ptl = pte_lockptr(vmf-&gt;vma-&gt;vm_mm, vmf-&gt;pmd);</span><br><span class="line">	spin_lock(vmf-&gt;ptl);</span><br><span class="line">	entry = vmf-&gt;orig_pte;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pte_same(*vmf-&gt;pte, entry))) &#123;</span><br><span class="line">		update_mmu_tlb(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果vma是可写的, 且pte的RW是只读属性, 则执行do_wp_page(vmf),之后重置entry的pte D位</span></span><br><span class="line">	<span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">			<span class="keyword">return</span> do_wp_page(vmf);  <span class="comment">// 进入COW缺页异常逻辑</span></span><br><span class="line">		entry = pte_mkdirty(entry);</span><br><span class="line">	&#125;</span><br><span class="line">	entry = pte_mkyoung(entry);</span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte, entry,</span><br><span class="line">				vmf-&gt;flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">		<span class="comment">// 更新mmu的缓存</span></span><br><span class="line">		update_mmu_cache(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Skip spurious TLB flush for retried page fault */</span></span><br><span class="line">		<span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_TRIED)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">		<span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">			flush_tlb_fix_spurious_fault(vmf-&gt;vma, vmf-&gt;address);</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于匿名页的处理会进入<code>do_anonymous_page</code>(在<code>mm/memory.c :3482</code>处)中进行:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 分配pte页表项</span></span><br><span class="line">	<span class="keyword">if</span> (pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd))</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	...  <span class="comment">// 使用零页处理读的情况</span></span><br><span class="line">	<span class="comment">// 分配一个物理页, 其中会通过__alloc_zeroed_user_highpage调用alloc_page_vma, 在其中进一步通过alloc_pages_vma调用__alloc_pages_nodemask, 由伙伴系统分配一个新的全0的物理页</span></span><br><span class="line">	page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address);</span><br><span class="line">	...</span><br><span class="line">	__SetPageUptodate(page);  <span class="comment">// 使新分配的物理页可见</span></span><br><span class="line">	<span class="comment">// 根据vma信息创建一个pte信息,并将物理页的页号信息保存在新建的pte中, 使得pte到物理页的映射生效</span></span><br><span class="line">	entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">	<span class="comment">// 使pte标记为最近被访问</span></span><br><span class="line">	entry = pte_sw_mkyoung(entry);</span><br><span class="line">	<span class="comment">// 如果vma是可写的, 则设置pte为脏且可写</span></span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">		entry = pte_mkwrite(pte_mkdirty(entry));</span><br><span class="line">	<span class="comment">// 锁定待更新vma的pte处</span></span><br><span class="line">	vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,</span><br><span class="line">			&amp;vmf-&gt;ptl);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 替换设置vma的pte为新的pte</span></span><br><span class="line">	set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line">	<span class="comment">// 更新mmt的tlb缓存</span></span><br><span class="line">	update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">	<span class="comment">// 解除锁定</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中<code>mk_pte</code>的对于x86系统的定义位于: <code>arch/x86/include/asm/pgtable.h :845</code>处: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk_pte(page, pgprot)   pfn_pte(page_to_pfn(page), (pgprot))</span></span><br></pre></td></tr></table></figure>
<p>而<code>pfn_pte</code>(位于<code>arch/x86/include/asm/pgtable.h :603</code>)和<code>page_to_pfn</code>(位于<code>include/asm-generic :55</code>)分别是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pte结构是一个长整形数据, 根据x86下pte的定义结构初始化生成</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pte_t</span> <span class="title">pfn_pte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> page_nr, <span class="keyword">pgprot_t</span> pgprot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> pfn = (<span class="keyword">phys_addr_t</span>)page_nr &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	pfn ^= protnone_mask(pgprot_val(pgprot));</span><br><span class="line">	pfn &amp;= PTE_PFN_MASK;</span><br><span class="line">	<span class="keyword">return</span> __pte(pfn | check_pgprot(pgprot));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取物理页号的函数, page存储在伙伴系统的pglist_data -&gt; mem_map中, 这个计算就是直接获得page相对于mem_map的偏移量, 即是index.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(page)	(unsigned long)((page) - vmemmap)</span></span><br></pre></td></tr></table></figure>

<p>对于首次访问文件映射区mmap的处理由<code>do_fault</code>(定义在mm/memory.c :4111)负责:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果vm_ops绑定的fault处理函数不存在情况的特殊处理</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault) &#123;</span><br><span class="line">	...</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(vmf-&gt;flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">	<span class="comment">// 如果写的vma区域不是可写的, 则</span></span><br><span class="line">		ret = do_read_fault(vmf);</span><br><span class="line">	<span class="comment">// 如果vma区域是私有且可写, 则执行do_cow_fault处理COW逻辑</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">		ret = do_cow_fault(vmf);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="comment">//共享的vma则通过do_shared_fault进行处理</span></span><br><span class="line">		ret = do_shared_fault(vmf);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_read_fault</code>, <code>do_cow_fault</code>和<code>do_shared_fault</code>三者都会执行<code>__do_fault</code>这个方法,其中对于COW的处理是, 先分配一个COW页, 再通过调用 <code>__do_fault</code>(内部执行<code>vma-&gt;vm_ops-&gt;fault(vmf)</code>,即执行vm_ops指定的fault函数), 之后拷贝page内容到COW页, 最后通过<code>finish_fault</code>方法设置pte, 并通过<code>put_page</code>减少新旧页各自的引用计数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_cow_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 分配新的COW页</span></span><br><span class="line">	vmf-&gt;cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-&gt;address);</span><br><span class="line">	<span class="comment">// 调用__do_fault</span></span><br><span class="line">	ret = __do_fault(vmf);</span><br><span class="line">	<span class="comment">// 拷贝page页数据</span></span><br><span class="line">	copy_user_highpage(vmf-&gt;cow_page, vmf-&gt;page, vmf-&gt;address, vma);</span><br><span class="line">	<span class="comment">// 刷新页</span></span><br><span class="line">	__SetPageUptodate(vmf-&gt;cow_page);</span><br><span class="line">	<span class="comment">// 调用finish_fault设置pte</span></span><br><span class="line">	ret |= finish_fault(vmf);</span><br><span class="line">	<span class="comment">// 减少旧页的引用计数</span></span><br><span class="line">	put_page(vmf-&gt;page);</span><br><span class="line">	<span class="comment">// 减少新页的引用计数</span></span><br><span class="line">	put_page(vmf-&gt;cow_page);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>finish_fault</code>内部会调用<code>alloc_set_pte</code>, 在<code>alloc_set_pte</code>的内部会执行设置新的pte, 更新pte数据的操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="built_in">write</span> = vmf-&gt;flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 获得一个新的pte结构</span></span><br><span class="line">entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line"><span class="comment">// 设置pte为新</span></span><br><span class="line">entry = pte_sw_mkyoung(entry);</span><br><span class="line"><span class="comment">// 如果vma可写,则设置pte脏和可写,cow页会进行这个操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>)</span><br><span class="line">	entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"><span class="comment">// 如果vma私有可写, 则增加匿名页计数,并添加物理页到vma的匿名映射区</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span> &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)) &#123;</span><br><span class="line">	inc_mm_counter_fast(vma-&gt;vm_mm, MM_ANONPAGES);</span><br><span class="line">	page_add_new_anon_rmap(page, vma, vmf-&gt;address, <span class="literal">false</span>);</span><br><span class="line">	lru_cache_add_inactive_or_unevictable(page, vma);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	inc_mm_counter_fast(vma-&gt;vm_mm, mm_counter_file(page));</span><br><span class="line">	page_add_file_rmap(page, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新pte,建立映射</span></span><br><span class="line">set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line"><span class="comment">// 更新mmt缓存</span></span><br><span class="line">update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br></pre></td></tr></table></figure>


<p>在<code>do_wp_page</code>(代码在<code>mm/memory.c :3085</code>处)中执行cow的处理逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取发生异常的地址所在page结构</span></span><br><span class="line">vmf-&gt;page = vm_normal_page(vma, vmf-&gt;address, vmf-&gt;orig_pte);</span><br><span class="line"><span class="comment">// 如果没有page结构是使用页帧映射的, 且vma是共享可写的, 则通过wp_pfn_shared处理共享可写的映射.</span></span><br><span class="line"><span class="keyword">if</span> (!vmf-&gt;page) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">			     (VM_WRITE|VM_SHARED))</span><br><span class="line">		<span class="keyword">return</span> wp_pfn_shared(vmf);</span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(vmf); <span class="comment">// 处理私有可写的映射</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (PageAnon(vmf-&gt;page)) &#123; <span class="comment">// 针对私有可写的匿名页做特殊处理, 如果父或子进程执行了COW, 此时另一个的pte仍然是只读, 但是这个page的map_count会变为1, 这种情况就需要把另一个进程的pte设置为可写</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">vmf</span>-&gt;<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (PageKsm(page) || page_count(page) != <span class="number">1</span>) <span class="comment">// 如果是KSM的page或者page_count计数不为1则</span></span><br><span class="line">		<span class="keyword">goto</span> copy;</span><br><span class="line">	<span class="keyword">if</span> (!trylock_page(page)) <span class="comment">//尝试锁住page, 锁不住则执行copy</span></span><br><span class="line">		<span class="keyword">goto</span> copy;</span><br><span class="line">	<span class="keyword">if</span> (PageKsm(page) || page_mapcount(page) != <span class="number">1</span> || page_count(page) != <span class="number">1</span>) &#123; </span><br><span class="line">	<span class="comment">// 如果map_count &gt; 1 或page_count&gt;1或是ksm page则不执行. 此处再次判断PageKsm(page)确保一定不是 ksm.</span></span><br><span class="line">		unlock_page(page);</span><br><span class="line">		<span class="keyword">goto</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock_page(page); <span class="comment">//page解锁</span></span><br><span class="line">	wp_page_reuse(vmf); <span class="comment">// 设置pte,在其中完成cow的处理</span></span><br><span class="line">	<span class="keyword">return</span> VM_FAULT_WRITE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">				(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line">	<span class="keyword">return</span> wp_page_shared(vmf); <span class="comment">//处理共享页</span></span><br><span class="line">&#125;</span><br><span class="line">copy:</span><br><span class="line">	get_page(vmf-&gt;page); <span class="comment">// 增加vma的page的引用计数, 避免page在计数为0时被释放</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl); <span class="comment">//释放pte锁</span></span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(vmf); <span class="comment">// 进一步完成处理COW的动作</span></span><br></pre></td></tr></table></figure>

<p>在<code>wp_page_copy</code>(定义在<code>mm/memory.c :2828</code>)中执行拷贝页数据的过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">wp_page_copy</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span> = <span class="title">vmf</span>-&gt;<span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">new_page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	<span class="keyword">int</span> page_copied = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_range</span> <span class="title">range</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(anon_vma_prepare(vma))) <span class="comment">// 关联一个anon_vma实例到vma</span></span><br><span class="line">		<span class="keyword">goto</span> oom;</span><br><span class="line">	<span class="keyword">if</span> (is_zero_pfn(pte_pfn(vmf-&gt;orig_pte))) &#123; <span class="comment">//如果映射的是0页, 则分配用户空间高端的页并用0进行初始化</span></span><br><span class="line">		new_page = alloc_zeroed_user_highpage_movable(vma,</span><br><span class="line">							      vmf-&gt;address);</span><br><span class="line">		<span class="keyword">if</span> (!new_page)</span><br><span class="line">			<span class="keyword">goto</span> oom;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是0页, 则分配高端的页, 并拷贝原来的page中数据到新页</span></span><br><span class="line">		new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,</span><br><span class="line">				vmf-&gt;address);</span><br><span class="line">		<span class="keyword">if</span> (!new_page)</span><br><span class="line">			<span class="keyword">goto</span> oom;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!cow_user_page(new_page, old_page, vmf)) &#123; <span class="comment">//拷贝page中数据</span></span><br><span class="line">		<span class="comment">// 不成功时错误处理</span></span><br><span class="line">			put_page(new_page); <span class="comment">//新页计数引用计数减1, </span></span><br><span class="line">			<span class="keyword">if</span> (old_page)</span><br><span class="line">				put_page(old_page); <span class="comment">//旧页引用计数减1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// cgroup相关设置</span></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_charge(new_page, mm, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">goto</span> oom_free_new;</span><br><span class="line">	cgroup_throttle_swaprate(new_page, GFP_KERNEL);</span><br><span class="line">	__SetPageUptodate(new_page); <span class="comment">// 设置新的页标识为PageUptodate, 表示该页是包含数据的页</span></span><br><span class="line">	mmu_notifier_range_init(&amp;range, MMU_NOTIFY_CLEAR, <span class="number">0</span>, vma, mm,</span><br><span class="line">				vmf-&gt;address &amp; PAGE_MASK,</span><br><span class="line">				(vmf-&gt;address &amp; PAGE_MASK) + PAGE_SIZE); <span class="comment">// 获得vma的线性地址范围</span></span><br><span class="line">	mmu_notifier_invalidate_range_start(&amp;range); <span class="comment">// 设置该范围invalidate</span></span><br><span class="line">	vmf-&gt;pte = pte_offset_map_lock(mm, vmf-&gt;pmd, vmf-&gt;address, &amp;vmf-&gt;ptl); <span class="comment">//锁住页表并获得现在的pte</span></span><br><span class="line">	<span class="keyword">if</span> (likely(pte_same(*vmf-&gt;pte, vmf-&gt;orig_pte))) &#123; <span class="comment">//检查锁住以后获得的pte和发生异常时的pte是否相同内容</span></span><br><span class="line">		<span class="keyword">if</span> (old_page) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!PageAnon(old_page)) &#123; <span class="comment">// old_page存在且不是匿名页</span></span><br><span class="line">				dec_mm_counter_fast(mm,</span><br><span class="line">						mm_counter_file(old_page)); <span class="comment">// 减旧页引用计数??</span></span><br><span class="line">				inc_mm_counter_fast(mm, MM_ANONPAGES); <span class="comment">// 加匿名页计数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// old_page不存在, 则加匿名页计数</span></span><br><span class="line">			inc_mm_counter_fast(mm, MM_ANONPAGES);</span><br><span class="line">		&#125;</span><br><span class="line">		flush_cache_page(vma, vmf-&gt;address, pte_pfn(vmf-&gt;orig_pte)); <span class="comment">//刷新cache中的页</span></span><br><span class="line">		entry = mk_pte(new_page, vma-&gt;vm_page_prot); <span class="comment">//构建新的页表项</span></span><br><span class="line">		entry = pte_sw_mkyoung(entry); <span class="comment">//设置pte被最近访问</span></span><br><span class="line">		entry = maybe_mkwrite(pte_mkdirty(entry), vma); <span class="comment">//设置pte脏且可写</span></span><br><span class="line">		ptep_clear_flush_notify(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">// 将页表原来的值清除, 刷新缺页时地址对应的tlb中pte的记录</span></span><br><span class="line">		page_add_new_anon_rmap(new_page, vma, vmf-&gt;address, <span class="literal">false</span>); <span class="comment">// 添加物理页到vma对应的匿名页反向映射中</span></span><br><span class="line">		lru_cache_add_inactive_or_unevictable(new_page, vma); <span class="comment">//将新的物理页添加到活跃或不可回收的lru链表中</span></span><br><span class="line">		set_pte_at_notify(mm, vmf-&gt;address, vmf-&gt;pte, entry); <span class="comment">//将构建好的entry页表项加入到vm的页表记录中</span></span><br><span class="line">		update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">// 更新mmt的tlb</span></span><br><span class="line">		<span class="keyword">if</span> (old_page) &#123;</span><br><span class="line">			page_remove_rmap(old_page, <span class="literal">false</span>);  <span class="comment">// 如果存在old_page, 从原来的页从虚拟页反向映射中删除, 并将其页的应用计数减1</span></span><br><span class="line">		&#125;</span><br><span class="line">		new_page = old_page;</span><br><span class="line">		page_copied = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		update_mmu_tlb(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">// 不相同时更新mmu的tlb信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (new_page)</span><br><span class="line">		put_page(new_page); <span class="comment">// 新page的引用减1</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	mmu_notifier_invalidate_range_only_end(&amp;range);</span><br><span class="line">	<span class="keyword">if</span> (old_page) &#123; <span class="comment">// 旧页存在的话</span></span><br><span class="line">		 <span class="comment">//如果已经映射了新的page, 但是旧的page对应的vma是Locked状态, 则旧的页被锁住, 这时需要将其解锁</span></span><br><span class="line">		<span class="keyword">if</span> (page_copied &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) &#123;</span><br><span class="line">			lock_page(old_page);	<span class="comment">/* LRU manipulation */</span></span><br><span class="line">			<span class="keyword">if</span> (PageMlocked(old_page))</span><br><span class="line">				munlock_vma_page(old_page); <span class="comment">// 解锁旧的页</span></span><br><span class="line">			unlock_page(old_page);</span><br><span class="line">		&#125;</span><br><span class="line">		put_page(old_page); <span class="comment">//旧页引用减1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page_copied ? VM_FAULT_WRITE : <span class="number">0</span>; <span class="comment">//如果拷贝page成功则返回VM_FAULT_WRITE, 其他返回0, 这个VM_FAULT_WRITE会一直向上传递给do_user_addr_fault</span></span><br><span class="line">oom_free_new:</span><br><span class="line">	put_page(new_page); <span class="comment">// oom时将新页引用减1</span></span><br><span class="line">oom:</span><br><span class="line">	<span class="keyword">if</span> (old_page)</span><br><span class="line">		put_page(old_page); <span class="comment">//oom时将旧页引用减1</span></span><br><span class="line">	<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>wp_page_reuse</code>(定义在<code>mm/memory.c :2789</code>处)中完成了pte的状态重新设置为可写,并更新mmu的tlb等操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wp_page_reuse</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(vmf-&gt;ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">vmf</span>-&gt;<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		page_cpupid_xchg_last(page, (<span class="number">1</span> &lt;&lt; LAST_CPUPID_SHIFT) - <span class="number">1</span>);</span><br><span class="line">	flush_cache_page(vma, vmf-&gt;address, pte_pfn(vmf-&gt;orig_pte)); <span class="comment">//flush cache数据</span></span><br><span class="line">	entry = pte_mkyoung(vmf-&gt;orig_pte); <span class="comment">// 设置pte页的标记为被访问</span></span><br><span class="line">	entry = maybe_mkwrite(pte_mkdirty(entry), vma); <span class="comment">// 设置pte页为脏,如果所在vma是可写的, 则设置pte为可写的.</span></span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vma, vmf-&gt;address, vmf-&gt;pte, entry, <span class="number">1</span>))</span><br><span class="line">		update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">//设置pte可访问, 并更新mmu的tlb缓存数据</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	count_vm_event(PGREUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于共享的页面通过<code>wp_page_shared</code>设置页可写或通过<code>wp_page_reuse</code>完成页的状态变更 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">wp_page_shared</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(vmf-&gt;ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">vm_fault_t</span> ret = VM_FAULT_WRITE;</span><br><span class="line"></span><br><span class="line">	get_page(vmf-&gt;page); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;page_mkwrite) &#123;</span><br><span class="line">		<span class="keyword">vm_fault_t</span> tmp;</span><br><span class="line"></span><br><span class="line">		pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">		tmp = do_page_mkwrite(vmf);  <span class="comment">// 设置page可写</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tmp || (tmp &amp;</span><br><span class="line">				      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) &#123;</span><br><span class="line">			put_page(vmf-&gt;page);</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = finish_mkwrite_fault(vmf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(tmp &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) &#123;</span><br><span class="line">			unlock_page(vmf-&gt;page);</span><br><span class="line">			put_page(vmf-&gt;page);</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wp_page_reuse(vmf);  <span class="comment">// 通过wp_page_reuse 完成页设置</span></span><br><span class="line">		lock_page(vmf-&gt;page);</span><br><span class="line">	&#125;</span><br><span class="line">	ret |= fault_dirty_shared_page(vmf); </span><br><span class="line">	put_page(vmf-&gt;page); </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此COW机制得到完成, page fault返回后,操作系统会重新执行引起page fault的动作. </p>
<p><em>ps: 这里是如何做到重新执行引起page fault的动作的? 书上的找到<code>ret_from_exception</code>和<code>resume_userspace</code>函数x86_64下并未找到. 这里我看在<code>entry_64.S</code>的中断响应程序结尾处, 会执行<code>jne    swapgs_restore_regs_and_return_to_usermode</code>以及<code>SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</code>, 这里会重新回到被中断的进程那里重新执行中断前的逻辑, 查阅文献发现这个功能是由硬件支持的</em></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当进行fork时,父子进程将所有私有可写的物理页进行共享, 并将其对应的页表项设置为只读, 当任意一方尝试写时, 会引起COW的缺页异常, 异常处理程序会为写操作方分配一个新的物理页, 并将原来共享的物理页内容拷贝到新页中, 之后重新建立新页的页表映射到新的物理页, 并设置为可写. 如果在缺页异常处理时发现共享的页只有一个使用者, 则直接设置这个页面为可写即可.</p>
<p>内存管理的实现复杂, 这一块还需要进一步学习, 部分实现原理和机制还需要结合深入理解Linux内核书本上的概念进行理解.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内存管理mmap分配内存默认对齐</title>
    <url>/2021/05/11/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86mmap%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%BB%98%E8%AE%A4%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h1 id="Linux内存管理mmap分配内存默认对齐"><a href="#Linux内存管理mmap分配内存默认对齐" class="headerlink" title="Linux内存管理mmap分配内存默认对齐"></a>Linux内存管理mmap分配内存默认对齐</h1><p>使用<code>mmap</code>建立内存映射:</p>
<p>头文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>定义: </p>
<p><code>void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);</code></p>
<p>prot:</p>
<ul>
<li>PROT_EXEC  映射区域可被执行；</li>
<li>PROT_READ  映射区域可被读取；</li>
<li>PROT_WRITE  映射区域可被写入；</li>
<li>PROT_NONE  映射区域不能存取。</li>
</ul>
<p>flags:</p>
<ul>
<li>MAP_FIXED  如果参数 start 所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。</li>
<li>MAP_SHARED  对应射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</li>
<li>MAP_PRIVATE  对应射区域的写入操作会产生一个映射文件的复制，即私人的”写入时复制” (copy on write)对此区域作的任何修改都不会写回原来的文件内容。</li>
<li>MAP_ANONYMOUS  建立匿名映射，此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li>
<li>MAP_DENYWRITE  只允许对应射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li>
<li>MAP_LOCKED  将映射区域锁定住，这表示该区域不会被置换(swap)。</li>
</ul>
<p><strong>在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</strong></p>
<p>错误代码：</p>
<ul>
<li>EBADF  参数fd 不是有效的文件描述词。</li>
<li>EACCES  存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED 则要有PROT_WRITE 以及该文件要能写入。</li>
<li>EINVAL  参数start、length 或offset 有一个不合法。</li>
<li>EAGAIN  文件被锁住，或是有太多内存被锁住。</li>
<li>ENOMEM  内存不足。</li>
</ul>
<p><strong>不使用MAP_FIXED,即使指定非页对齐的start, 也会分配页对齐的地址. 如果此时使用MAP_FIXED, 则会返回错误.</strong> </p>
<p>举例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = mmap(<span class="number">0x20001000</span>, <span class="number">10240</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//在0x20001000处分配1024*10个B空间</span></span><br><span class="line"><span class="keyword">void</span> *p = mmap(<span class="number">0x20000012</span>, <span class="number">10240</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);  <span class="comment">// 会返回错误</span></span><br></pre></td></tr></table></figure>

<h5 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h5><p><code>0x20000012</code>中每个数字表示4bit, 3个数就是12bit也就是2^12次方,即4k大小. 所以<code>0x20001000</code>不会报错,但是<code>0x20000012</code>会,因为地址不是一个整页的起始地址. 如果移除了<code>MAP_FIXED</code>就不会, 但是实际分配的地址起始会变成<code>0x20000000</code></p>
<p>使用场景是：分配内存、读写大文件、连接动态库文件、多进程间共享内存</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>学习</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中i++与++i到底有啥区别</title>
    <url>/2021/05/11/c%E8%AF%AD%E8%A8%80%E4%B8%ADi++%E4%B8%8E++i%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="c语言中i-与-i到底有啥区别"><a href="#c语言中i-与-i到底有啥区别" class="headerlink" title="c语言中i++与++i到底有啥区别"></a>c语言中i++与++i到底有啥区别</h1><p>结论: <code>i++</code> 比 <code>++i</code> 在需要代表的语义相同情况的场景下性能要差一点</p>
<p>原因: </p>
<p><code>i++</code>翻译成汇编就是先将<code>i</code>的值取出, 返回<code>i</code>的值, 到寄存器,执行<code>i+1</code>的操作, 之后将结果在写回<code>i</code>的地址, </p>
<p><code>++i</code>则是直接将<code>i</code>的地址中数据加1, 之后再返回值, 这时的值是<code>i+1</code></p>
<p>如果<code>i++</code>与<code>++i</code>执行的操作语义对与i来说都可以的话, 即不论是否先执行<code>+1</code>都可以的话, 那么优先使用<code>++i</code></p>
<p>但是在其他语义不同的使用场景则需要区别对待:</p>
<p>比如: </p>
<p><code>*p++</code> 是取p所指向的值, 之后对p指针执行+1操作</p>
<p><code>*++p</code> 则是先执行p指针+1, 再取p+1地址的值</p>
<p><code>(*p)++</code> 则是取p地址指向的值,之后对值执行+1计算</p>
<p>同理对于<code>i--</code>和<code>--i</code>也是适用的.</p>
<p>其实<code>i++</code> 相当于 <code>i=i+1</code> 是一个表达式. 具有左值和右值. </p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Glibc的memset源码分析</title>
    <url>/2021/05/11/Glibc%E7%9A%84memset%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Glibc的memset源码分析"><a href="#Glibc的memset源码分析" class="headerlink" title="Glibc的memset源码分析"></a>Glibc的memset源码分析</h1><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>CPU配置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">model name      : Intel(R) Xeon(R) Gold 6134 CPU @ 3.20GHz</span><br><span class="line"></span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l3 cdp_l3 invpcid_single pti intel_ppin ssbd mba ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm mpx rdt_a avx512f avx512dq rdseed adx smap clflushopt clwb intel_pt avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm arat pln pts hwp hwp_act_window hwp_epp hwp_pkg_req pku ospke md_clear flush_l1d</span><br></pre></td></tr></table></figure>

<p>可以发现其中支持avx的flag: <code>avx2</code>,<code>avx512f</code>… 以及ERMS(<code>erms</code>)的支持.</p>
<p>使用的<code>glibc</code>库是<code>libc-2.27.so</code>.</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>查看<code>glibc-2.27</code>的版本代码,在<code>sysdeps/x86_64/multiarch/</code>目录下, 在文件<code>ifunc-memset.h</code>中定义了是否使用<code>erms</code>和<code>avx512</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (CPU_FEATURES_ARCH_P (cpu_features, Prefer_ERMS))</span><br><span class="line">   <span class="keyword">return</span> OPTIMIZE (erms);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (CPU_FEATURES_ARCH_P (cpu_features, AVX512F_Usable)</span><br><span class="line">     &amp;&amp; !CPU_FEATURES_ARCH_P (cpu_features, Prefer_No_AVX512))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (CPU_FEATURES_ARCH_P (cpu_features, Prefer_No_VZEROUPPER))</span><br><span class="line"><span class="keyword">return</span> OPTIMIZE (avx512_no_vzeroupper);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (CPU_FEATURES_CPU_P (cpu_features, ERMS))</span><br><span class="line"><span class="keyword">return</span> OPTIMIZE (avx512_unaligned_erms);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> OPTIMIZE (avx512_unaligned);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (CPU_FEATURES_ARCH_P (cpu_features, AVX2_Usable))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (CPU_FEATURES_CPU_P (cpu_features, ERMS))</span><br><span class="line"><span class="keyword">return</span> OPTIMIZE (avx2_unaligned_erms);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> OPTIMIZE (avx2_unaligned);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>无论<code>avx2</code>还是<code>avx512</code>都共享使用了<code>sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S</code>中的代码,其中大致逻辑是如果支持erms就使用erms相关代码, 并针对对齐和非对齐的情况进行处理, 只有在<code>erms</code>支持的条件下才会执行到<code>L(stosb)</code>处的代码. 而非<code>erms</code>支持的的则执行<code>L(more_2x_vec):</code>进入循环执行mov操作, <code>VMOVU(A)</code>在<code>avx2</code>和<code>avx512</code>下分别是<code>vmovdqu(a)</code>和<code>vmovdqu(a)64</code></p>
<p><code>VEC_SIZE</code>在<code>avx512</code>下是64,在<code>avx2</code>下是32.</p>
<p>相关代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* memset is implemented as:</span><br><span class="line">   1. Use overlapping store to avoid branch.</span><br><span class="line">   2. If size is less than VEC, use integer register stores.</span><br><span class="line">   3. If size is from VEC_SIZE to 2 * VEC_SIZE, use 2 VEC stores.</span><br><span class="line">   4. If size is from 2 * VEC_SIZE to 4 * VEC_SIZE, use 4 VEC stores.</span><br><span class="line">   5. If size is more to 4 * VEC_SIZE, align to 4 * VEC_SIZE with</span><br><span class="line">      4 VEC stores and store 4 * VEC at a time until done.  *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; stosb的相关代码在这里: </span><br><span class="line">L(stosb):</span><br><span class="line">	&#x2F;* Issue vzeroupper before rep stosb.  *&#x2F;</span><br><span class="line">	VZEROUPPER</span><br><span class="line">	movq	%rdx, %rcx</span><br><span class="line">	movzbl	%sil, %eax</span><br><span class="line">	movq	%rdi, %rdx</span><br><span class="line">	rep stosb</span><br><span class="line">	movq	%rdx, %rax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 触发进入stosb的条件是:rdx值大于REP_STOSB_THRESHOLD, 且满足大于2*VEC_SIZE</span><br><span class="line">ENTRY (MEMSET_SYMBOL (__memset, unaligned_erms))</span><br><span class="line">	MEMSET_VDUP_TO_VEC0_AND_SET_RETURN (%esi, %rdi)</span><br><span class="line">	cmpq	$VEC_SIZE, %rdx</span><br><span class="line">	jb	L(less_vec)</span><br><span class="line">	cmpq	$(VEC_SIZE * 2), %rdx</span><br><span class="line">	ja	L(stosb_more_2x_vec)</span><br><span class="line">	&#x2F;* From VEC and to 2 * VEC.  No branch when size &#x3D;&#x3D; VEC_SIZE.  *&#x2F;</span><br><span class="line">	VMOVU	%VEC(0), -VEC_SIZE(%rdi,%rdx)</span><br><span class="line">	VMOVU	%VEC(0), (%rdi)</span><br><span class="line">	VZEROUPPER</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">L(stosb_more_2x_vec):</span><br><span class="line">	cmpq	$REP_STOSB_THRESHOLD, %rdx</span><br><span class="line">	ja	L(stosb)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#x2F;* Threshold to use Enhanced REP STOSB.  Since there is overhead to set</span><br><span class="line">   up REP STOSB operation, REP STOSB isn&#39;t faster on short data.  The</span><br><span class="line">   memset micro benchmark in glibc shows that 2KB is the approximate</span><br><span class="line">   value above which REP STOSB becomes faster on processors with</span><br><span class="line">   Enhanced REP STOSB.  Since the stored value is fixed, larger register</span><br><span class="line">   size has minimal impact on threshold.  *&#x2F;</span><br><span class="line">#ifndef REP_STOSB_THRESHOLD</span><br><span class="line"># define REP_STOSB_THRESHOLD		2048</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L(more_2x_vec):</span><br><span class="line">	cmpq  $(VEC_SIZE * 4), %rdx</span><br><span class="line">	ja	L(loop_start)</span><br><span class="line">	VMOVU	%VEC(0), (%rdi)</span><br><span class="line">	VMOVU	%VEC(0), VEC_SIZE(%rdi)</span><br><span class="line">	VMOVU	%VEC(0), -VEC_SIZE(%rdi,%rdx)</span><br><span class="line">	VMOVU	%VEC(0), -(VEC_SIZE * 2)(%rdi,%rdx)</span><br><span class="line">L(return):</span><br><span class="line">	VZEROUPPER</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">L(loop_start):</span><br><span class="line">	leaq	(VEC_SIZE * 4)(%rdi), %rcx</span><br><span class="line">	VMOVU	%VEC(0), (%rdi)</span><br><span class="line">	andq	$-(VEC_SIZE * 4), %rcx</span><br><span class="line">	VMOVU	%VEC(0), -VEC_SIZE(%rdi,%rdx)</span><br><span class="line">	VMOVU	%VEC(0), VEC_SIZE(%rdi)</span><br><span class="line">	VMOVU	%VEC(0), -(VEC_SIZE * 2)(%rdi,%rdx)</span><br><span class="line">	VMOVU	%VEC(0), (VEC_SIZE * 2)(%rdi)</span><br><span class="line">	VMOVU	%VEC(0), -(VEC_SIZE * 3)(%rdi,%rdx)</span><br><span class="line">	VMOVU	%VEC(0), (VEC_SIZE * 3)(%rdi)</span><br><span class="line">	VMOVU	%VEC(0), -(VEC_SIZE * 4)(%rdi,%rdx)</span><br><span class="line">	addq	%rdi, %rdx</span><br><span class="line">	andq	$-(VEC_SIZE * 4), %rdx</span><br><span class="line">	cmpq	%rdx, %rcx</span><br><span class="line">	je	L(return)</span><br><span class="line">L(loop):</span><br><span class="line">	VMOVA	%VEC(0), (%rcx)</span><br><span class="line">	VMOVA	%VEC(0), VEC_SIZE(%rcx)</span><br><span class="line">	VMOVA	%VEC(0), (VEC_SIZE * 2)(%rcx)</span><br><span class="line">	VMOVA	%VEC(0), (VEC_SIZE * 3)(%rcx)</span><br><span class="line">	addq	$(VEC_SIZE * 4), %rcx</span><br><span class="line">	cmpq	%rcx, %rdx</span><br><span class="line">	jne	L(loop)</span><br><span class="line">	VZEROUPPER_SHORT_RETURN</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h3 id="glibc代码逻辑验证"><a href="#glibc代码逻辑验证" class="headerlink" title="glibc代码逻辑验证"></a>glibc代码逻辑验证</h3><p>测试验证以上逻辑:</p>
<p>当<code>rdx&gt;2048</code>时:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">5000</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="string">'a'</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>perf top</code>查看是<code>L(stosb)</code>处的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    │    000000000018ef20 &lt;__nss_group_lookup@GLIBC_2.2.5+0x251e0&gt;:</span><br><span class="line"> 0.91 │      vzeroupper</span><br><span class="line">      │      mov    %rdx,%rcx</span><br><span class="line">      │      movzbl %sil,%eax</span><br><span class="line">      │      mov    %rdi,%rdx</span><br><span class="line">98.32 │      rep    stos %al,%es:(%rdi)</span><br><span class="line"> 0.76 │      mov    %rdx,%rax</span><br><span class="line">      │    ← retq</span><br></pre></td></tr></table></figure>
<p>当<code>rdx&lt;=2048</code>时:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">5000</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="string">'a'</span>, <span class="number">2048</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>perf top</code>查看是<code>L(loop)</code>处的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__memset_avx2_unaligned_erms  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">Percent│       vmovdqu %ymm0,(%rdi)</span><br><span class="line">       │       and    $0xffffffffffffff80,%rcx</span><br><span class="line">  6.41 │       vmovdqu %ymm0,-0x20(%rdi,%rdx,1)</span><br><span class="line">       │       vmovdqu %ymm0,0x20(%rdi)</span><br><span class="line">       │       vmovdqu %ymm0,-0x40(%rdi,%rdx,1)</span><br><span class="line">       │       vmovdqu %ymm0,0x40(%rdi)</span><br><span class="line">  3.71 │       vmovdqu %ymm0,-0x60(%rdi,%rdx,1)</span><br><span class="line">       │       vmovdqu %ymm0,0x60(%rdi)</span><br><span class="line">       │       vmovdqu %ymm0,-0x80(%rdi,%rdx,1)</span><br><span class="line">       │       add    %rdi,%rdx</span><br><span class="line">  3.61 │       and    $0xffffffffffffff80,%rdx</span><br><span class="line">       │       cmp    %rdx,%rcx</span><br><span class="line">       │     ↑ je     51</span><br><span class="line"> 14.78 │ 97:   vmovdqa %ymm0,(%rcx)</span><br><span class="line"> 37.20 │       vmovdqa %ymm0,0x20(%rcx)</span><br><span class="line"> 13.57 │       vmovdqa %ymm0,0x40(%rcx)</span><br><span class="line"> 13.06 │       vmovdqa %ymm0,0x60(%rcx)</span><br><span class="line">  3.45 │       add    $0x80,%rcx</span><br><span class="line">       │       cmp    %rcx,%rdx</span><br><span class="line">       │     ↑ jne    97</span><br><span class="line">  0.94 │       vzeroupper</span><br><span class="line">       │     ← retq</span><br><span class="line">       │ ba:   cmp    $0x10,%dl</span><br><span class="line">       │     ↓ jae    db</span><br><span class="line">       │       vmovq  %xmm0,%rcx</span><br><span class="line">       │       cmp    $0x8,%dl</span><br><span class="line">       │     ↓ jae    e9</span><br></pre></td></tr></table></figure>

<p>当<code>rdx&lt;128</code>时:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">5000</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="string">'a'</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>perf top</code>查看是<code>L(more_2x_vec)</code>处的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__memset_avx2_unaligned_erms  &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.27.so</span><br><span class="line">Percent│     ↓ jb     ba</span><br><span class="line">       │       cmp    $0x40,%rdx</span><br><span class="line">       │     ↓ ja     2a</span><br><span class="line">       │       vmovdqu %ymm0,-0x20(%rdi,%rdx,1)</span><br><span class="line">       │       vmovdqu %ymm0,(%rdi)</span><br><span class="line">       │       vzeroupper</span><br><span class="line">       │     ← retq</span><br><span class="line">       │ 2a:   cmp    $0x800,%rdx</span><br><span class="line">       │     → ja     18ef20 &lt;__nss_group_lookup@GLIBC_2.2.5+0x251e0&gt;</span><br><span class="line">       │       cmp    $0x80,%rdx</span><br><span class="line">       │     ↓ ja     55</span><br><span class="line"> 24.76 │       vmovdqu %ymm0,(%rdi)</span><br><span class="line">  0.01 │       vmovdqu %ymm0,0x20(%rdi)</span><br><span class="line">       │       vmovdqu %ymm0,-0x20(%rdi,%rdx,1)</span><br><span class="line"> 61.51 │       vmovdqu %ymm0,-0x40(%rdi,%rdx,1)</span><br><span class="line">       │ 51:   vzeroupper</span><br><span class="line">       │     ← retq</span><br></pre></td></tr></table></figure>

<p>由于<code>cpu</code>均支持<code>erms</code>, 所以进入的逻辑是<code>erms</code>相关代码.</p>
<h4 id="avx指令可能导致cpu降频的问题"><a href="#avx指令可能导致cpu降频的问题" class="headerlink" title="avx指令可能导致cpu降频的问题"></a>avx指令可能导致cpu降频的问题</h4><p>根据<a href="https://bugs.launchpad.net/linux/+bug/1727136" target="_blank" rel="noopener">https://bugs.launchpad.net/linux/+bug/1727136</a> 和 <a href="https://bugs.launchpad.net/linux/+bug/1727136" target="_blank" rel="noopener">https://bugs.launchpad.net/linux/+bug/1727136</a> 中的描述, <code>glibc</code>不使用<code>avx</code>相关代码实现<code>memcpy/memset</code>是为了避免可能导致cpu降频,并引起性能力下降.</p>
<p>通过检测代码:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo perf stat -e cpu/event=0x28,umask=0x18,name=core_power_lvl1_turbo_license/,cpu/event=0x28,umask=0x20,name=core_power_lvl2_turbo_license/,cpu/event=0x28,umask=0x40,name=core_power_throttle/,cycles -a -I 1000 sleep 10</span><br></pre></td></tr></table></figure>


<h3 id="性能验证测试"><a href="#性能验证测试" class="headerlink" title="性能验证测试"></a>性能验证测试</h3><p>参考: <a href="https://stackoverflow.com/questions/33480999/how-can-the-rep-stosb-instruction-execute-faster-than-the-equivalent-loop" target="_blank" rel="noopener">https://stackoverflow.com/questions/33480999/how-can-the-rep-stosb-instruction-execute-faster-than-the-equivalent-loop</a> 和 <a href="https://stackoverflow.com/questions/43343231/enhanced-rep-movsb-for-memcpy" target="_blank" rel="noopener">https://stackoverflow.com/questions/43343231/enhanced-rep-movsb-for-memcpy</a><br>中给出的测试, <code>REP STOSB</code>对于大块的数据是最优的选择. </p>
<p>在支持<code>ERMS</code>的<code>CPU</code>上,会对<code>REP STOSB</code>指令进行优化,使得其执行效率优于循环执行<code>mov</code>的逻辑.而在不支持<code>ERMS</code>的<code>CPU</code>上则只能选择循环<code>mov</code>的操作了. 这里如果<code>CPU</code>支持<code>AVX</code>, 则<code>mov</code>会变为<code>vmovdqa/vmovdqa64</code>等<code>AVX</code>的<code>mov</code>指令.</p>
<p>以下进一步在当前CPU上进行代码对比测试:</p>
<p>测试代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">5000</span>];</span><br><span class="line">   <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;<span class="built_in">max</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="string">'a'</span>, <span class="number">3000</span>);</span><br><span class="line">        i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用一个第三方的优化过的<code>libc</code>库, 其中使用了<code>avx512</code>实现了<code>memset</code></p>
<p>下载地址: <a href="https://www.agner.org/optimize/asmlib.zip" target="_blank" rel="noopener">https://www.agner.org/optimize/asmlib.zip</a></p>
<p>参考连接: <a href="https://www.agner.org/optimize/#asmlib" target="_blank" rel="noopener">https://www.agner.org/optimize/#asmlib</a></p>
<p>分别进行编译后运行<code>perf</code>测试性能: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">new_acu:pilot@quanta2:~/wuding$ gcc 1.c -o asmlib ./libaelf64o.a</span><br><span class="line">new_acu:pilot@quanta2:~/wuding$ gcc 1.c -o origin</span><br><span class="line"></span><br><span class="line">new_acu:pilot@quanta2:~/wuding$ perf stat ./asmlib</span><br><span class="line"></span><br><span class="line"> Performance counter stats for './asmlib':</span><br><span class="line"></span><br><span class="line">      33809.757694      task-clock (msec)         #    1.000 CPUs utilized</span><br><span class="line">                11      context-switches          #    0.000 K/sec</span><br><span class="line">                 0      cpu-migrations            #    0.000 K/sec</span><br><span class="line">                50      page-faults               #    0.001 K/sec</span><br><span class="line">   108,191,627,848      cycles                    #    3.200 GHz</span><br><span class="line">   181,495,657,395      instructions              #    1.68  insn per cycle</span><br><span class="line">    56,914,104,466      branches                  # 1683.363 M/sec</span><br><span class="line">           153,916      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">      33.810266264 seconds time elapsed</span><br><span class="line"></span><br><span class="line">      33.809945000 seconds user</span><br><span class="line">       0.000000000 seconds sys</span><br><span class="line"></span><br><span class="line">new_acu:pilot@quanta2:~/wuding$ perf stat ./origin</span><br><span class="line"></span><br><span class="line"> Performance counter stats for './origin':</span><br><span class="line"></span><br><span class="line">      34796.854964      task-clock (msec)         #    1.000 CPUs utilized</span><br><span class="line">                15      context-switches          #    0.000 K/sec</span><br><span class="line">                 1      cpu-migrations            #    0.000 K/sec</span><br><span class="line">                50      page-faults               #    0.001 K/sec</span><br><span class="line">   111,350,368,185      cycles                    #    3.200 GHz</span><br><span class="line">    29,025,326,422      instructions              #    0.26  insn per cycle</span><br><span class="line">     7,522,153,422      branches                  #  216.173 M/sec</span><br><span class="line">           168,441      branch-misses             #    0.00% of all branches</span><br><span class="line"></span><br><span class="line">      34.805927226 seconds time elapsed</span><br><span class="line"></span><br><span class="line">      34.797053000 seconds user</span><br><span class="line">       0.000000000 seconds sys</span><br></pre></td></tr></table></figure>


<p>对比可以发现运行性能仅提升约2%.</p>
<p>查看使用<code>asmlib</code>运行时的<code>perf top</code>可见热点代码, 可验证的确使用的是<code>avx512</code>相关指令: <code>vmovdqu64</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      │</span><br><span class="line">      │    00000000000008ee &lt;L050&gt;:</span><br><span class="line">      │    L050():</span><br><span class="line">95.91 │      vmovdqu64 %zmm16,(%rdi)</span><br><span class="line"> 0.01 │      add    $0x40,%rdi</span><br><span class="line">      │      and    $0xffffffffffffffc0,%rdi</span><br><span class="line">      │      lea    (%rcx,%rdx,1),%rax</span><br><span class="line"> 4.08 │      and    $0xffffffffffffffc0,%rax</span><br><span class="line">      │      sub    %rax,%rdi</span><br><span class="line">      │      cmp    MemsetCacheLimit,%rdx</span><br><span class="line">      │    → ja     L200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      │   Disassembly of section .text:</span><br><span class="line">      │</span><br><span class="line">      │   0000000000000910 &lt;L100&gt;:</span><br><span class="line">      │   L100():</span><br><span class="line">55.17 │0:   vmovdqa64 %zmm16,(%rax,%rdi,1)</span><br><span class="line">      │     add    $0x40,%rdi</span><br><span class="line">44.83 │   ↑ jne    0</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>综合分析来看, <code>glibc</code>的<code>memset</code>已经进行了优化. <code>rep stos</code>指令的性能并不差. </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>近期的学习感悟</title>
    <url>/2021/12/05/%E8%BF%91%E6%9C%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<h2 id="近期的学习感悟"><a href="#近期的学习感悟" class="headerlink" title="近期的学习感悟"></a>近期的学习感悟</h2><p>很久没有写blog了. 最近听讲了一期Go夜读的分享会, 演讲者推荐了微习惯的养成分享. 其中的核心观念就是尽量将看似很难坚持下去或者很难一下子达到的目标分成多个微小的组成, 每天完成一小点, 既有成就感, 又能逐渐实现目标. 比如运动这件事上, 要求自己每天都跑步1小时实际上对大多数人来说都很难, 尤其是我们这些打工人. 那么就干脆定一个小目标先, 如要求自己先从每天跑100米开始, 等到一段时间自己已经习惯了以后, 再增加点目标值如每天跑150m或200m, 如此循序渐进, 很可能过一段时间自己就能够接受每天跑1小时的运动. 如果自己发现增加目标后不能适应, 也可以保持原来的目标水平, 持续下去, 最终可能一年下来的累积值也很高, 自己也不会整体感到自己缺乏锻炼. 所以保持微习惯即容易实现又容易得到精神满足, 是一个值得借鉴的成长方法. 正是因此, 我才发现, 还是需要适当的写写blog的, 每次不必需要写很多内容, 或写的多深入, 保持下这个微习惯即可.</p>
<p>近期还有一个学习感悟就是如何去高效地学习. 以前很多时候我学习都会找时间拿一本书来从头开始看, 一点点理解, 一点点啃. 不仅进度缓慢, 而且时常看了但是有没有完全看懂, 再加之长时间不去复习, 等于看了个寂寞..现在想想这种学习方法不仅低效还很容易效果回退. 近来发现一种更加值得采用和推荐的学习方式是启发式学习: 带着问题去找答案, 对于自己想学习的知识先提出一些自己想搞懂的问题, 带着这些问题去看书或者查阅其他资料, 等自己觉得可以回答这些问题的时候再找个人或者自己对自己讲解一遍, 如果能把这些问题讲清楚了, 那就是真的懂了. 如果不行或者发现有些内容还不够认识清晰, 那么就再回去看, 如果同时发现些新的问题, 那就也一并再去看. 如此往复下去, 知道能逻辑自洽, 合理地解答这些问题为止. 当然如果能把一些非常专业的问题向完全不懂的人讲明白, 讲的通俗易懂, 那么就可以出师了, 哈哈. 如果自己很难对想学习的知识提出问题, 那么也可以利用搜索引擎, 通过关键词去看看别人是写过哪些相关的问题, 以及有哪些相关的知识, 对这些知识提出问题就是一个很简单的入门问题.</p>
<p>在学习的过程中, 我自己还有一个感悟, 就像GOLANG的哲学一样: 大道至简. 如果你能把一个看似复杂的问题简化成易于理解的模型, 或者将复杂的概念讲的通俗易懂, 那么对这个问题你绝对是个专家. 那么如何才能将问题讲的比较容易理解呢? 我发现有一种方法会很好用: 举个栗子. 不论你回答别人的问题还是自己提出问题, 都可以通过举例的方式让别人快速理解你的用意. 而举例子也是有学问的, 既要和你要别的意思接近, 又要在对方的可理解范围之内. 比如向儿子解释为啥1+1=2的时候, 就会举例说你有一个橘子, 爸爸又给你拿了一个橘子.. 所以最容易和别人沟通的一种方式就是尽量的去举例子, 通过例子说明问题, 快速达成理解共识, 再基于理解的共识更深入地说明细枝末节, 这种方式也是高效沟通的途径.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三点感悟:</p>
<ol>
<li>从保持微习惯开始,从小目标开始逐渐完成目标更加容易.</li>
<li>带着问题去学习,通过解释问题来确认自己的学习效果.</li>
<li>大道至简, 尽量通过举例子的方式去说明问题去高效沟通.</li>
</ol>
]]></content>
      <categories>
        <category>学习感悟</category>
      </categories>
      <tags>
        <tag>学习感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>BPF之巅的学习--追踪系统历史与相关技术</title>
    <url>/2021/12/05/BPF%E4%B9%8B%E5%B7%85%E7%9A%84%E5%AD%A6%E4%B9%A0--%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%8E%86%E5%8F%B2%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="BPF之巅的学习–追踪系统历史与相关技术"><a href="#BPF之巅的学习–追踪系统历史与相关技术" class="headerlink" title="BPF之巅的学习–追踪系统历史与相关技术"></a>BPF之巅的学习–追踪系统历史与相关技术</h2><h2 id="早期与发展"><a href="#早期与发展" class="headerlink" title="早期与发展"></a>早期与发展</h2><p>最初的BPF是被开发来在BSD系统上使用的. 通过将BPF虚拟机的指令集定义的过滤器表达式传递给内核的解释器执行从而避免网络数据包从内核态到用户态的复制.  tcpdump就是这一技术的用户态程序. 扩展版的eBPF是在其基础上发展的, 提供了更多的寄存器和映射型存储. 现在大部分人说的BPF就是指eBPF.</p>
<h2 id="相比perf以及内核模块"><a href="#相比perf以及内核模块" class="headerlink" title="相比perf以及内核模块"></a>相比perf以及内核模块</h2><p>相比perf在内核态就可以做过滤等统计操作, 减少了内核态向用户态的拷贝数据量.<br>相比内核模块要安全,且开发成本低, 不依赖特定的内核编译过程. 但是相比少了些任意使用内核内部函数的灵活性.</p>
<h2 id="BPF的前端程序"><a href="#BPF的前端程序" class="headerlink" title="BPF的前端程序"></a>BPF的前端程序</h2><p>低级语言到高级语言: LLVM-&gt;BCC-&gt;bpftrace</p>
<p>BCC与bpftrace在内部都使用LLVM中间表示形式和LLVM库来实现BPF的编译.</p>
<p>Linux源码中有BPF指令的文档. 也可参考LLVM IR文档和Cilium BPF与XDP文档</p>
<p>Linux4.15后可以通过bpftool来查看和操作BPF对象.<br>Linux4.17以后BCC和bpftrace都会使用<code>perf_event_open()</code>进行BPF程序的挂载.</p>
<h2 id="BPF的API"><a href="#BPF的API" class="headerlink" title="BPF的API"></a>BPF的API</h2><p><code>bpf_probe_read()</code> 用于访问BPF之外的内存空间, 这个函数会进行安全检查并且禁止缺页中断的发生以保证probe上文中不会引发内核错误. x86上内核空间和用户空间没有重叠, 故通过地址读取不会存在问题. 而在SPARC上, 则必须通过<code>bpf_probe_read_kernel()</code>和<code>bpf_probe_read_user()</code>来区别使用.</p>
<h2 id="BPF并发控制"><a href="#BPF并发控制" class="headerlink" title="BPF并发控制"></a>BPF并发控制</h2><p>Linux5.1中增加了spin lock(<code>bpf_spin_lock(), bpf_spin_unlock()</code>)来确保并发一致性. 而之前的版本则需要通过per-CPU的映射表来绕过并发问题. 其并发读写映射表的问题被成为”丢失的更新”问题.</p>
<p><code>BPF_XADD</code>(互斥加操作), 映射中的映射机制等都可保证原子操作.<br><code>bpf_map_update_elem()</code>对常规的hash和LRU map的操作也是原子的.</p>
<h2 id="BTF和BPF-CO-RE"><a href="#BTF和BPF-CO-RE" class="headerlink" title="BTF和BPF CO-RE"></a>BTF和BPF CO-RE</h2><p>BPF Type Format, 元数据格式, 可以内嵌到vmlinux的二进制中, 使得可以方便获得被跟踪的源代码信息.<br>BPF CO-RE是一次编译到处运行的意思, 旨在将BPF一次性编译位字节码分发执行, 避免在嵌入式环境需要安装LLVM和Clang的问题.</p>
<h2 id="BPF限制"><a href="#BPF限制" class="headerlink" title="BPF限制"></a>BPF限制</h2><p>内核中无限循环是不允许的. 解决办法包括循环展开, 增加特定辅助函数等. Linux5.3支持受限的循环.<br>BPF栈大小不能超过MAX_BPF_STACK限制, 值位512.<br>BPF指令的总数据量早期为4096, 5.2以后限制为100万.</p>
<h2 id="调用栈回溯"><a href="#调用栈回溯" class="headerlink" title="调用栈回溯"></a>调用栈回溯</h2><ol>
<li>基于帧指针的回溯, 惯例: 调用返回地址永远位于RBP执行+偏移8的位置. gcc默认不启用, 需要通过<code>-fno-omit-frame-pointer</code>开启. 默认不启用的原因: i386中引入的, 为了将rbp寄存器释放出来使用以提升性能.编译器gcc vs icc性能比拼. 以及可以通过debug info来获得栈回溯等. x86_64体系结构上寄存器有16个了, 所以提升性能的收益并不明显了.</li>
<li>调试信息debug info. DWARF格式的ELF调试信息, 通过<code>.eh_frame</code>和<code>.debug_frame</code>的ELF文件段提供. 缺点是文件过大, BPF也不支持(处理器消耗很大且可能需要读取没有加载到内存中的ELF信息, 使得在禁用中断的BPF上下文中实现不可能) BPF的前端BCC和bpftrace则支持使用调试信息.</li>
<li>最后分支记录LBR. Intel处理器的特性, 支持有限深度的回溯4-32个, 通过硬件缓冲区记录, 没有额外开销. BPF不支持.</li>
<li>ORC调试格式信息, Oops回滚能力. 相比DWARF对处理器要求低, 使用<code>.orc_unwind</code>和<code>.orc_unwind_ip</code>的ELF段. Linux内核已经支持. 可通过perf_callchain_kernel()获取.用户态还未支持.</li>
</ol>
<p>调用栈信息在内核中是以地址数值的形式记录的, 这些地址需要在用户态通过翻译成为对应的符号.</p>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>查看调用栈以及热点代码最方便. 其他变体: 冰柱图(Y轴反转), 火焰时序图, 差分火焰图(diff图, 对比两个跟踪结果)</p>
<h2 id="kprobes"><a href="#kprobes" class="headerlink" title="kprobes"></a>kprobes</h2><p>插桩过程: </p>
<ol>
<li>将插入的目标地址的字节内容复制并保存</li>
<li>以单步中断覆盖目标地址(x86_64是int3,如果优化则是jmp), </li>
<li>执行到断点后跳转到处理函数执行, </li>
<li>原始指令会接着执行. </li>
<li>当不再需要时复制回原始的字节内容.<br>如果kprobe是一个Ftrace的已经插桩的地址, 则将kprobe注册为对应Ftrace处理器, 通过入口函数(x86上是gcc4.6是<strong>fentry</strong>)调用Ftrace跳到处理函数. 不再使用则会移移除Ftrace的注册.<br>如果是kretprobe, 则会对函数入口进行kprobe插桩,  通过kprobe将函数的返回地址保存后替换为一个trampoline函数, 当函数执行ret时会跳到对应的函数处理, 完成后再跳回来到之前的保存的地址. 不再使用则同样移除入口的kprobe.</li>
</ol>
<p>kprobe的处理过程可能需要禁止抢占或禁止中断.. 内核设计以些不允许kprobes的函数黑名单, 包括kprobes自己, 可以防止递归.</p>
<p>kprobes使用jmp指令时, 会先调用<code>stop_machine()</code>函数来保证修改代码时其他CPU核心不会执行指令.</p>
<p>最大的开销时对频繁调用的函数执行插桩是每次函数调用的小开销会叠加最终产生性能影响.</p>
<p>kprobes在某些ARM64上不能正常工作, 因为其内核代码不允许修改.</p>
<p>3种接口可访问kprobes:</p>
<ol>
<li>API, register_kprobes()等</li>
<li>基于Ftrace的, 通过<code>/sys/kernel/debug/tracing/kprobe_events</code>写入字符串可起停kprobes</li>
<li>通过perf_event_open(), 与perf工具一样</li>
</ol>
<h2 id="uprobes"><a href="#uprobes" class="headerlink" title="uprobes"></a>uprobes</h2><p>uprobes是基于文件的, 当一个可执行文件中的函数被跟踪时, 所有用到该文件的进程都会被插桩, 包括未启动的进程. 工作原理与kprobes类似.</p>
<p>接口:</p>
<ol>
<li>基于Ftrace的. 通过<code>/sys/kernel/debug/tracing/uprobe_events</code>写入字符串可起停uprobes</li>
<li>通过perf_event_open(), 与perf工具一样, 4.17以上版本支持.<br>内核中也有register_uprobe_events(), 但是不以API形式暴露.</li>
</ol>
<p>在频繁调用的函数上开销会很大, 如malloc/free. </p>
<h2 id="tracepoints"><a href="#tracepoints" class="headerlink" title="tracepoints"></a>tracepoints</h2><p>内核的静态跟踪点 大约100+, 禁用开销为NOP开销, 且很稳定.</p>
<p>跟踪点格式: “子系统:事件名”, 如sched:context_switch. </p>
<p>原理:</p>
<ol>
<li>内核编译阶段插入5字节的nop指令(确保可以被替换为5字节的jmp)</li>
<li>函数尾部会插入一个跟踪点处理函数, 也叫蹦床函数. 其会遍历存储跟踪点探针回调函数的数组.</li>
<li>执行时, 当跟踪点被启用, 会在回调函数数组中插入一条新的跟踪回调函数, 以RCU形式同步更新.如果之前处于tracepoints处于禁用状态, nop指令会被重写为到蹦床函数的跳转指令.</li>
<li>禁用时会以RCU形式删掉回调函数数组, 如果时最后一个则会写回nop. </li>
</ol>
<p>回调函数数组中可以依次插入多个回调函数, 这样可以支持多个回调函数在同一个追踪点上进行追踪处理, 其会被依次执行.</p>
<p>BCC中可以通过<code>BPF.tracepoint_exists</code>来测试是否存在某个追踪点.</p>
<p>原始跟踪点: BPF_RAW_TRACEPOINT, 向跟踪点暴露原始参数, 避免创建跟踪点参数的开销. 其性能要好于kprobes</p>
<h2 id="USDT"><a href="#USDT" class="headerlink" title="USDT"></a>USDT</h2><p>许多应用使用<code>--enable-dtrace-probe</code>或<code>--with-dtrace</code>来开启. 通过systemtap-sdt-dev包提供头文件.或使用Facebook的Folly C++库.</p>
<p>可通过readelf -n 来查看二进制的USDT探针以及获得二进制的偏移量. 通过段位置的起始地址+偏移量找到位置.</p>
<p>编译时使用nop, 激活后被修改为int3. 触发后内核会执行中断响应触发BPF程序.</p>
<h2 id="PMC"><a href="#PMC" class="headerlink" title="PMC"></a>PMC</h2><p>性能监控计数器(又称性能观测计数器PIC, CPU性能计数器CPC, 性能监控单元事件PMU events), 都指处理器上的硬件可编程计数器.</p>
<p>任一时刻CPU中只允许固定数量的寄存器&lt;6个读取 PMC. 可通过循环采用的方式读取.</p>
<p>PMC支持模式:</p>
<ol>
<li>计数</li>
<li>溢出采样, 发生一定次数后通知内核</li>
</ol>
<h2 id="PEBC"><a href="#PEBC" class="headerlink" title="PEBC"></a>PEBC</h2><p>由于存在中断延时或乱序执行, 溢出采样不能精确记录数据. Intel的精确事件采样方案(PEBC)就是使用硬件缓冲区来记录PMC事件发生的正确指令指针, perf支持PEBC.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核中时间片驱动的调度是怎么完成的</title>
    <url>/2021/12/05/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E6%97%B6%E9%97%B4%E7%89%87%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%8C%E6%88%90%E7%9A%84?/</url>
    <content><![CDATA[<h2 id="Linux内核中时间片驱动的调度是怎么完成的"><a href="#Linux内核中时间片驱动的调度是怎么完成的" class="headerlink" title="Linux内核中时间片驱动的调度是怎么完成的?"></a>Linux内核中时间片驱动的调度是怎么完成的?</h2><p>由于近来工作中涉及到调度, 就偶然想出来一个问题: Linux中内核调度CFS是获得task调度的时机的? 是定时更新下每个task的时间片以计算是否需调度? 还是通过让task决定自己主动让出CPU?</p>
<p>Linux中并不区分进程和线程, 而是统一都是Task, 使用<code>struct task_struct</code>来定义. 这是一个庞大的数据结构. 创建线程和进程时, 根据不同的flag来设置子线/进程与父进/线程是否共享某些数据结构还是通过COW机制来创建新的字段.</p>
<p>在<code>task_struct</code>中定义了虚拟时间片的概念, 当task的时间片用完以后, 会被调度出CPU, 这个过程是在哪里发生的呢? </p>
<p>首先进程执行的时间片用完这一信息是通过高精度时钟来触发发出的, 计时到期后修改task的时间片信息, 如果发现时间片用完, 则设置<code>TIF_NEED_RESCHED</code>标志提示可以该task可以被抢占了.  之后某个时刻内核的scheduler相关逻辑被执行时会去检查这个Flag, 并执行schedule(). 被抢占的task可能处于用户态或者内核态(如果允许被抢占).</p>
<p>高精度时钟计时是通过硬件来达到的, 很早期的设计是一个层级时间轮设计, 现在改用了红黑树的设计, 使用事件驱动模式. 这种方式避免了依赖系统硬件的tick来推动时间论运作, 从而提高了精度并模块耦合.</p>
<p>参考:</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/399441638" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/399441638</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/377065400" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/377065400</a></li>
<li><a href="https://blog.csdn.net/baidu_24256693/article/details/79922620" target="_blank" rel="noopener">https://blog.csdn.net/baidu_24256693/article/details/79922620</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>伪共享.md</title>
    <url>/2021/12/14/%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享?"></a>什么是伪共享?</h3><p>CPU硬件访问内存通过Cache作为缓冲中介来加速访问, 而Cache与内存的一致性保证以Cache Line为最小单元进行操作, Cache又分级为1,2,3级缓冲, L1,L2是CPU独立的, L3是CPU共享的. Cache Line一般一行缓冲64B. 因此在并行执行场景下, 如果多个CPU同时访问Cache Line大小对应的内存数据区域, 即使它们访问的数据是不同的, 但是由于所访问的Cache Line是同一个, 也会导致数据脏, 从而使得Cache Line失效,  进而引起Cache Line的写回同步, 这种就是伪共享. (原本可能只需访问L1就可以的, 由于Cache Line失效, 数据需要同步会L3, 或重新从L3或内存中读取, 从而减慢了代码的执行速率). </p>
<p>换种说法是:<br>对缓存行中的单个变量进行修改了，导致整个缓存行数据也就失效了，并且，会导致其他CPU的含有被改动的共享变量的缓存行也失效了，就是所谓的伪共享问题。</p>
<p>引用Intel的说明:</p>
<blockquote>
<p>为了保证多cache下数据一致性，Intel处理器（是多处理器架构）服从MESI（Modified/Exclusive/Shared/Invalid）协议【对cache line的状态标记，更多关于MESI的信息可以阅读参考链接2】。当cache line第一次加载进来之后，处理器将cache line标记为 Exclusive【Exclusive表示这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。】，只要这个cache line被标记为 Exclusive，后续的加载（subsequent loads【应该指读内存指令】）能够免费地（【无内存开销】）使用这个cache line中的数据。如果这个处理器在总线上看到这个cache line被其他处理器加载，这个处理器会将这个cache line标记为Shared【Shared表示这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中】。如果这个处理器写（store【应该是指CPU写】）了一个标记为’S’【 Shared的缩写】的cache line，这个cache line被标记为 Modified【Modified表示这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中】，同时，这个处理器向所有其他处理器发送’Invalid’ cache line消息【因为该写操作导致其他CPU的cache中该数据失效】。如果处理器看到被标记为M的cache line被其他处理器访问，则这个处理器将该cache line写回主存，并将cache line标记为Shared【此时，所有其他CPU的后续访问该数据时，读到的是新的数据】，其他处理器访问这个cache line时，将会导致一个cache miss【它们要么是从未被加载到cache过，要么是从Shared状态变成了Invalid状态】。<br>当cache line被标记为Invalid时，处理器之间频繁地协调【应指通过MESI协议维护cache一致性】，导致cache line数据被写回内存并随后又加载到cache中。伪共享加剧了协调过程【应指伪共享情况下，协调发生得更频繁了】，并显著降低了应用程序性能。</p>
</blockquote>
<h3 id="避免伪共享的办法"><a href="#避免伪共享的办法" class="headerlink" title="避免伪共享的办法"></a>避免伪共享的办法</h3><ol>
<li>使用线程局部数据拷贝, 编译器或手动将可能发生伪共享的连续存储改为线程/进程的本地数据, 线程局部数据拷贝能够被频繁读取和修改，并且只需将结果完全拷贝回去一次即可.</li>
<li>通过人为添加padding填充来以空间换时间, 使得可能同时被访问的数据不再同一个Cache Line中, 一般保证&gt;64B.<br>使用编译指示，来强制使每一个变量对齐。下面的代码显式了编译器使用__declspec( align(n) ) 此处n=64，按照cache line边界对齐。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__declspec (align(64)) int thread1_global_variable;</span><br><span class="line">__declspec (align(64)) int thread2_global_variable;</span><br></pre></td></tr></table></figure>
或者自己在数据结构的尾部填入padding, 或自己强制数组对齐到64B的倍数.</li>
</ol>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>一般为了避免伪共享带来的维护成本高收益低, 可忽略不处理, 只有在性能要求高的场景才需要考虑避免, 以空间的损失换来时间的降低.</p>
<p>参考:</p>
<ol>
<li><a href="https://www.cnblogs.com/apprentice89/p/3347720.html" target="_blank" rel="noopener">https://www.cnblogs.com/apprentice89/p/3347720.html</a></li>
<li><a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyfonly/p/5800758.html</a></li>
<li><a href="https://www.cnblogs.com/crazymakercircle/p/13909102.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazymakercircle/p/13909102.html</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
