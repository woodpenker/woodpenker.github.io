<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"woodpenker.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="当进行fork时,父子进程将所有私有可写的物理页进行共享, 并将其对应的页表项设置为只读, 当任意一方尝试写时, 会引起COW的缺页异常, 异常处理程序会为写操作方分配一个新的物理页, 并将原来共享的物理页内容拷贝到新页中, 之后重新建立新页的页表映射到新的物理页, 并设置为可写. 如果在缺页异常处理时发现共享的页只有一个使用者, 则直接设置这个页面为可写即可.">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 5.11.4内核COW机制源码分析">
<meta property="og:url" content="https://woodpenker.github.io/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="woodpenker&#39;s blog">
<meta property="og:description" content="当进行fork时,父子进程将所有私有可写的物理页进行共享, 并将其对应的页表项设置为只读, 当任意一方尝试写时, 会引起COW的缺页异常, 异常处理程序会为写操作方分配一个新的物理页, 并将原来共享的物理页内容拷贝到新页中, 之后重新建立新页的页表映射到新的物理页, 并设置为可写. 如果在缺页异常处理时发现共享的页只有一个使用者, 则直接设置这个页面为可写即可.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-03T03:25:15.000Z">
<meta property="article:modified_time" content="2021-04-03T03:51:58.796Z">
<meta property="article:author" content="woodpenker">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://woodpenker.github.io/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux 5.11.4内核COW机制源码分析 | woodpenker's blog</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-156045206-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">woodpenker's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">while(life!=0){study++;}</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/woodpenker" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://woodpenker.github.io/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="woodpenker">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="woodpenker's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 5.11.4内核COW机制源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-03 11:25:15 / Modified: 11:51:58" itemprop="dateCreated datePublished" datetime="2021-04-03T11:25:15+08:00">2021-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="Linux 5.11.4内核COW机制源码分析" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/03/COW%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>35 mins.</span>
            </span>
            <div class="post-description">当进行fork时,父子进程将所有私有可写的物理页进行共享, 并将其对应的页表项设置为只读, 当任意一方尝试写时, 会引起COW的缺页异常, 异常处理程序会为写操作方分配一个新的物理页, 并将原来共享的物理页内容拷贝到新页中, 之后重新建立新页的页表映射到新的物理页, 并设置为可写. 如果在缺页异常处理时发现共享的页只有一个使用者, 则直接设置这个页面为可写即可.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="COW写时复制的实现分析"><a href="#COW写时复制的实现分析" class="headerlink" title="COW写时复制的实现分析"></a>COW写时复制的实现分析</h2><h2 id="宏观理解COW"><a href="#宏观理解COW" class="headerlink" title="宏观理解COW"></a>宏观理解COW</h2><p>原因: </p>
<ol>
<li>大部分进程在执行fork后,都会执行与父进程不同的逻辑,通过exec覆盖整个子进程的逻辑地址空间,那样在fork时做一次复制父进程的数据的操作就是一种浪费, 而如果父子进程fork后不执行exec,则父子进程逻辑相同, 只要没有人写数据, 内存也是共享的, 完全没有必要复制. </li>
<li>另外如果一个在一个进程逻辑空间中分配堆空间并进行全0初始化,则没必要每次都进行内存初始化.还有在使用共享的lib时也可以这样节省内存</li>
</ol>
<p>实现方法:<br>1.系统在fork调用时不进行逻辑地址空间中的数据复制, 直接通过mmu把父进程的逻辑地址所对应的物理地址设置为只读,并记录一个引用数. 当父或子进程有一个想写入数据时,如果页面的引用数大于1,会通过MMU读取只读内存区域,从而引发内存页异常中断,在中断处理程序中检测引发异常的原因,发现是cow引起的,则内核开辟一块物理空间,把异常页数据复制进去,然后改变触发异常的逻辑页的实际物理指向,此时父子进程对应的这个逻辑页就不相关了.<br>2.先通过MMU让这些逻辑地址都指向一个只读地址,然后在写访问这个地址时同样产生页异常中断,此时才实际分配物理内存空间.</p>
<p>可能带来的负面问题:<br>如果fork后不执行exec且父子进程都是对进程空间进行大量地写, 那么就会不断地产生大量页面异常中断, 反而可能会出现性能下降.</p>
<h2 id="涉及到的一些基本概念和数据结构"><a href="#涉及到的一些基本概念和数据结构" class="headerlink" title="涉及到的一些基本概念和数据结构"></a>涉及到的一些基本概念和数据结构</h2><p>进程结构体: <code>task_struct</code> ,其中包含有该进程的内存结构体 <code>mm_struct</code>(定义在<code>include/linux/mm_types.h :386</code>).<br>在<code>mm_struct</code>中有以下字段和COW相关:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pgd_t</span> * pgd; <span class="comment">// pgd的指针</span></span><br><span class="line"><span class="keyword">atomic_t</span> mm_users;  <span class="comment">// 使用的用户数量</span></span><br><span class="line"><span class="keyword">atomic_t</span> mm_count;  <span class="comment">//被引用的次数, 包括匿名用户引用</span></span><br><span class="line"><span class="keyword">int</span> map_count; <span class="comment">// vma的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">// vma的双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>  <span class="comment">// vma的红黑树root节点, 便于加快查找vma</span></span><br></pre></td></tr></table></figure>

<hr>
<p>而<code>vma_struct</code>的结构(定义在<code>include/linux/mm_types.h :303</code>)中包含了<code>vma(virtual memory area)</code>的起止地址,前/后一个vma的指针和所属mm_struct指针等信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start; <span class="comment">//起始地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;  <span class="comment">//终止地址的下一个位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>  <span class="comment">// 前后vma指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>  <span class="comment">// 所属的mm指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags; <span class="comment">// 访问权限</span></span><br></pre></td></tr></table></figure>

<p>vma对应着程序的heap, stack, bss, data, text等区域, 没有映射文件的vma是匿名的(stack, heap等).</p>
<hr>
<p>pte(page table entry)是虚拟地址页表项, 对应一个物理页, 其定义是一个32/64位的UL数.<br>其中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|  物理地址的起始位置    | avail | G | PAT |D |A| PCD | PWT | U&#x2F;S | R&#x2F;W| P |</span><br></pre></td></tr></table></figure>

<p>其中P(0)表示是否有物理页, 0表示缺页(被换出或未分配)<br>R/W(1)表示页是否可读写, 0 表示只读<br>U/S(2)表示页的访问权限, 0 表示只内核可以访问<br>D(6)表示页是否脏页, 1为脏页<br>A(5)表示是否被访问过, 1为被访问</p>
<p>x86的PAGE_SHIFT为 12, 定义在<code>arch/x86/include/asm/page_types.h</code></p>
<hr>
<p>linux目前采用统一的4级页表管理法, 把虚拟地址划分成如下一些部分做页面查找:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 未使用(16bit) | PGD(9bit) | PUD(9bit) | PMD(9bit) | PTE(9bit) | OFFSET (PAGE_SHIFT&#x3D;12bit) |</span><br></pre></td></tr></table></figure>

<p>其中高位128T给内核, 地位128T给用户空间, 中间空间的目前是保留.</p>
<p>每个物理页和虚拟页都默认4KB对齐的数据空间.</p>
<p>在x86系统下, 寄存器 CR2 存放缺页异常是的vma, CR3放当前进程的页目录的物理地址基址, 用于做页面查找</p>
<p>进程的获取虚拟页面对应的物理页的方式是通过MMU硬件自动完成的, MMU内部有一个TLB的页表缓存区域, 用于加快页表索引时速度, 减少多次读取内存的开销. MMU通过CPU给出的虚拟地址, 取第48-39位,得到PGD的偏移量, 加上PGD对应的物理位置获得PUD的物理位置,取出数据加上38-30位得到PMD的物理位置,取出再加上29-21位得到PTE的物理位置, 取出后加上OFFSET偏移得到实际的物理内存地址.</p>
<p>内核页表放在<code>swapper_pg_dir</code>中, 进程内的内核页表是其内核页表的拷贝, 这样可以减少在进程陷入系统调用时, TLB. CR3的数据切换刷新.</p>
<hr>
<p>内存交换所换出的内存页分为两种, 文件映射页（file-backed page）和匿名页（anonymous page), 文件映射页直接通过文件进行读写, 而匿名页则需要通过硬盘中单独的交换分区进行读写. 匿名页包括各种堆,栈,bss,pipe,数据段,tmpfs等的页, 用户态一般通过malloc,mmap,brk/sbrk申请.</p>
<p>linux中通过LRU算法执行对页面的swap回收操作, x86页表中的accessed位标记了页面是否最近被访问, 当页面被MMU访问到时会自动设置, 之后需要通过函数调用来清除标记位.</p>
<hr>
<p>物理内存页用<code>struct page</code>(定义在<code>include/linux/mm_types.h :69</code>)表示. 其中<code>atomic_t _mapcount;</code>表示物理页的被使用计数,  如果为0, 则该物理页不再被任何人使用.</p>
<hr>
<p>hugetlb是内存大页的tlb页表, 指向大页, 而huge page的大小和pmd所管理的物理页总大小是一致的. 默认是2^9 * 4k = 2M.在TLB中通过hugetlb指向huge page, 而被分配的大页作为hugetlbfs被提供给进程使用,类似tmpfs.</p>
<hr>
<p>rmap是用于通过匿名页方向查找到使用该物理页的pte的数据结构,该反向映射用于在回收物理内存时断开使用该物理页的所有进程等场景.</p>
<h2 id="分析对象"><a href="#分析对象" class="headerlink" title="分析对象"></a>分析对象</h2><p>linux内核: linux-5.11.4</p>
<p>体系结构: x86_64</p>
<h2 id="fork系统调用中的COW"><a href="#fork系统调用中的COW" class="headerlink" title="fork系统调用中的COW"></a>fork系统调用中的COW</h2><p>主要的作用链路是: <code>kernel_clone -&gt; copy_process -&gt; copy_mm -&gt; dup_mm -&gt; dup_mmap -&gt;copy_page_range -&gt; copy_p4d_range -&gt; copy_pud_range -&gt; copy_pmd_range -&gt; copy_pte_range -&gt; copy_present_pte/copy_nopresent_pte</code></p>
<p>fork通过系统中断触发, x86_64的系统中断入口定义在<code>arch/x86/entry/entry_64.S :95</code>处. 其中会执行<code>call do_syscall_64</code>进入中断响应程序选择逻辑,<code>do_syscall_64</code>定义在<code>arch/x86/entry/common.c :39</code>处, 其中会查询中断描述符表, 这个表在<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中定义了64位系统下fork系统调用的中断号: <code>57    common    fork            sys_fork</code>. 之后会执行到<code>kernel_clone</code>(定义在<code>kernel/fork.c :2412</code>)进行fork的主要处理逻辑. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="function">__visible noinstr <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nr, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">	instrumentation_begin();</span><br><span class="line">	<span class="keyword">if</span> (likely(nr &lt; NR_syscalls)) &#123;</span><br><span class="line">		nr = array_index_nospec(nr, NR_syscalls);</span><br><span class="line">		regs-&gt;ax = sys_call_table[nr](regs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_X32_ABI</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (likely((nr &amp; __X32_SYSCALL_BIT) &amp;&amp;</span><br><span class="line">			  (nr &amp; ~__X32_SYSCALL_BIT) &lt; X32_NR_syscalls)) &#123;</span><br><span class="line">		nr = array_index_nospec(nr &amp; ~__X32_SYSCALL_BIT,</span><br><span class="line">					X32_NR_syscalls);</span><br><span class="line">		regs-&gt;ax = x32_sys_call_table[nr](regs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	instrumentation_end();</span><br><span class="line">	syscall_exit_to_user_mode(regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> instrumentation_begin() (&#123;					\</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"%c0: nop\n\t"</span>						\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".pushsection .discard.instr_begin\n\t"</span>		\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".long %c0b - .\n\t"</span>				\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".popsection\n\t"</span> : : <span class="string">"i"</span> (__COUNTER__))</span></span>;		\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> instrumentation_end() (&#123;					\</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"%c0: nop\n\t"</span>					\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".pushsection .discard.instr_end\n\t"</span>		\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".long %c0b - .\n\t"</span>				\</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="string">".popsection\n\t"</span> : : <span class="string">"i"</span> (__COUNTER__))</span></span>;		\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em>ps: 这里书上说通过cs和eip寄存器给出了 IDT表中第i项门描述符的段选择符和偏移量字段, 通过其可以跳转到被选中的中断处理程序的第一条指令这个执行过程是由硬件自动完成的</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">kernel_clone</span><span class="params">(struct kernel_clone_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 数据初始化和flags判断</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在copy_process中进行进程拷贝逻辑</span></span><br><span class="line">	p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取pid</span></span><br><span class="line">	...</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// 唤醒新的进程</span></span><br><span class="line">	wake_up_new_task(p);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ptrace相关</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// namespace中加入新的pid</span></span><br><span class="line">	put_pid(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_process</code>(定义在<code>kernel/fork.c :1844</code>)中执行进程拷贝的逻辑:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __latent_entropy struct task_struct *<span class="title">copy_process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">					struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> trace,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span> node,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct kernel_clone_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先进行flags检查,namespace检查, signal的暂存</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 复制进程结构体, audit,perf,cgroup信息等复制和设置</span></span><br><span class="line">	dup_task_struct </span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 执行进程的各种资源拷贝</span></span><br><span class="line">	shm_init_task(p);</span><br><span class="line">	retval = security_task_alloc(p, clone_flags);</span><br><span class="line">	retval = copy_semundo(clone_flags, p);</span><br><span class="line">	retval = copy_files(clone_flags, p);</span><br><span class="line">	retval = copy_fs(clone_flags, p);</span><br><span class="line">	retval = copy_sighand(clone_flags, p);</span><br><span class="line">	retval = copy_signal(clone_flags, p);</span><br><span class="line">	<span class="comment">// 拷贝内存资源</span></span><br><span class="line">	retval = copy_mm(clone_flags, p);</span><br><span class="line">	retval = copy_namespaces(clone_flags, p);</span><br><span class="line">	retval = copy_io(clone_flags, p);</span><br><span class="line">	retval = copy_thread(clone_flags, args-&gt;<span class="built_in">stack</span>, args-&gt;stack_size, p, args-&gt;tls);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 分配pid等其他收尾工作</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存的拷贝"><a href="#内存的拷贝" class="headerlink" title="内存的拷贝"></a>内存的拷贝</h3><p>在<code>copy_mm</code>(定义在<code>kernel/fork.c :1382</code>) 中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_mm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;  <span class="comment">// 如果是内核进程, 这个字段会一直为NULL</span></span><br><span class="line">	tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果是CLONE_VM, 则直接跳到good_mm, 将mm和active_mm都设置为当前进程的mm</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123; </span><br><span class="line">		mmget(oldmm); <span class="comment">//原子增加oldmm中mm_users计数,即oldmm的使用者数量</span></span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 不是CLONE_VM的都执行拷贝mm的操作, COW主要看这里的实现</span></span><br><span class="line">	mm = dup_mm(tsk, current-&gt;mm);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">	tsk-&gt;mm = mm;</span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里用到的<code>mmget</code>是一个专门用于增加mm的使用计数的方法, 其定义(在<code>include/linux/sched/mm.h :68</code>)如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mmget</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atomic_inc(&amp;mm-&gt;mm_users); <span class="comment">//原子增加计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而与<code>mmget</code>对应的减少计数并在计数为0时释放资源的方法<code>mmput</code>定义(在<code>kernel/fork.c :1074-1104</code>)如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __mmput(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">	VM_BUG_ON(atomic_read(&amp;mm-&gt;mm_users));</span><br><span class="line"></span><br><span class="line">	uprobe_clear_state(mm);</span><br><span class="line">	exit_aio(mm);</span><br><span class="line">	ksm_exit(mm);</span><br><span class="line">	khugepaged_exit(mm); <span class="comment">/* must run before exit_mmap */</span></span><br><span class="line">	exit_mmap(mm);</span><br><span class="line">	mm_put_huge_zero_page(mm);</span><br><span class="line">	set_mm_exe_file(mm, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;mm-&gt;mmlist)) &#123;</span><br><span class="line">		spin_lock(&amp;mmlist_lock);</span><br><span class="line">		list_del(&amp;mm-&gt;mmlist);</span><br><span class="line">		spin_unlock(&amp;mmlist_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mm-&gt;binfmt)</span><br><span class="line">		module_put(mm-&gt;binfmt-&gt;<span class="keyword">module</span>);</span><br><span class="line">	mmdrop(mm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decrement the use count and release all resources for an mm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmput</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	might_sleep();  </span><br><span class="line">	<span class="comment">// 原子减计数并看是否为0</span></span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;mm-&gt;mm_users))</span><br><span class="line">		__mmput(mm); <span class="comment">//具体的释放mm的动作</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(mmput);</span><br></pre></td></tr></table></figure>
<p><em>ps: 这里might_sleep(); 是什么原因还没搞明白</em></p>
<p>非CLONE_VM的继续执行<code>dup_mm</code>(在<code>kernel/fork.c :1345</code>)拷贝<code>mm_struct</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mm_struct *<span class="title">dup_mm</span><span class="params">(struct task_struct *tsk,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct mm_struct *oldmm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 创建一个mm</span></span><br><span class="line">	mm = allocate_mm();</span><br><span class="line">	<span class="comment">// 拷贝就的mm的数据</span></span><br><span class="line">	<span class="built_in">memcpy</span>(mm, oldmm, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line">	<span class="comment">// 初始化新的mm</span></span><br><span class="line">	<span class="keyword">if</span> (!mm_init(mm, tsk, mm-&gt;user_ns))</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">	<span class="comment">// 拷贝vma双向链表数据, 内部针对COW做了处理</span></span><br><span class="line">	err = dup_mmap(mm, oldmm);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 返回mm</span></span><br><span class="line">	<span class="keyword">return</span> mm;</span><br><span class="line">	<span class="comment">// 其他执行错误情况处理</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>mm_init</code>(在<code>kernel/fork.c  :1004</code>处)中做了与COW相关的一些设置: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mm-&gt;mmap = <span class="literal">NULL</span>; <span class="comment">//设置mmp为空</span></span><br><span class="line"><span class="comment">//设置红黑树为根为空的哨兵节点: </span></span><br><span class="line"><span class="comment">// 其定义为: </span></span><br><span class="line"><span class="comment">// #define RB_ROOT	(struct rb_root) &#123; NULL, &#125; </span></span><br><span class="line"><span class="comment">// 在include/linux/rbtree.h :37处</span></span><br><span class="line">mm-&gt;mm_rb = RB_ROOT; </span><br><span class="line"><span class="comment">// 初始化mm_users和mm_count为1</span></span><br><span class="line">atomic_set(&amp;mm-&gt;mm_users, <span class="number">1</span>);  </span><br><span class="line">atomic_set(&amp;mm-&gt;mm_count, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置map_count计数为0</span></span><br><span class="line">mm-&gt;map_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>主要的拷贝mmap的逻辑由<code>dup_mmap</code>(在<code>kernel/fork.c  :470-644</code>处)完成, 这里分两种情况处理: </p>
<ol>
<li>配置了MMU: <code>#ifdef CONFIG_MMU</code></li>
<li>没有配置CONFIG_MMU, 这里只执行: <code>RCU_INIT_POINTER(mm-&gt;exe_file, get_mm_exe_file(oldmm));</code>的逻辑, 对exe_file部分做RCU初始化,使exe_file指向父进程的exe_file,使得两者一致,即任意读都可以,并在写的时候复制副本完成修改写入,之后再一次性替换原来的数据. </li>
</ol>
<p>针对配置了MMU的场景: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __latent_entropy <span class="keyword">int</span> <span class="title">dup_mmap</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct mm_struct *oldmm)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uprobe_start_dup_mmap(); <span class="comment">// 执行: percpu_down_read(&amp;dup_mmap_sem) , 锁定读锁</span></span><br><span class="line">	...</span><br><span class="line">	flush_cache_dup_mm(oldmm); <span class="comment">// 刷cache到内存, 确保脏页落到内存中.</span></span><br><span class="line">	...</span><br><span class="line">	RCU_INIT_POINTER(mm-&gt;exe_file, get_mm_exe_file(oldmm));</span><br><span class="line">	<span class="comment">// 拷贝vm配置</span></span><br><span class="line">	mm-&gt;total_vm = oldmm-&gt;total_vm;</span><br><span class="line">	mm-&gt;data_vm = oldmm-&gt;data_vm;</span><br><span class="line">	mm-&gt;exec_vm = oldmm-&gt;exec_vm;</span><br><span class="line">	mm-&gt;stack_vm = oldmm-&gt;stack_vm;</span><br><span class="line">	...</span><br><span class="line">	pprev = &amp;mm-&gt;mmap;</span><br><span class="line">	retval = ksm_fork(mm, oldmm); <span class="comment">// ksm合并内核的相同页面</span></span><br><span class="line">	...</span><br><span class="line">	prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 循环遍历拷贝mmap中的每个vma执行拷贝逻辑</span></span><br><span class="line">	<span class="keyword">for</span> (mpnt = oldmm-&gt;mmap; mpnt; mpnt = mpnt-&gt;vm_next) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果flag是VM_DONTCOPY则跳过</span></span><br><span class="line">		<span class="keyword">if</span> (mpnt-&gt;vm_flags &amp; VM_DONTCOPY) &#123;</span><br><span class="line">			vm_stat_account(mm, mpnt-&gt;vm_flags, -vma_pages(mpnt));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果有收到kill信号就退出执行</span></span><br><span class="line">		<span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">			retval = -EINTR;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 拷贝vma的结构</span></span><br><span class="line">		tmp = vm_area_dup(mpnt);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果flag是VM_WIPEONFORK,则把匿名vma设置为空</span></span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;vm_flags &amp; VM_WIPEONFORK) &#123;</span><br><span class="line">			tmp-&gt;anon_vma = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">// 拷贝匿名区</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (anon_vma_fork(tmp, mpnt))</span><br><span class="line">			<span class="keyword">goto</span> fail_nomem_anon_vma_fork;</span><br><span class="line">		<span class="comment">// vm_file部分拷贝等处理</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果是hugetlb的页,且私有的,则直接设置计数为0</span></span><br><span class="line">		<span class="keyword">if</span> (is_vm_hugetlb_page(tmp))</span><br><span class="line">			reset_vma_resv_huge_pages(tmp);</span><br><span class="line">		*pprev = tmp;</span><br><span class="line">		pprev = &amp;tmp-&gt;vm_next;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 拷贝vma中的所有页</span></span><br><span class="line">		mm-&gt;map_count++;</span><br><span class="line">		<span class="comment">// 不是VM_WIPEONFORK的, 则执行拷贝逻辑</span></span><br><span class="line">		<span class="keyword">if</span> (!(tmp-&gt;vm_flags &amp; VM_WIPEONFORK))</span><br><span class="line">			retval = copy_page_range(tmp, mpnt);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	retval = arch_dup_mmap(oldmm, mm); <span class="comment">//体系结构相关的拷贝处理</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>ps: 这里pprev 看代码似乎没有被用到, 不知道其有什么用意, 还是这里就是冗余代码</em></p>
<p>在<code>copy_page_range</code>(定义在<code>mm/memory.c  :1126</code>处)中执行4级页表的拷贝, 这里会有两种情况的拷贝, hugetlb情况和正常情况两种处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_page_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = src_vma-&gt;vm_start; <span class="comment">// vma的起始地址,会被内部函数一直传递下去</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 判断不需要进行拷贝的情况</span></span><br><span class="line">	<span class="keyword">if</span> (!(src_vma-&gt;vm_flags &amp; (VM_HUGETLB | VM_PFNMAP | VM_MIXEDMAP)) &amp;&amp;</span><br><span class="line">	    !src_vma-&gt;anon_vma)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果是vma是hugetlb_page,则单独进行copy_hugetlb_page_range处理并直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (is_vm_hugetlb_page(src_vma))</span><br><span class="line">		<span class="keyword">return</span> copy_hugetlb_page_range(dst_mm, src_mm, src_vma);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(src_vma-&gt;vm_flags &amp; VM_PFNMAP)) &#123;</span><br><span class="line">		<span class="comment">// 不常见的场景处理: 当vma包含VM_PFNMAP的flag时进行copy处理,</span></span><br><span class="line">		<span class="comment">// track_pfn_copy只有在x86下有定义在arch/x86/mm/pat/memtype.c中的处理逻辑, 其他都是arch都是直接返回0. </span></span><br><span class="line">		<span class="comment">// x86下, 在track_pfn_copy中如果检测到vma包含VM_PAT的flag,则执行reserve_pfn_range操作. </span></span><br><span class="line">		<span class="comment">// reserve_pfn_range定义在arch/x86/mm/pat/memtype.c :906行处</span></span><br><span class="line">		ret = track_pfn_copy(src_vma);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断是否cow类型的vma</span></span><br><span class="line">	is_cow = is_cow_mapping(src_vma-&gt;vm_flags); <span class="comment">// is_cow_mapping定义在mm/internal.h :299行中, </span></span><br><span class="line">	<span class="comment">// 当是cow时, 先进行mmu的相关设置</span></span><br><span class="line">	<span class="keyword">if</span> (is_cow) &#123;</span><br><span class="line">	      <span class="comment">// 获取父进程vma对应的内存range</span></span><br><span class="line">		mmu_notifier_range_init(&amp;range, MMU_NOTIFY_PROTECTION_PAGE,</span><br><span class="line">					<span class="number">0</span>, src_vma, src_mm, addr, <span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 设置该range 起始位置之后的mmu映射无效, 即通知其他MMU做清理</span></span><br><span class="line">		mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">		<span class="comment">// 确保父进程vma被锁定</span></span><br><span class="line">		mmap_assert_write_locked(src_mm);</span><br><span class="line">		raw_write_seqcount_begin(&amp;src_mm-&gt;write_protect_seq);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历执行pgd级别的相关页表项拷贝</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	dst_pgd = pgd_offset(dst_mm, addr);</span><br><span class="line">	src_pgd = pgd_offset(src_mm, addr);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		next = pgd_addr_end(addr, <span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 如果pgd不正常则继续下一个循环</span></span><br><span class="line">		<span class="keyword">if</span> (pgd_none_or_clear_bad(src_pgd))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 此处调用copy_p4d_range执行下一级的页表项拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(copy_p4d_range(dst_vma, src_vma, dst_pgd, src_pgd,</span><br><span class="line">					    addr, next))) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pgd++, src_pgd++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="comment">// 拷贝结束后针对cow的页执行收尾</span></span><br><span class="line">	<span class="keyword">if</span> (is_cow) &#123;</span><br><span class="line">		raw_write_seqcount_end(&amp;src_mm-&gt;write_protect_seq);</span><br><span class="line">		<span class="comment">// 通知其他MMU清理映射关系的结束位置</span></span><br><span class="line">		mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索相关文献后得知:<code>mmu_notifier_invalidate_range_start</code> 和<code>mmu_notifier_invalidate_range_end</code>都是在2008年2.6.27的合并窗口里面加入的, 用于通知其他MMU移除这些范围内的内存页的映射,避免MMU的缓存错误</p>
<p>其中关于<code>is_cow_mapping</code>(定义在<code>mm/internal.h :299</code>处)的内容如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_cow_mapping</span><span class="params">(<span class="keyword">vm_flags_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// flags中一定有VM_MAYWRITE且不含VM_SHARED的是cow页</span></span><br><span class="line">	<span class="keyword">return</span> (flags &amp; (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中VM_SHARED为0x00000008, VM_MAYWRITE为0<br>x0000020, 则这个表达式检测了vma是否私有且可写, 是则判定这个vma是cow的.</p>
<h5 id="针对内存大页tlb的拷贝处理"><a href="#针对内存大页tlb的拷贝处理" class="headerlink" title="针对内存大页tlb的拷贝处理"></a>针对内存大页tlb的拷贝处理</h5><p>对于hugetlb_page执行的<code>copy_hugetlb_page_range</code>(定义在<code>mm/hugetlb.c :3779</code>处), 其逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_hugetlb_page_range</span><span class="params">(struct mm_struct *dst, struct mm_struct *src,</span></span></span><br><span class="line"><span class="function"><span class="params">			    struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// ps: 这里和上面的is_cow_mapping功能一致, 但是却自己又写了一遍.  不知是为啥.</span></span><br><span class="line">	cow = (vma-&gt;vm_flags &amp; (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;</span><br><span class="line">	<span class="keyword">if</span> (cow) &#123;</span><br><span class="line">		mmu_notifier_range_init(&amp;range, MMU_NOTIFY_CLEAR, <span class="number">0</span>, vma, src,</span><br><span class="line">					vma-&gt;vm_start,</span><br><span class="line">					vma-&gt;vm_end);</span><br><span class="line">		mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i_mmap_lock_read(mapping);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历vma执行页拷贝</span></span><br><span class="line">	<span class="keyword">for</span> (addr = vma-&gt;vm_start; addr &lt; vma-&gt;vm_end; addr += sz) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (huge_pte_none(entry) || !huge_pte_none(dst_entry)) &#123;</span><br><span class="line">			;</span><br><span class="line">		<span class="comment">// 如果大页是被换出的页</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(is_hugetlb_entry_migration(entry) ||</span><br><span class="line">				    is_hugetlb_entry_hwpoisoned(entry))) &#123;</span><br><span class="line">			<span class="comment">// 如果父进程的pte页可写且vma是私有可写的则设置父进程的pte只读, 并设置子进程的页为父进程的处于swap中的页</span></span><br><span class="line">			<span class="keyword">if</span> (is_write_migration_entry(swp_entry) &amp;&amp; cow) &#123;</span><br><span class="line">				make_migration_entry_read(&amp;swp_entry);</span><br><span class="line">				entry = swp_entry_to_pte(swp_entry);</span><br><span class="line">				set_huge_swap_pte_at(src, addr, src_pte,</span><br><span class="line">						     entry, sz);</span><br><span class="line">			&#125;</span><br><span class="line">			set_huge_swap_pte_at(dst, addr, dst_pte, entry, sz);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		      <span class="comment">// 如果是私有可写的页, 则设置父进程的页的W/R为0即只读</span></span><br><span class="line">			<span class="keyword">if</span> (cow) &#123;</span><br><span class="line">				huge_ptep_set_wrprotect(src, addr, src_pte);</span><br><span class="line">			&#125;</span><br><span class="line">			entry = huge_ptep_get(src_pte);</span><br><span class="line">			ptepage = pte_page(entry);</span><br><span class="line">			<span class="comment">// 增加物理页引用计数</span></span><br><span class="line">			get_page(ptepage);</span><br><span class="line">			<span class="comment">// 增加page被映射的计数</span></span><br><span class="line">			page_dup_rmap(ptepage, <span class="literal">true</span>);</span><br><span class="line">			<span class="comment">// 设置子进程的pte对应的物理页为父进程的page</span></span><br><span class="line">			set_huge_pte_at(dst, addr, dst_pte, entry);</span><br><span class="line">			<span class="comment">// 增加hugetlb中的使用计数, 此方法即执行了: atomic_long_add(l, &amp;mm-&gt;hugetlb_usage);. 位于include/linux/hugetlb.h :736处</span></span><br><span class="line">			hugetlb_count_add(pages_per_huge_page(h), dst);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝结束后的相关处理</span></span><br><span class="line">	<span class="keyword">if</span> (cow)</span><br><span class="line">		mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i_mmap_unlock_read(mapping);</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="针对默认普通页的拷贝处理"><a href="#针对默认普通页的拷贝处理" class="headerlink" title="针对默认普通页的拷贝处理"></a>针对默认普通页的拷贝处理</h5><p>从<code>copy_page_range</code>跳到<code>copy_p4d_range</code>(在<code>mm/memory.c  :1103</code>处)后, 主要进行遍历循环pgd下的pud进行拷贝</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_p4d_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">pgd_t</span> *dst_pgd, <span class="keyword">pgd_t</span> *src_pgd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> (copy_pud_range(dst_vma, src_vma, dst_p4d, src_p4d,</span><br><span class="line">				   addr, next))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_p4d++, src_p4d++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_pud_range</code>(在<code>mm/memory.c  :1066</code>处)中循环遍历进行pud下的所有pmd拷贝:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_pud_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">p4d_t</span> *dst_p4d, <span class="keyword">p4d_t</span> *src_p4d, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 特殊情况处理</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 执行pmd拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (copy_pmd_range(dst_vma, src_vma, dst_pud, src_pud,</span><br><span class="line">				   addr, next))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pud++, src_pud++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>copy_pmd_range</code>(在<code>mm/memory.c  :1029</code>处) 中循环遍历进行pte的拷贝, 这里会有个分叉, 如果是huge_pmd或者处于swap中或是设备映射的页表则跳到<code>copy_huge_pmd</code>执行, 普通的页则执行<code>copy_pte_range</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_pmd_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">pud_t</span> *dst_pud, <span class="keyword">pud_t</span> *src_pud, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 处理huge_pmd或者处于swap中或是设备映射的页表的拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (is_swap_pmd(*src_pmd) || pmd_trans_huge(*src_pmd)</span><br><span class="line">			|| pmd_devmap(*src_pmd)) &#123;</span><br><span class="line">				...</span><br><span class="line">				err = copy_huge_pmd(dst_mm, src_mm,</span><br><span class="line">					    dst_pmd, src_pmd, addr, src_vma);</span><br><span class="line">				<span class="keyword">if</span> (err == -ENOMEM)</span><br><span class="line">					<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">				<span class="keyword">if</span> (!err)</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">// 如果完成拷贝则继续下一个pmd的处理</span></span><br><span class="line">				<span class="comment">// copy_huge_pmd返回的err都是小于或等于0的, 此处fall through 感觉一般不可能被触发</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 处理普通pte的拷贝</span></span><br><span class="line">		<span class="keyword">if</span> (copy_pte_range(dst_vma, src_vma, dst_pmd, src_pmd,</span><br><span class="line">				   addr, next))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;	</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pmd++, src_pmd++, addr = next, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理大pmd的拷贝-copy-huge-pmd"><a href="#处理大pmd的拷贝-copy-huge-pmd" class="headerlink" title="处理大pmd的拷贝: copy_huge_pmd"></a>处理大pmd的拷贝: <code>copy_huge_pmd</code></h5><p><code>copy_huge_pmd</code>代码在<code>mm/huge_memory.c :1011</code>处:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_huge_pmd</span><span class="params">(struct mm_struct *dst_mm, struct mm_struct *src_mm,</span></span></span><br><span class="line"><span class="function"><span class="params">		  <span class="keyword">pmd_t</span> *dst_pmd, <span class="keyword">pmd_t</span> *src_pmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">		  struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 特殊情况处理,条件检查和加锁等操作</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 大零页的处理, </span></span><br><span class="line">	<span class="keyword">if</span> (is_huge_zero_pmd(pmd)) &#123;</span><br><span class="line">		zero_page = mm_get_huge_zero_page(dst_mm);</span><br><span class="line">		<span class="comment">// 直接设置子进程页为大零页</span></span><br><span class="line">		set_huge_zero_page(pgtable, dst_mm, vma, addr, dst_pmd,</span><br><span class="line">				zero_page);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对私有可写且pinned的页进程处理</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_cow_mapping(vma-&gt;vm_flags) &amp;&amp;</span><br><span class="line">		     atomic_read(&amp;src_mm-&gt;has_pinned) &amp;&amp;</span><br><span class="line">		     page_maybe_dma_pinned(src_page))) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 增加父进程页的计数</span></span><br><span class="line">	get_page(src_page);</span><br><span class="line">	<span class="comment">// 增加父进程页的映射计数</span></span><br><span class="line">	page_dup_rmap(src_page, <span class="literal">true</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 设置父进程pmd只读</span></span><br><span class="line">	pmdp_set_wrprotect(src_mm, addr, src_pmd);</span><br><span class="line">	<span class="comment">// 设置子进程pmd只读且未被最近访问</span></span><br><span class="line">	pmd = pmd_mkold(pmd_wrprotect(pmd));</span><br><span class="line">	<span class="comment">// 设置子进程的pmd为新建的pmd,使拷贝生效</span></span><br><span class="line">	set_pmd_at(dst_mm, addr, dst_pmd, pmd);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理对普通pmd下的所有pte的拷贝-copy-pte-range"><a href="#处理对普通pmd下的所有pte的拷贝-copy-pte-range" class="headerlink" title="处理对普通pmd下的所有pte的拷贝: copy_pte_range"></a>处理对普通pmd下的所有pte的拷贝: <code>copy_pte_range</code></h5><p>对普通pte的拷贝的处理代码位于<code>mm/memory.c :923</code>处, 逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_pte_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">	       <span class="keyword">pmd_t</span> *dst_pmd, <span class="keyword">pmd_t</span> *src_pmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">	       <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 一些变量初始化和条件判断,加锁等</span></span><br><span class="line">	...</span><br><span class="line">again:</span><br><span class="line">	progress = <span class="number">0</span>;</span><br><span class="line">	...	</span><br><span class="line">	<span class="comment">// 循环执行处理:</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">// 如果progress&gt;=32 则检查是否需要进行重新schedule.是则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (progress &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">			progress = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (need_resched() ||</span><br><span class="line">			    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// pte是空的情况直接progress++</span></span><br><span class="line">		<span class="keyword">if</span> (pte_none(*src_pte)) &#123;</span><br><span class="line">			progress++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断pte是不是present的即在内存中的, 大概率可能是的, 如果不是, 则执行copy_nonpresent_pte的逻辑, 否则就执行copy_present_pte的逻辑, 不论哪种执行后都将progress加8.</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pte_present(*src_pte))) &#123;</span><br><span class="line">			entry.val = copy_nonpresent_pte(dst_mm, src_mm,</span><br><span class="line">							dst_pte, src_pte,</span><br><span class="line">							src_vma, addr, rss);</span><br><span class="line">			<span class="keyword">if</span> (entry.val)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			progress += <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = copy_present_pte(dst_vma, src_vma, dst_pte, src_pte,</span><br><span class="line">				       addr, rss, &amp;prealloc);</span><br><span class="line">		...		  </span><br><span class="line">		progress += <span class="number">8</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != <span class="built_in">end</span>);</span><br><span class="line">	<span class="comment">// 拷贝结束后的收尾处理</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断pte是不是在内存中的逻辑不同体系结构定义不同, 在x86_64中定义为判断pte中第0位(P位)的值是不是1. </p>
<h5 id="不在物理内存中的pte的拷贝"><a href="#不在物理内存中的pte的拷贝" class="headerlink" title="不在物理内存中的pte的拷贝"></a>不在物理内存中的pte的拷贝</h5><p><code>copy_nonpresent_pte</code>位于<code>mm/memory.c :698</code>处:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">copy_nonpresent_pte(struct mm_struct *dst_mm, struct mm_struct *src_mm,</span><br><span class="line">		<span class="keyword">pte_t</span> *dst_pte, <span class="keyword">pte_t</span> *src_pte, struct vm_area_struct *vma,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">int</span> *rss)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> pte = *src_pte;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">swp_entry_t</span> entry = pte_to_swp_entry(pte);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 大概率是在swap中的pte, 则执行swap_duplicate增加其引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!non_swap_entry(entry))) &#123;</span><br><span class="line">		...</span><br><span class="line">	<span class="comment">// 如果是换入的页</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_migration_entry(entry)) &#123;</span><br><span class="line">		page = migration_entry_to_page(entry);</span><br><span class="line">		<span class="comment">// 物理页引用增加</span></span><br><span class="line">		rss[mm_counter(page)]++;</span><br><span class="line">		<span class="comment">// 如果pte页是可写的且vma是私有可写的</span></span><br><span class="line">		<span class="keyword">if</span> (is_write_migration_entry(entry) &amp;&amp;</span><br><span class="line">				is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">			<span class="comment">// 设置父进程pte只读</span></span><br><span class="line">			make_migration_entry_read(&amp;entry);</span><br><span class="line">			pte = swp_entry_to_pte(entry);</span><br><span class="line">			<span class="comment">// 如果父进程页脏则设置子进程页脏</span></span><br><span class="line">			<span class="keyword">if</span> (pte_swp_soft_dirty(*src_pte))</span><br><span class="line">				pte = pte_swp_mksoft_dirty(pte);</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 重新设置父进程pte</span></span><br><span class="line">			set_pte_at(src_mm, addr, src_pte, pte);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 如果是设备私有的pte</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_device_private_entry(entry)) &#123;</span><br><span class="line">		page = device_private_entry_to_page(entry);</span><br><span class="line">		<span class="comment">// 增加page引用计数,映射计数,rss计数</span></span><br><span class="line">		get_page(page);</span><br><span class="line">		rss[mm_counter(page)]++;</span><br><span class="line">		page_dup_rmap(page, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 如果私有可写的设备pte, 且vma私有可写</span></span><br><span class="line">		<span class="keyword">if</span> (is_write_device_private_entry(entry) &amp;&amp;</span><br><span class="line">		    is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">		    <span class="comment">// 设置pte只读</span></span><br><span class="line">			make_device_private_entry_read(&amp;entry);</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 重新设置父进程pte</span></span><br><span class="line">			set_pte_at(src_mm, addr, src_pte, pte);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置子进程的pte</span></span><br><span class="line">	set_pte_at(dst_mm, addr, dst_pte, pte);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处于物理内存中的pte的拷贝"><a href="#处于物理内存中的pte的拷贝" class="headerlink" title="处于物理内存中的pte的拷贝"></a>处于物理内存中的pte的拷贝</h5><p>代码位于<code>mm/memory.c :851</code>中, 逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_present_pte(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">		 <span class="keyword">pte_t</span> *dst_pte, <span class="keyword">pte_t</span> *src_pte, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">int</span> *rss,</span><br><span class="line">		 struct page **prealloc)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取父进程pte对应的page结构描述符</span></span><br><span class="line">	page = vm_normal_page(src_vma, addr, pte);</span><br><span class="line">	<span class="comment">// 如果page存在, 则执行拷贝物理页逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 执行拷贝物理页的逻辑</span></span><br><span class="line">		retval = copy_present_page(dst_vma, src_vma, dst_pte, src_pte,</span><br><span class="line">					   addr, rss, prealloc, pte, page);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 增加page引用计数</span></span><br><span class="line">		get_page(page);</span><br><span class="line">		<span class="comment">// 增加page的映射计数</span></span><br><span class="line">		page_dup_rmap(page, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 增加rss计数</span></span><br><span class="line">		rss[mm_counter(page)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果vma是私有可写的,且pte可写, 则设置父子进程pte只读, </span></span><br><span class="line">	<span class="keyword">if</span> (is_cow_mapping(vm_flags) &amp;&amp; pte_write(pte)) &#123;</span><br><span class="line">		ptep_set_wrprotect(src_mm, addr, src_pte); <span class="comment">//设置父pte只读</span></span><br><span class="line">		pte = pte_wrprotect(pte); <span class="comment">//设置子pte只读</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果vma是共享的, 则设置pte为非脏的</span></span><br><span class="line">	<span class="keyword">if</span> (vm_flags &amp; VM_SHARED)</span><br><span class="line">		pte = pte_mkclean(pte); <span class="comment">// 内部逻辑是设置pte的D位置为0</span></span><br><span class="line">	<span class="comment">// 设置pte的A位为0, 即最近未被访问</span></span><br><span class="line">	pte = pte_mkold(pte); </span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 设置子进程的pte</span></span><br><span class="line">	set_pte_at(dst_vma-&gt;vm_mm, addr, dst_pte, pte);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>vm_normal_page</code>执行获取虚拟页pte对应关联的物理页page的逻辑:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">vm_normal_page</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">			    <span class="keyword">pte_t</span> pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn = pte_pfn(pte); <span class="comment">//获取物理页的page frame页框号码	...</span></span><br><span class="line">	<span class="keyword">return</span> pfn_to_page(pfn); <span class="comment">// 返回物理页, 其逻辑为 (vmem_map + (pfn))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86下<code>pte_pfn</code>的定义在<code>arch/x86/include/asm/pgtable.h :212</code>处:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">pte_pfn</span><span class="params">(<span class="keyword">pte_t</span> pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> pfn = pte_val(pte); <span class="comment">// pte_val 就是native_pte_val, 返回pte.pte</span></span><br><span class="line">	pfn ^= protnone_mask(pfn); </span><br><span class="line">	<span class="keyword">return</span> (pfn &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中变量的定义如下, 而PAGE_SIZE默认是4K的页, 那么在默认4k页情况下PTE_PFN_MASK即为<code>000ffffffffff000</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PFN_MASK		((pteval_t)PHYSICAL_PAGE_MASK)`, </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSICAL_PAGE_MASK	(((signed long)PAGE_MASK) &amp; __PHYSICAL_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MASK		(~(PAGE_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT		12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYSICAL_MASK_SHIFT	52</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DYNAMIC_PHYSICAL_MASK</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">phys_addr_t</span> physical_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYSICAL_MASK		physical_mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYSICAL_MASK		((phys_addr_t)((1ULL &lt;&lt; __PHYSICAL_MASK_SHIFT) - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中的<code>copy_present_page</code>内部会进行判断页是不是pinned和非私有可写的, 如果是非pinned和私有可写的则返回1, 其他情况则执行数据拷贝, 如果遇到错误则返回负数. 代码在<code>mm/memory.c :796</code>处:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">copy_present_page(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,</span><br><span class="line">		  <span class="keyword">pte_t</span> *dst_pte, <span class="keyword">pte_t</span> *src_pte, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">int</span> *rss,</span><br><span class="line">		  struct page **prealloc, <span class="keyword">pte_t</span> pte, struct page *page)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果vma是非私有可写的, 返回1, 跳过实际的数据拷贝</span></span><br><span class="line">	<span class="keyword">if</span> (!is_cow_mapping(src_vma-&gt;vm_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 如果是非pinned的页, 则返回1</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!atomic_read(&amp;src_mm-&gt;has_pinned)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (likely(!page_maybe_dma_pinned(page)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 以下则针对pinned的页执行数据拷贝:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 拷贝旧page数据到新页</span></span><br><span class="line">	copy_user_highpage(new_page, page, addr, src_vma);</span><br><span class="line">	<span class="comment">// 强制刷新新物理页</span></span><br><span class="line">	__SetPageUptodate(new_page);</span><br><span class="line">	<span class="comment">// 把子进程的pte指向新建的物理页,建立反向映射关系</span></span><br><span class="line">	page_add_new_anon_rmap(new_page, dst_vma, addr, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">// 设置子进程该页cache失效</span></span><br><span class="line">	lru_cache_add_inactive_or_unevictable(new_page, dst_vma);</span><br><span class="line">	rss[mm_counter(new_page)]++;</span><br><span class="line">	<span class="comment">// 向子进程vma中写入新的页并设置pte脏和可写</span></span><br><span class="line">	pte = mk_pte(new_page, dst_vma-&gt;vm_page_prot);</span><br><span class="line">	pte = maybe_mkwrite(pte_mkdirty(pte), dst_vma);</span><br><span class="line">	set_pte_at(dst_vma-&gt;vm_mm, addr, dst_pte, pte);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>page_add_new_anon_rmap</code>(定义在<code>mm/rmap.c : 1175</code>处)中, 会调用<code>__page_set_anon_rmap</code>(定义在<code>mm/rmap.c : 1039</code>处)设置匿名物理页对应的线性地址索引:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anon_vma = (<span class="keyword">void</span> *) anon_vma + PAGE_MAPPING_ANON;</span><br><span class="line">WRITE_ONCE(page-&gt;mapping, (struct address_space *) anon_vma);</span><br><span class="line">page-&gt;index = linear_page_index(vma, address);</span><br></pre></td></tr></table></figure>
<p>而<code>linear_page_index</code>(位于<code>include/linux/pagemap.h :551</code>)的代码逻辑则如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pgoff_t</span> <span class="title">linear_page_index</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pgoff_t</span> pgoff;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">		<span class="keyword">return</span> linear_hugepage_index(vma, address);</span><br><span class="line">	pgoff = (address - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	pgoff += vma-&gt;vm_pgoff; <span class="comment">// pgoff是vma开始的线性地址对应的虚拟页框号.</span></span><br><span class="line">	<span class="keyword">return</span> pgoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内存COW缺页异常的触发和处理"><a href="#内存COW缺页异常的触发和处理" class="headerlink" title="内存COW缺页异常的触发和处理"></a>内存COW缺页异常的触发和处理</h3><p>在读取内存页遇到权限错误后COW的处理链路(普通页)主要如下:<br><code>DEFINE_IDTENTRY_RAW_ERRORCODE -&gt; handle_page_fault -&gt; do_user_addr_fault -&gt; handle_mm_fault -&gt; __handle_mm_fault -&gt; handle_pte_fault -&gt; do_wp_page -&gt; wp_page_copy/wp_page_reuse</code></p>
<p>在x86体系下, 当发生访问COW页面时, MMU通过解析线性地址(虚拟地址)获得页表项详细,即会访问W/R为0的页, 查阅Intel的手册第4.7节和6.2节中内容可知: 对W/R为0的页面进行写入操作是, MMU会返回Page Fault的Fault错误, page fault error code是14, 错误Mne-monic为#PF. 其中返回的32位数据中第1位会被置为1,代表导致错误的原因是写入权限问题.</p>
<p>处理这个错误的代码入口定义在<code>arch/x86/entry/entry_64.S</code>中.</p>
<p><em>ps: 此处如何通过entry_64.S找到下一个处理函数的入口尚未看明白</em></p>
<p>之后代码跳转到: <code>arch/x86/mm/fault.c :1469</code>处的<code>DEFINE_IDTENTRY_RAW_ERRORCODE</code>执行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instrumentation_begin();</span><br><span class="line">handle_page_fault(regs, error_code, address);</span><br><span class="line">instrumentation_end();</span><br></pre></td></tr></table></figure>
<p>其中的<code>handle_page_fault</code>(定义在<code>arch/x86/mm/fault.c :1445</code>处)负责处理page fault, 内部分为两种处理逻辑, 一种是对内核地址上的页错误进行处理, 一种是对用户空间地址上的页错误进行处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">	do_kern_addr_fault(regs, error_code, address);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	do_user_addr_fault(regs, error_code, address);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>do_user_addr_fault</code>(定义在<code>arch/x86/mm/fault.c :1240</code>处)中执行对COW处理逻辑:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_user_addr_fault</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> hw_error_code,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 一些条件检查等</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果MMU的fage fault错误是X86_PF_WRITE, 则设置flags为FAULT_FLAG_WRITE</span></span><br><span class="line">	<span class="comment">// 而X86_PF_WRITE = 1 &lt;&lt; 1, 刚好就是MMU返回的错误信息第1位为1的.</span></span><br><span class="line">	<span class="keyword">if</span> (hw_error_code &amp; X86_PF_WRITE)</span><br><span class="line">		flags |= FAULT_FLAG_WRITE;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 尝试mmap加读锁,失败则进行might_sleep();</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!mmap_read_trylock(mm))) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 执行mm的page fault错误处理逻辑</span></span><br><span class="line">	fault = handle_mm_fault(vma, address, flags, regs);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// mmap解锁</span></span><br><span class="line">	mmap_read_unlock(mm);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>handle_mm_fault</code>定义在<code>mm/memory.c :4592</code>处,其中根据页面是否是大页进行分别处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">handle_mm_fault</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 设置当前进程状态为running</span></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line">	<span class="comment">// pagefault计数增加</span></span><br><span class="line">	count_vm_event(PGFAULT);</span><br><span class="line">	count_memcg_event_mm(vma-&gt;vm_mm, PGFAULT);</span><br><span class="line">	<span class="comment">// 一些条件检查</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 处理页错误, 区分hugetlb和普通页分别处理</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = __handle_mm_fault(vma, address, flags);	<span class="comment">// 其他oom检查等逻辑</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理hugetlb的page-fault错误"><a href="#处理hugetlb的page-fault错误" class="headerlink" title="处理hugetlb的page fault错误"></a>处理hugetlb的page fault错误</h4><p><code>hugetlb_fault</code>的逻辑代码定义在<code>mm/hugetlb.c :4507</code>处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">hugetlb_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 确保reservaion被解除</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !huge_pte_write(entry)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vma_needs_reservation(h, vma, haddr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = VM_FAULT_OOM;</span><br><span class="line">			<span class="keyword">goto</span> out_mutex;</span><br><span class="line">		&#125;</span><br><span class="line">		vma_end_reservation(h, vma, haddr);</span><br><span class="line">		<span class="comment">// 如果是私有的页则获得一个pagechage</span></span><br><span class="line">		<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_MAYSHARE))</span><br><span class="line">			pagecache_page = hugetlbfs_pagecache_page(h,</span><br><span class="line">								vma, haddr);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 获取pte对应的物理页</span></span><br><span class="line">	page = pte_page(entry);</span><br><span class="line">	<span class="keyword">if</span> (page != pagecache_page)</span><br><span class="line">		<span class="keyword">if</span> (!trylock_page(page)) &#123;</span><br><span class="line">			need_wait_lock = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> out_ptl;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 增加物理页引用计数</span></span><br><span class="line">	get_page(page);</span><br><span class="line">	<span class="comment">// 如果vma可写且pte只读则执行拷贝物理页操作hugetlb_cow</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!huge_pte_write(entry)) &#123;</span><br><span class="line">		<span class="comment">// 拷贝大页数据</span></span><br><span class="line">			ret = hugetlb_cow(mm, vma, address, ptep,</span><br><span class="line">					  pagecache_page, ptl);</span><br><span class="line">			<span class="keyword">goto</span> out_put_page;</span><br><span class="line">		&#125;</span><br><span class="line">		entry = huge_pte_mkdirty(entry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 标记旧物理页最近被访问</span></span><br><span class="line">	entry = pte_mkyoung(entry);</span><br><span class="line">	<span class="comment">// 设置pte的access标记并更新mmt的tlb缓存</span></span><br><span class="line">	<span class="keyword">if</span> (huge_ptep_set_access_flags(vma, haddr, ptep, entry,</span><br><span class="line">						flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">		update_mmu_cache(vma, haddr, ptep);</span><br><span class="line">out_put_page:</span><br><span class="line">	<span class="comment">// 解锁旧页</span></span><br><span class="line">	<span class="keyword">if</span> (page != pagecache_page)</span><br><span class="line">		unlock_page(page);</span><br><span class="line">	<span class="comment">// 减少旧物理页引用计数</span></span><br><span class="line">	put_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>hugetlb_cow</code>代码定义在<code>mm/hugetlb.c :4098</code>处, 其中和cow相关的逻辑为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">	...</span><br><span class="line">	<span class="comment">// 如果该page只有一个人使用了则直接设置该页的pte为可写状态即可</span></span><br><span class="line">	<span class="keyword">if</span> (page_mapcount(old_page) == <span class="number">1</span> &amp;&amp; PageAnon(old_page)) &#123;</span><br><span class="line">		page_move_anon_rmap(old_page, vma);</span><br><span class="line">		set_huge_ptep_writable(vma, haddr, ptep);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 新建一个大页</span></span><br><span class="line">	new_page = alloc_huge_page(vma, haddr, outside_reserve);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 拷贝页的内容</span></span><br><span class="line">	copy_user_huge_page(new_page, old_page, address, vma,</span><br><span class="line">				    pages_per_huge_page(h));</span><br><span class="line">	<span class="comment">// mmu设置通知区域不可用,刷新其他mmu</span></span><br><span class="line">	mmu_notifier_range_init(&amp;range, MMU_NOTIFY_CLEAR, <span class="number">0</span>, vma, mm, haddr,</span><br><span class="line">					haddr + huge_page_size(h));</span><br><span class="line">	mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line">spin_lock(ptl);</span><br><span class="line">	ptep = huge_pte_offset(mm, haddr, huge_page_size(h));</span><br><span class="line">	<span class="comment">// 完成cow映射分离</span></span><br><span class="line">	<span class="keyword">if</span> (likely(ptep &amp;&amp; pte_same(huge_ptep_get(ptep), pte))) &#123;</span><br><span class="line">		ClearPagePrivate(new_page);</span><br><span class="line">		huge_ptep_clear_flush(vma, haddr, ptep);</span><br><span class="line">		mmu_notifier_invalidate_range(mm, range.start, range.<span class="built_in">end</span>);</span><br><span class="line">		<span class="comment">// 更新pte指向的page</span></span><br><span class="line">		set_huge_pte_at(mm, haddr, ptep,</span><br><span class="line">				make_huge_pte(vma, new_page, <span class="number">1</span>));</span><br><span class="line">		<span class="comment">// 移除旧页的反向映射</span></span><br><span class="line">		page_remove_rmap(old_page, <span class="literal">true</span>);</span><br><span class="line">		<span class="comment">// 添加新页的反向映射</span></span><br><span class="line">		hugepage_add_new_anon_rmap(new_page, vma, haddr);</span><br><span class="line">		<span class="comment">// 设置新页可见</span></span><br><span class="line">		set_page_huge_active(new_page);</span><br><span class="line">		<span class="comment">/* Make the old page be freed below */</span></span><br><span class="line">		new_page = old_page;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(ptl);</span><br><span class="line">	<span class="comment">// mmu通知range截止</span></span><br><span class="line">	mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">out_release_all:</span><br><span class="line">	restore_reserve_on_error(h, vma, haddr, new_page);</span><br><span class="line">	<span class="comment">// 减少物理页的引用计数</span></span><br><span class="line">	put_page(new_page);</span><br><span class="line">out_release_old:</span><br><span class="line">	put_page(old_page);</span><br></pre></td></tr></table></figure>


<h4 id="处理普通页的page-fault错误"><a href="#处理普通页的page-fault错误" class="headerlink" title="处理普通页的page fault错误"></a>处理普通页的page fault错误</h4><p><code>__handle_mm_fault</code>的代码定义在<code>mm/memory.c :4436</code>处: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> __handle_mm_fault(struct vm_area_struct *vma,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">// 声明vmf的结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> = &#123;</span></span><br><span class="line">		.vma = vma,</span><br><span class="line">		.address = address &amp; PAGE_MASK,</span><br><span class="line">		.flags = flags,</span><br><span class="line">		.pgoff = linear_page_index(vma, address),</span><br><span class="line">		.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 寻找和分配页表项</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	...</span><br><span class="line">	pgd = pgd_offset(mm, address); <span class="comment">//全局页表</span></span><br><span class="line">	p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">	...</span><br><span class="line">	vmf.pud = pud_alloc(mm, p4d, address); <span class="comment">//上层页表</span></span><br><span class="line">	...</span><br><span class="line">	vmf.pmd = pmd_alloc(mm, vmf.pud, address); <span class="comment">//中间层页表</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 进行pte页表的的错误处理,即完成物理页分配和pte页表项填充</span></span><br><span class="line">	<span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>handle_pte_fault</code>方法定义在<code>mm/memory.c :4343</code>处, </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">handle_pte_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	... <span class="comment">// 检查pmd是否none</span></span><br><span class="line">    <span class="comment">// 如果pte是NULL且vma是匿名的,do_anonymous_page(vmf),其中会处理零页的情况, 如果pte不存在且vma不是匿名的, 则说明是第一次访问文件的mmap区域,此时进行处理文件映射相关的处理</span></span><br><span class="line">	<span class="keyword">if</span> (!vmf-&gt;pte) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))</span><br><span class="line">			<span class="keyword">return</span> do_anonymous_page(vmf); <span class="comment">// 处理匿名页</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> do_fault(vmf); <span class="comment">//处理文件映射</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))  <span class="comment">// 处理在swap中的内存</span></span><br><span class="line">		<span class="keyword">return</span> do_swap_page(vmf);</span><br><span class="line">	<span class="keyword">if</span> (pte_protnone(vmf-&gt;orig_pte) &amp;&amp; vma_is_accessible(vmf-&gt;vma))</span><br><span class="line">		<span class="keyword">return</span> do_numa_page(vmf);</span><br><span class="line">	vmf-&gt;ptl = pte_lockptr(vmf-&gt;vma-&gt;vm_mm, vmf-&gt;pmd);</span><br><span class="line">	spin_lock(vmf-&gt;ptl);</span><br><span class="line">	entry = vmf-&gt;orig_pte;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pte_same(*vmf-&gt;pte, entry))) &#123;</span><br><span class="line">		update_mmu_tlb(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果vma是可写的, 且pte的RW是只读属性, 则执行do_wp_page(vmf),之后重置entry的pte D位</span></span><br><span class="line">	<span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">			<span class="keyword">return</span> do_wp_page(vmf);  <span class="comment">// 进入COW缺页异常逻辑</span></span><br><span class="line">		entry = pte_mkdirty(entry);</span><br><span class="line">	&#125;</span><br><span class="line">	entry = pte_mkyoung(entry);</span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte, entry,</span><br><span class="line">				vmf-&gt;flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">		<span class="comment">// 更新mmu的缓存</span></span><br><span class="line">		update_mmu_cache(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Skip spurious TLB flush for retried page fault */</span></span><br><span class="line">		<span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_TRIED)</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">		<span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">			flush_tlb_fix_spurious_fault(vmf-&gt;vma, vmf-&gt;address);</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于匿名页的处理会进入<code>do_anonymous_page</code>(在<code>mm/memory.c :3482</code>处)中进行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 分配pte页表项</span></span><br><span class="line">	<span class="keyword">if</span> (pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd))</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	...  <span class="comment">// 使用零页处理读的情况</span></span><br><span class="line">	<span class="comment">// 分配一个物理页, 其中会通过__alloc_zeroed_user_highpage调用alloc_page_vma, 在其中进一步通过alloc_pages_vma调用__alloc_pages_nodemask, 由伙伴系统分配一个新的全0的物理页</span></span><br><span class="line">	page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address);</span><br><span class="line">	...</span><br><span class="line">	__SetPageUptodate(page);  <span class="comment">// 使新分配的物理页可见</span></span><br><span class="line">	<span class="comment">// 根据vma信息创建一个pte信息,并将物理页的页号信息保存在新建的pte中, 使得pte到物理页的映射生效</span></span><br><span class="line">	entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">	<span class="comment">// 使pte标记为最近被访问</span></span><br><span class="line">	entry = pte_sw_mkyoung(entry);</span><br><span class="line">	<span class="comment">// 如果vma是可写的, 则设置pte为脏且可写</span></span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">		entry = pte_mkwrite(pte_mkdirty(entry));</span><br><span class="line">	<span class="comment">// 锁定待更新vma的pte处</span></span><br><span class="line">	vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,</span><br><span class="line">			&amp;vmf-&gt;ptl);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 替换设置vma的pte为新的pte</span></span><br><span class="line">	set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line">	<span class="comment">// 更新mmt的tlb缓存</span></span><br><span class="line">	update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">	<span class="comment">// 解除锁定</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中<code>mk_pte</code>的对于x86系统的定义位于: <code>arch/x86/include/asm/pgtable.h :845</code>处: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk_pte(page, pgprot)   pfn_pte(page_to_pfn(page), (pgprot))</span></span><br></pre></td></tr></table></figure>
<p>而<code>pfn_pte</code>(位于<code>arch/x86/include/asm/pgtable.h :603</code>)和<code>page_to_pfn</code>(位于<code>include/asm-generic :55</code>)分别是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pte结构是一个长整形数据, 根据x86下pte的定义结构初始化生成</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pte_t</span> <span class="title">pfn_pte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> page_nr, <span class="keyword">pgprot_t</span> pgprot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> pfn = (<span class="keyword">phys_addr_t</span>)page_nr &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	pfn ^= protnone_mask(pgprot_val(pgprot));</span><br><span class="line">	pfn &amp;= PTE_PFN_MASK;</span><br><span class="line">	<span class="keyword">return</span> __pte(pfn | check_pgprot(pgprot));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取物理页号的函数, page存储在伙伴系统的pglist_data -&gt; mem_map中, 这个计算就是直接获得page相对于mem_map的偏移量, 即是index.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(page)	(unsigned long)((page) - vmemmap)</span></span><br></pre></td></tr></table></figure>

<p>对于首次访问文件映射区mmap的处理由<code>do_fault</code>(定义在mm/memory.c :4111)负责:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果vm_ops绑定的fault处理函数不存在情况的特殊处理</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault) &#123;</span><br><span class="line">	...</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(vmf-&gt;flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">	<span class="comment">// 如果写的vma区域不是可写的, 则</span></span><br><span class="line">		ret = do_read_fault(vmf);</span><br><span class="line">	<span class="comment">// 如果vma区域是私有且可写, 则执行do_cow_fault处理COW逻辑</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">		ret = do_cow_fault(vmf);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="comment">//共享的vma则通过do_shared_fault进行处理</span></span><br><span class="line">		ret = do_shared_fault(vmf);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_read_fault</code>, <code>do_cow_fault</code>和<code>do_shared_fault</code>三者都会执行<code>__do_fault</code>这个方法,其中对于COW的处理是, 先分配一个COW页, 再通过调用 <code>__do_fault</code>(内部执行<code>vma-&gt;vm_ops-&gt;fault(vmf)</code>,即执行vm_ops指定的fault函数), 之后拷贝page内容到COW页, 最后通过<code>finish_fault</code>方法设置pte, 并通过<code>put_page</code>减少新旧页各自的引用计数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_cow_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 分配新的COW页</span></span><br><span class="line">	vmf-&gt;cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-&gt;address);</span><br><span class="line">	<span class="comment">// 调用__do_fault</span></span><br><span class="line">	ret = __do_fault(vmf);</span><br><span class="line">	<span class="comment">// 拷贝page页数据</span></span><br><span class="line">	copy_user_highpage(vmf-&gt;cow_page, vmf-&gt;page, vmf-&gt;address, vma);</span><br><span class="line">	<span class="comment">// 刷新页</span></span><br><span class="line">	__SetPageUptodate(vmf-&gt;cow_page);</span><br><span class="line">	<span class="comment">// 调用finish_fault设置pte</span></span><br><span class="line">	ret |= finish_fault(vmf);</span><br><span class="line">	<span class="comment">// 减少旧页的引用计数</span></span><br><span class="line">	put_page(vmf-&gt;page);</span><br><span class="line">	<span class="comment">// 减少新页的引用计数</span></span><br><span class="line">	put_page(vmf-&gt;cow_page);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>finish_fault</code>内部会调用<code>alloc_set_pte</code>, 在<code>alloc_set_pte</code>的内部会执行设置新的pte, 更新pte数据的操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="built_in">write</span> = vmf-&gt;flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 获得一个新的pte结构</span></span><br><span class="line">entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line"><span class="comment">// 设置pte为新</span></span><br><span class="line">entry = pte_sw_mkyoung(entry);</span><br><span class="line"><span class="comment">// 如果vma可写,则设置pte脏和可写,cow页会进行这个操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span>)</span><br><span class="line">	entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"><span class="comment">// 如果vma私有可写, 则增加匿名页计数,并添加物理页到vma的匿名映射区</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">write</span> &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)) &#123;</span><br><span class="line">	inc_mm_counter_fast(vma-&gt;vm_mm, MM_ANONPAGES);</span><br><span class="line">	page_add_new_anon_rmap(page, vma, vmf-&gt;address, <span class="literal">false</span>);</span><br><span class="line">	lru_cache_add_inactive_or_unevictable(page, vma);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	inc_mm_counter_fast(vma-&gt;vm_mm, mm_counter_file(page));</span><br><span class="line">	page_add_file_rmap(page, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新pte,建立映射</span></span><br><span class="line">set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line"><span class="comment">// 更新mmt缓存</span></span><br><span class="line">update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br></pre></td></tr></table></figure>


<p>在<code>do_wp_page</code>(代码在<code>mm/memory.c :3085</code>处)中执行cow的处理逻辑如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取发生异常的地址所在page结构</span></span><br><span class="line">vmf-&gt;page = vm_normal_page(vma, vmf-&gt;address, vmf-&gt;orig_pte);</span><br><span class="line"><span class="comment">// 如果没有page结构是使用页帧映射的, 且vma是共享可写的, 则通过wp_pfn_shared处理共享可写的映射.</span></span><br><span class="line"><span class="keyword">if</span> (!vmf-&gt;page) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">			     (VM_WRITE|VM_SHARED))</span><br><span class="line">		<span class="keyword">return</span> wp_pfn_shared(vmf);</span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(vmf); <span class="comment">// 处理私有可写的映射</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (PageAnon(vmf-&gt;page)) &#123; <span class="comment">// 针对私有可写的匿名页做特殊处理, 如果父或子进程执行了COW, 此时另一个的pte仍然是只读, 但是这个page的map_count会变为1, 这种情况就需要把另一个进程的pte设置为可写</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">vmf</span>-&gt;<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (PageKsm(page) || page_count(page) != <span class="number">1</span>) <span class="comment">// 如果是KSM的page或者page_count计数不为1则</span></span><br><span class="line">		<span class="keyword">goto</span> copy;</span><br><span class="line">	<span class="keyword">if</span> (!trylock_page(page)) <span class="comment">//尝试锁住page, 锁不住则执行copy</span></span><br><span class="line">		<span class="keyword">goto</span> copy;</span><br><span class="line">	<span class="keyword">if</span> (PageKsm(page) || page_mapcount(page) != <span class="number">1</span> || page_count(page) != <span class="number">1</span>) &#123; </span><br><span class="line">	<span class="comment">// 如果map_count &gt; 1 或page_count&gt;1或是ksm page则不执行. 此处再次判断PageKsm(page)确保一定不是 ksm.</span></span><br><span class="line">		unlock_page(page);</span><br><span class="line">		<span class="keyword">goto</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock_page(page); <span class="comment">//page解锁</span></span><br><span class="line">	wp_page_reuse(vmf); <span class="comment">// 设置pte,在其中完成cow的处理</span></span><br><span class="line">	<span class="keyword">return</span> VM_FAULT_WRITE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">				(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line">	<span class="keyword">return</span> wp_page_shared(vmf); <span class="comment">//处理共享页</span></span><br><span class="line">&#125;</span><br><span class="line">copy:</span><br><span class="line">	get_page(vmf-&gt;page); <span class="comment">// 增加vma的page的引用计数, 避免page在计数为0时被释放</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl); <span class="comment">//释放pte锁</span></span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(vmf); <span class="comment">// 进一步完成处理COW的动作</span></span><br></pre></td></tr></table></figure>

<p>在<code>wp_page_copy</code>(定义在<code>mm/memory.c :2828</code>)中执行拷贝页数据的过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">wp_page_copy</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span> = <span class="title">vmf</span>-&gt;<span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">new_page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	<span class="keyword">int</span> page_copied = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_range</span> <span class="title">range</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(anon_vma_prepare(vma))) <span class="comment">// 关联一个anon_vma实例到vma</span></span><br><span class="line">		<span class="keyword">goto</span> oom;</span><br><span class="line">	<span class="keyword">if</span> (is_zero_pfn(pte_pfn(vmf-&gt;orig_pte))) &#123; <span class="comment">//如果映射的是0页, 则分配用户空间高端的页并用0进行初始化</span></span><br><span class="line">		new_page = alloc_zeroed_user_highpage_movable(vma,</span><br><span class="line">							      vmf-&gt;address);</span><br><span class="line">		<span class="keyword">if</span> (!new_page)</span><br><span class="line">			<span class="keyword">goto</span> oom;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是0页, 则分配高端的页, 并拷贝原来的page中数据到新页</span></span><br><span class="line">		new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,</span><br><span class="line">				vmf-&gt;address);</span><br><span class="line">		<span class="keyword">if</span> (!new_page)</span><br><span class="line">			<span class="keyword">goto</span> oom;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!cow_user_page(new_page, old_page, vmf)) &#123; <span class="comment">//拷贝page中数据</span></span><br><span class="line">		<span class="comment">// 不成功时错误处理</span></span><br><span class="line">			put_page(new_page); <span class="comment">//新页计数引用计数减1, </span></span><br><span class="line">			<span class="keyword">if</span> (old_page)</span><br><span class="line">				put_page(old_page); <span class="comment">//旧页引用计数减1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// cgroup相关设置</span></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_charge(new_page, mm, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">goto</span> oom_free_new;</span><br><span class="line">	cgroup_throttle_swaprate(new_page, GFP_KERNEL);</span><br><span class="line">	__SetPageUptodate(new_page); <span class="comment">// 设置新的页标识为PageUptodate, 表示该页是包含数据的页</span></span><br><span class="line">	mmu_notifier_range_init(&amp;range, MMU_NOTIFY_CLEAR, <span class="number">0</span>, vma, mm,</span><br><span class="line">				vmf-&gt;address &amp; PAGE_MASK,</span><br><span class="line">				(vmf-&gt;address &amp; PAGE_MASK) + PAGE_SIZE); <span class="comment">// 获得vma的线性地址范围</span></span><br><span class="line">	mmu_notifier_invalidate_range_start(&amp;range); <span class="comment">// 设置该范围invalidate</span></span><br><span class="line">	vmf-&gt;pte = pte_offset_map_lock(mm, vmf-&gt;pmd, vmf-&gt;address, &amp;vmf-&gt;ptl); <span class="comment">//锁住页表并获得现在的pte</span></span><br><span class="line">	<span class="keyword">if</span> (likely(pte_same(*vmf-&gt;pte, vmf-&gt;orig_pte))) &#123; <span class="comment">//检查锁住以后获得的pte和发生异常时的pte是否相同内容</span></span><br><span class="line">		<span class="keyword">if</span> (old_page) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!PageAnon(old_page)) &#123; <span class="comment">// old_page存在且不是匿名页</span></span><br><span class="line">				dec_mm_counter_fast(mm,</span><br><span class="line">						mm_counter_file(old_page)); <span class="comment">// 减旧页引用计数??</span></span><br><span class="line">				inc_mm_counter_fast(mm, MM_ANONPAGES); <span class="comment">// 加匿名页计数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// old_page不存在, 则加匿名页计数</span></span><br><span class="line">			inc_mm_counter_fast(mm, MM_ANONPAGES);</span><br><span class="line">		&#125;</span><br><span class="line">		flush_cache_page(vma, vmf-&gt;address, pte_pfn(vmf-&gt;orig_pte)); <span class="comment">//刷新cache中的页</span></span><br><span class="line">		entry = mk_pte(new_page, vma-&gt;vm_page_prot); <span class="comment">//构建新的页表项</span></span><br><span class="line">		entry = pte_sw_mkyoung(entry); <span class="comment">//设置pte被最近访问</span></span><br><span class="line">		entry = maybe_mkwrite(pte_mkdirty(entry), vma); <span class="comment">//设置pte脏且可写</span></span><br><span class="line">		ptep_clear_flush_notify(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">// 将页表原来的值清除, 刷新缺页时地址对应的tlb中pte的记录</span></span><br><span class="line">		page_add_new_anon_rmap(new_page, vma, vmf-&gt;address, <span class="literal">false</span>); <span class="comment">// 添加物理页到vma对应的匿名页反向映射中</span></span><br><span class="line">		lru_cache_add_inactive_or_unevictable(new_page, vma); <span class="comment">//将新的物理页添加到活跃或不可回收的lru链表中</span></span><br><span class="line">		set_pte_at_notify(mm, vmf-&gt;address, vmf-&gt;pte, entry); <span class="comment">//将构建好的entry页表项加入到vm的页表记录中</span></span><br><span class="line">		update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">// 更新mmt的tlb</span></span><br><span class="line">		<span class="keyword">if</span> (old_page) &#123;</span><br><span class="line">			page_remove_rmap(old_page, <span class="literal">false</span>);  <span class="comment">// 如果存在old_page, 从原来的页从虚拟页反向映射中删除, 并将其页的应用计数减1</span></span><br><span class="line">		&#125;</span><br><span class="line">		new_page = old_page;</span><br><span class="line">		page_copied = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		update_mmu_tlb(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">// 不相同时更新mmu的tlb信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (new_page)</span><br><span class="line">		put_page(new_page); <span class="comment">// 新page的引用减1</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	mmu_notifier_invalidate_range_only_end(&amp;range);</span><br><span class="line">	<span class="keyword">if</span> (old_page) &#123; <span class="comment">// 旧页存在的话</span></span><br><span class="line">		 <span class="comment">//如果已经映射了新的page, 但是旧的page对应的vma是Locked状态, 则旧的页被锁住, 这时需要将其解锁</span></span><br><span class="line">		<span class="keyword">if</span> (page_copied &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) &#123;</span><br><span class="line">			lock_page(old_page);	<span class="comment">/* LRU manipulation */</span></span><br><span class="line">			<span class="keyword">if</span> (PageMlocked(old_page))</span><br><span class="line">				munlock_vma_page(old_page); <span class="comment">// 解锁旧的页</span></span><br><span class="line">			unlock_page(old_page);</span><br><span class="line">		&#125;</span><br><span class="line">		put_page(old_page); <span class="comment">//旧页引用减1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page_copied ? VM_FAULT_WRITE : <span class="number">0</span>; <span class="comment">//如果拷贝page成功则返回VM_FAULT_WRITE, 其他返回0, 这个VM_FAULT_WRITE会一直向上传递给do_user_addr_fault</span></span><br><span class="line">oom_free_new:</span><br><span class="line">	put_page(new_page); <span class="comment">// oom时将新页引用减1</span></span><br><span class="line">oom:</span><br><span class="line">	<span class="keyword">if</span> (old_page)</span><br><span class="line">		put_page(old_page); <span class="comment">//oom时将旧页引用减1</span></span><br><span class="line">	<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>wp_page_reuse</code>(定义在<code>mm/memory.c :2789</code>处)中完成了pte的状态重新设置为可写,并更新mmu的tlb等操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wp_page_reuse</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(vmf-&gt;ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">vmf</span>-&gt;<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		page_cpupid_xchg_last(page, (<span class="number">1</span> &lt;&lt; LAST_CPUPID_SHIFT) - <span class="number">1</span>);</span><br><span class="line">	flush_cache_page(vma, vmf-&gt;address, pte_pfn(vmf-&gt;orig_pte)); <span class="comment">//flush cache数据</span></span><br><span class="line">	entry = pte_mkyoung(vmf-&gt;orig_pte); <span class="comment">// 设置pte页的标记为被访问</span></span><br><span class="line">	entry = maybe_mkwrite(pte_mkdirty(entry), vma); <span class="comment">// 设置pte页为脏,如果所在vma是可写的, 则设置pte为可写的.</span></span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vma, vmf-&gt;address, vmf-&gt;pte, entry, <span class="number">1</span>))</span><br><span class="line">		update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte); <span class="comment">//设置pte可访问, 并更新mmu的tlb缓存数据</span></span><br><span class="line">	pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">	count_vm_event(PGREUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于共享的页面通过<code>wp_page_shared</code>设置页可写或通过<code>wp_page_reuse</code>完成页的状态变更 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">wp_page_shared</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(vmf-&gt;ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">vmf</span>-&gt;<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">vm_fault_t</span> ret = VM_FAULT_WRITE;</span><br><span class="line"></span><br><span class="line">	get_page(vmf-&gt;page); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;page_mkwrite) &#123;</span><br><span class="line">		<span class="keyword">vm_fault_t</span> tmp;</span><br><span class="line"></span><br><span class="line">		pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">		tmp = do_page_mkwrite(vmf);  <span class="comment">// 设置page可写</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tmp || (tmp &amp;</span><br><span class="line">				      (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) &#123;</span><br><span class="line">			put_page(vmf-&gt;page);</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = finish_mkwrite_fault(vmf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(tmp &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) &#123;</span><br><span class="line">			unlock_page(vmf-&gt;page);</span><br><span class="line">			put_page(vmf-&gt;page);</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wp_page_reuse(vmf);  <span class="comment">// 通过wp_page_reuse 完成页设置</span></span><br><span class="line">		lock_page(vmf-&gt;page);</span><br><span class="line">	&#125;</span><br><span class="line">	ret |= fault_dirty_shared_page(vmf); </span><br><span class="line">	put_page(vmf-&gt;page); </span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此COW机制得到完成, page fault返回后,操作系统会重新执行引起page fault的动作. </p>
<p><em>ps: 这里是如何做到重新执行引起page fault的动作的? 书上的找到<code>ret_from_exception</code>和<code>resume_userspace</code>函数x86_64下并未找到. 这里我看在<code>entry_64.S</code>的中断响应程序结尾处, 会执行<code>jne    swapgs_restore_regs_and_return_to_usermode</code>以及<code>SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</code>, 这里会重新回到被中断的进程那里重新执行中断前的逻辑, 查阅文献发现这个功能是由硬件支持的</em></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当进行fork时,父子进程将所有私有可写的物理页进行共享, 并将其对应的页表项设置为只读, 当任意一方尝试写时, 会引起COW的缺页异常, 异常处理程序会为写操作方分配一个新的物理页, 并将原来共享的物理页内容拷贝到新页中, 之后重新建立新页的页表映射到新的物理页, 并设置为可写. 如果在缺页异常处理时发现共享的页只有一个使用者, 则直接设置这个页面为可写即可.</p>
<p>内存管理的实现复杂, 这一块还需要进一步学习, 部分实现原理和机制还需要结合深入理解Linux内核书本上的概念进行理解.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
              <a href="/tags/kernel/" rel="tag"># kernel</a>
          </div>

        
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link rel="stylesheet" href="/css/highlight/styles/github.css">

<!--
 <script src="https://utteranc.es/client.js"
        repo="woodpenker/woodpenker.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script> 
-->


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/02/%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%9D%E8%80%83/" rel="prev" title="关于原子性与数据竞争的学习和思考">
      <i class="fa fa-chevron-left"></i> 关于原子性与数据竞争的学习和思考
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/03/XPS13-intel-CPU%E8%B6%85%E9%A2%91%E5%AF%BC%E8%87%B4%E5%8F%91%E7%83%AD%E4%B8%A5%E9%87%8D/" rel="next" title="XPS13-intel-CPU超频导致发热严重">
      XPS13-intel-CPU超频导致发热严重 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#COW写时复制的实现分析"><span class="nav-number">1.</span> <span class="nav-text">COW写时复制的实现分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏观理解COW"><span class="nav-number">2.</span> <span class="nav-text">宏观理解COW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#涉及到的一些基本概念和数据结构"><span class="nav-number">3.</span> <span class="nav-text">涉及到的一些基本概念和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析对象"><span class="nav-number">4.</span> <span class="nav-text">分析对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork系统调用中的COW"><span class="nav-number">5.</span> <span class="nav-text">fork系统调用中的COW</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存的拷贝"><span class="nav-number">5.1.</span> <span class="nav-text">内存的拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#针对内存大页tlb的拷贝处理"><span class="nav-number">5.1.0.1.</span> <span class="nav-text">针对内存大页tlb的拷贝处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#针对默认普通页的拷贝处理"><span class="nav-number">5.1.0.2.</span> <span class="nav-text">针对默认普通页的拷贝处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理大pmd的拷贝-copy-huge-pmd"><span class="nav-number">5.1.0.3.</span> <span class="nav-text">处理大pmd的拷贝: copy_huge_pmd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理对普通pmd下的所有pte的拷贝-copy-pte-range"><span class="nav-number">5.1.0.4.</span> <span class="nav-text">处理对普通pmd下的所有pte的拷贝: copy_pte_range</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不在物理内存中的pte的拷贝"><span class="nav-number">5.1.0.5.</span> <span class="nav-text">不在物理内存中的pte的拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处于物理内存中的pte的拷贝"><span class="nav-number">5.1.0.6.</span> <span class="nav-text">处于物理内存中的pte的拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存COW缺页异常的触发和处理"><span class="nav-number">5.2.</span> <span class="nav-text">内存COW缺页异常的触发和处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#处理hugetlb的page-fault错误"><span class="nav-number">5.2.1.</span> <span class="nav-text">处理hugetlb的page fault错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理普通页的page-fault错误"><span class="nav-number">5.2.2.</span> <span class="nav-text">处理普通页的page fault错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">woodpenker</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">woodpenker</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">271k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">4:07</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'TQssKihDiGGbSY1kYhITVjH6-gzGzoHsz',
      appKey     : 'nR7QfbpY2Pp701SrxCfINdpm',
      placeholder: "Go go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
